
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="Author" content="IBM">
   <meta name="GENERATOR" content="Mozilla/4.5 [en] (Win98; I) [Netscape]">
   <title>Package-level Javadoc</title>
</head>
<body>


"package","org/eclipse/jface/dialogs","\nProvides support for dialogs.\n<h2>\nPackage Specification</h2>\nA dialog is a specialized window, typically consisting of a dialog area\nand a button bar, designed for narrow-focussed communication with the user.\n<p>The dialog framework consists of an abstract base class (<tt>Dialog</tt>),\nalong with more concrete dialog subclasses for displaying messages (<tt>MessageDialog</tt>),\nsoliciting text input (<tt>InputDialog</tt>), and displaying progress during\na long-running operation (<tt>ProgressMonitorDialog</tt>).\n<p>Dialog stores (<tt>IDialogStore</tt>, <tt>DialogStore</tt>) provide\na general framework for organizing a dialog's settings into key/value pairs.\nMulti-page dialogs are made easier through the use of dialog pages (<tt>IDialogPage</tt>,\n<tt>DialogPage</tt>).\n<p>Note: None of the classes in this package maintain global state.\n<br>&nbsp;\n<br>&nbsp;\n<br>&nbsp;\n"
"package","org/eclipse/jface/layout","\nProvides support for layout generation. \n<h2>\nPackage Specification</h2>\n<p> This package provides classes that can be used to generate layouts.\n"
"package","org/eclipse/jface/resource","\nProvides support for managing resources such as SWT\nfonts and images.\n<h2>\nPackage Specification</h2>\nThis package contains support for managing resources, including:\n<ul>\n<li>\nfont registries (<tt>FontRegistry</tt>) - for hanging on to the SWT font\nobjects needed by an application</li>\n\n<li>\ncolor registries (<tt>ColorRegistry</tt>) - for hanging on to the SWT color \nobjects needed by an application</li>\n\n<li>\nimage registries (<tt>ImageRegistry</tt>) - for hanging on to the SWT image\nobjects needed by an application</li>\n\n<li>\nimage descriptors (<tt>ImageDescriptor</tt>) - surrogate object for creating\nSWT images</li>\n\n<li>\nstring conversion (<tt>StringConverter</tt>) - for parsing property files</li>\n</ul>\nThe JFace resources module is an independent JFace module requiring a basic\nknowledge of SWT and the JFace property change event mechanism. Familiarity\nwith other JFace modules is not required.\n<p>Image descriptors are objects that knows how to create an image on demand.\nThey serve as a lightweight representation of images in situations where\nno SWT display exists yet, and are used mainly in conjunction with image\nregistries. This package contains the image descriptor framework, which\nis a simple hierarchy rooted at the abstract class <tt>ImageDescriptor</tt>.\nThe framework includes abstract subclasses for composing images (<tt>CompositeImageDescriptor</tt>)\nas well as a ready-made concrete subclass for loading images from files\n(<tt>FileImageDescriptor</tt>).\n<p>The class <tt>JFaceResources</tt> maintains global state on behalf of\nJFace itself consisting of JFace's own image registry, font registry, resource\nbundle, and preference store.\n<br>&nbsp;\n"
"package","org/eclipse/jface/operation","\nProvides JFace support for long-running operations.\n<h2>\nPackage Specification</h2>\nLong-running operations must be dealt with specially in order to keep the\nUI helpful and responsive. Typically this involves temporarily disabling\nmost controls and displaying a busy cursor and progress indicator; while\nthe operation is in progress, the only requests that will be accepted will\nbe ones to cancel the operation.\n<p>The <tt>IRunnableWithProgress</tt> interface should be implemented by\nany class whose instances are intended to be executed as long-running operations.\nThese objects can then be run in any runnable context (<tt>IRunnableContext</tt>),\nincluding such standard JFace UI components as application windows (<tt>ApplicationWindow</tt>),\nwizard dialogs (<tt>WizardDialog</tt>), and progress monitor dialogs (<tt>ProgressMonitorDialog</tt>).\nThe utility class <tt>ModalContext</tt> defines the basic mechanism and\nUI event loop for modal operations.\n"
"package","org/eclipse/jface/contentassist","\nProvides a content assist add-on for implementors of <tt>IContentAssistSubjectControl</tt>.\nContent assist supports the user in writing&nbsp; by proposing context\nsensitive completions at a given position. A completion can also\nbe a incomplete in itself and content assist provides means to deal with\nnested completions.\n<h2>\nPackage Specification</h2>\n<tt>ISubjectControlContentAssistant</tt> defines the concept of the content assist add-on.\nIt collaborates with content type specific completion processors (<tt>ISubjectControlContentAssistProcessor</tt>)\nin order to generate completion proposals (<tt>ICompletionProposal</tt>)\nvalid at the current document position. The package provides a default\nimplementation <tt>SubjectControlContentAssistant</tt> which completely defines and implements\nthe UI and the control flow for content assist.\n<br>\n<br>\n<strong>Deprecated, as of 3.2, replaced by Platform UI's field assist support</strong>\n"
"package","org/eclipse/jface/preference","\nProvides a framework for preferences.\n<h2>\nPackage Specification</h2>\nA <b>preference manager</b> (class <tt>PreferenceManager</tt>) maintains\na tree of <b>preference nodes</b>. Preferences are presented to the end\nuser in a <b>preference dialog</b> consisting of <b>preference pages</b>.\nA preference page consists of multiple preference fields, which can be\ndisplayed and modified though <b>field editors</b>. The framework contains\nan abstract base class for preference dialogs (<tt>PreferenceDialog</tt>),\nand an abstract preference page class (<tt>FieldEditorPreferencePage</tt>)\nfor hosting these field editors.\n<p>The individual preference values are maintained in a <b>preference store</b>\n(<tt>IPreferenceStore</tt>). Each preference has a current value and a\ndefault value use to (re-)initialize it. The framework provides a concrete\npreference store implementation (<tt>PreferenceStore</tt>) based on an\ninternal <tt>java.util.Properties</tt> object, with support for persisting\nthe non-default preference values to files or streams.\n<p>A field editor presents the value of a single preference to the end\nuser. The value is loaded from the preference store; if modified by the\nend user, the value is validated and eventually stored back to the preference\nstore.\n<p>This package contains ready-to-use field editors for various types of\npreferences:\n<ul>\n<li>\n<tt>BooleanFieldEditor</tt> - booleans</li>\n\n<li>\n<tt>IntegerFieldEditor</tt> - integers</li>\n\n<li>\n<tt>StringFieldEditor</tt> - text strings</li>\n\n<li>\n<tt>RadioGroupFieldEditor</tt> - enumerations</li>\n\n<li>\n<tt>ColorFieldEditor</tt> - RGB colors</li>\n\n<li>\n<tt>FontFieldEditor</tt> - fonts</li>\n\n<li>\n<tt>DirectoryFieldEditor</tt> - directories</li>\n\n<li>\n<tt>FileFieldEditor</tt> - files</li>\n\n<li>\n<tt>PathEditor</tt> - paths</li>\n</ul>\nAll field editors are subclasses of the abstract base class <tt>FieldEditor</tt>;\nthe framework allows new kinds of field editors to be defined by subclassing\nthis class or one of its subclasses.\n<p>Note: None of the classes in this package maintain global state.\n<br>&nbsp;\n"
"package","org/eclipse/jface/wizard","\nProvides a framework for wizards.\n<h2>\nPackage Specification</h2>\nA wizard dialog is a specialized window for walking the end user through\na sequence of steps; each step is presented on a separate page.\n<p>At the most abstract level, the protocol is given by 3 interfaces:\n<ul>\n<li>\n<tt>IWizard</tt> - a wizard consisting of several wizard pages</li>\n\n<li>\n<tt>IWizardPage</tt> - an individual wizard page</li>\n\n<li>\n<tt>IWizardContainer</tt> - the outside world from the point of view of\na wizard</li>\n</ul>\nA wizard is any object implementing <tt>IWizard</tt>. The abstract base\nclass <tt>Wizard</tt> is provided as a starting point; it is simpler to\nsubclass <tt>Wizard</tt> than to implement <tt>IWizard</tt> from scratch.\nThe main responsibility of a <tt>Wizard</tt> subclass is doing the real\nwork when the wizard finishes.\n<p>Similarly, a wizard page is any object implementing <tt>IWizardPage</tt>.\nThe abstract base class <tt>WizardPage</tt> is provided as a starting point.\nThe main responsibility of a <tt>WizardPage</tt> subclass is providing\nthe SWT controls and the backing logic for a single wizard page.\n<p><tt>WizardDialog</tt> is a ready-to-use JFace dialog that is instantiated\nwith a wizard and acts as the wizard's container. This dialog has a standard\nlayout: an area at the top containing the wizard's title, description,\nand image; the actual wizard page appears in the middle; below it is a\nprogress indicator; and at the bottom is an area with a message line and\na button bar containing Next, Back, Finish, Cancel, and Help buttons.\n<p><tt>WizardSelectionPage</tt>, a special abstract subclass of <tt>WizardPage</tt>,\nallows whole other wizards to be connected to a root page.\n<p>Note: None of the classes in this package maintain global state.\n<br>&nbsp;\n"
"package","org/eclipse/jface/internal/text",""
"package","org/eclipse/jface/internal/text/revisions","\n<p>\nInternal classes and helpers to implement the revision model and its UI presentation. See\nthe <tt><a href="../../../text/revisions/package.html">org.eclipse.jface.text.revisions</a></tt>\npackage for the API classes implementing the revision model.\n</p>\nContains everything needed to:\n<ul>\n  <li>paint revision information in the vertical ruler</li>\n  <li>adapt the revision information to (quick) diff scripts</li>\n</ul>\n<p>\nThis package is internal and may be subject to change without notice.\n</p>\n"
"package","org/eclipse/jface/internal/text/link/contentassist","\nThis package is a modified copy of <code>org.eclipse.jface.text.contentassist</code> that supports the linked mode proposals.\nThis package is internal and may disappear if the changes are merged with the API content assist package. Subject to change without notice.\n"
"package","org/eclipse/jface/internal/text/html",""
"package","org/eclipse/jface/internal/text/source","\n<p>\nInternal support classes and helpers for the <tt>org.eclipse.jface.text.source</tt> package.\n"
"package","org/eclipse/jface/bindings","\n<p>Provides support for bindings between commands and various user input events\n(e.g., keyboard shortcuts).</p>\n\n<h2>Package Specification</h2>\n<p>\nThis package provides the common classes and abstract classes required to\nprovide binding support.\n</p>\n<p>\nAll the real work in this package is carried out by the\n<code>BindingManager</code>, and most work with bindings can be carried out\ndirectly with it.  The binding manager manages a collection of bindings, and\ndecides which bindings are active at any point in time.  By changes the various\nproperties of the manager, the active bindings will change.  The binding\nmanager implements a caching scheme that is optimized for an infreqeuntly\nchanging set of bindings, but frequently changing properties.\n</p>\n<p>\nThe binding manager also manages schemes.  A scheme is a grouping of bindings.\nTo create a scheme, use <code>BindingManager.getScheme(String)</code>.  The\nscheme must then be defined before it can be used.\n</p>\n<p>\nIf you wish to implement your own type of binding, then you must subclass\n<code>Trigger</code> and <code>TriggerSequence</code>.  Then, simply use these\nsubclasses with the <code>BindingManager</code>.\n</p>\n"
"package","org/eclipse/jface/bindings/keys","\n<p>Provides support for bindings between commands and keys.</p>\n\n<h2>Package Specification</h2>\n<p>\nThis just a key-specific implementation of the generic bindings and trigger\nsupport.  This package provides an abstraction layer between the SWT key events\nand key bindings within JFace.\n</p>\n<p>\n<code>KeySequence</code> is a <code>TriggerSequence</code> that has\n<code>KeyStroke</code> instances as triggers.  A <code>KeyStroke</code> is\ncomposed of one or more keys held down at the same time.  A key stroke ends\nwhen the keys are released.  A key stroke can contain zero or more modifiers\nkeys, but it always contains exactly one natural key.  A modifier key is one of\nCtrl, Shift, Alt, or Command.  A natural key is anything else.</p>\n<p>\nNatural keys are further subdivided into special keys and character keys.\nCharacter keys are keys that have an ASCII representation (e.g., Space, 'A' and\nBackspace).  Special keys are ones that do not (e.g., Arrow Up, F11, and\nNumLock).\n</p>\n<p>\n<code>SWTKeySupport</code> is a static class that provides the link between SWT\nand these internal representations.  It has methods for converting between SWT\nkey events and the internal representation, and vice versa.  It also provides\naccess to the native-style key formatting facilities.\n</p>\n"
"package","org/eclipse/jface/bindings/keys/formatting","\n<p>Provides support for formatting key sequences.</p>\n\n<h2>Package Specification</h2>\n<p>\nThis is a collection fo various formatters for key sequences.  The formatters\nare accessible through the <code>KeyFormatterFactory</code>.  To change how\nkeys are formatted in the user interface, call\n<code>KeyFormatterFactory.setDefault(IKeyFormatter)</code>.  They provided\nformatters are:\n</p>\n<dl>\n<dt>FormalKeyFormatter</dt>\n<dd>Provides a formal grammar for reading and writing key sequences.</dd>\n<dt>NativeKeyFormatter</dt>\n<dd>Provide a native-looking, human-readable format for keys.</dd>\n<dt>CompactKeyFormatter</dt>\n<dd>A variation of the native formatter that provides a more compact representation.</dd>\n<dt>EmacsKeyFormatter</dt>\n<dd>An Xemacs-style formatter (e.g., C^x C^x).</dd>\n</dl>\n"
"package","org/eclipse/jface/viewers","\nProvides a framework for viewers, which are model-based\ncontent adapters for SWT widgets.\n<h2>\nPackage Specification</h2>\nA viewer is a model-based adapter on an SWT widget.&nbsp; Each viewer has\nfour parts:\n<blockquote>\n<li>\nan <b>input</b> - the object that serves as the viewer's model</li>\n\n<li>\na <b>widget</b> - the SWT control through which the viewer's model is displayed</li>\n\n<li>\na <b>content provider</b> - mediates between the model and viewer</li>\n\n<li>\na <b>label provider</b> - maps model objects to displayable labels containing\ntext and/or an image</li>\n</blockquote>\nThis package contains the viewer framework. The viewer framework is an\nindependent JFace module. Using it requires a knowledge of SWT, but does\nnot require familiarity with any of the other JFace modules. The framework\nconsists of abstract base classes for viewers (<tt>Viewer</tt>, <tt>StructuredViewer</tt>,\n<tt>AbstractTreeViewer</tt>) together with concrete viewer classes (<tt>ListViewer</tt>,\n<tt>TreeViewer</tt>,\n<tt>TableViewer</tt>,\n<tt>TableTreeViewer</tt>, <tt>CheckboxTreeViewer</tt>,\nand <tt>CheckboxTableViewer</tt>),\nand various lesser support classes. The concrete structured viewer classes\nare ready-to-use and have built-in support for drag-and-drop, filtering\n(<tt>IViewerFilter</tt> and <tt>ViewerFilter</tt>), and sorting (<tt>IViewerSorter</tt>\nand <tt>ViewerSorter</tt>); these classes may also be subclassed further\nif required.\n<p>In general terms, creating a viewer involves the following steps:\n<ul>\n<li>\ninstantiating a viewer on some pre-existing SWT widget,</li>\n\n<li>\nsetting the viewer's content provider (an object implementing <tt>IContentProvider</tt>),</li>\n\n<li>\nsetting the viewer's label provider (an object implementing\n<tt>ILabelProvider</tt>),</li>\n\n<li>\nand, finally, setting the viewer's input.</li>\n</ul>\nOnce a viewer's input is set, the viewer becomes active. As the model changes,\nit is the content provider's responsibility to respond to changes to the\nmodel by telling the viewer what to change (done by calling add and remove\nmethods on the viewer). An existing viewer may be retargeted by giving\nit a different object as input; the viewer is responsible for informing\nthe content provider of these kinds of wholesale changes (<tt>IContentProvider.inputChanged</tt>).\nAlso, each viewer registers with its label provider for notification of\nchanges that would affect what the viewer displays (see <tt>ILabelProviderListener.stateChanged</tt>).\n<p>Note: None of the classes in this package maintain global state.\n<br>&nbsp;\n"
"package","org/eclipse/jface/viewers/deferred","\nProvides a framework for viewers that handle deferred contents. \n<h2>\nPackage Specification</h2>\n<p>The deferred viewers are viewers that can handle concurrent updates from a \n  variety of Threads.<br>\n  &nbsp; \n"
"package","org/eclipse/jface/window","\nProvides a general framework for creating and managing\nwindows.\n<h2>\nPackage Specification</h2>\nA JFace window is an object that has no visual representation (no widgets)\nuntil it is told to open. All JFace windows, including dialogs, are instances\nof the abstract class <tt>Window</tt> or a subclass. This package contains\nthe base window classes:\n<tt>Window</tt> itself, which provides support\nfor a basic windows; and <tt>ApplicationWindow</tt>, which provides ready-to-use\nsupport for a high-level "main window" with standard menus, tool bar, and\nstatus line. Both of these classes may be subclassed to define additional\ntypes of window as required.\n<p>This package also contains <tt>WindowManager</tt>, instance of which\nare used for managing a group of windows. Window managers are useful in\napplications which create many different windows (dialogs, wizards, etc.)\nin addition to a main window. Window managers are not required for simple\napplications.\n<p>The only global state maintained by classes in this package is a default\nimage for window title bars (<tt>Window.setDefaultImage</tt>).\n"
"package","org/eclipse/jface/menus","\nProvides support for trim specification. \n<h2>\nPackage Specification</h2>\n<p> This package provides classes for trim widgets.\n"
"package","org/eclipse/jface/text",""
"package","org/eclipse/jface/text/revisions","\nProvides a revision model and a protocol to display revision information in a vertical ruler column.\n<h2>Package Specification</h2>\n<tt>IRevisionRulerColumn</tt> is the protocol that a team provider can use to display line based revision control information to a document.\n<tt>RevisionInformation</tt> defines the revision model, which contains a list of <tt>Revision</tt>s, which in turn contain <tt>RevisionRange</tt>s.\n"
"package","org/eclipse/jface/text/reconciler","\nProvides a reconciler add-on for an <tt>ITextViewer</tt>.\nA&nbsp; reconciler provides generic synchronization support&nbsp; with\nthe content of the document serving as the <tt>ITextViewer</tt>'s input.\nThere is no explicit model of what is synchronized.\n<h2>\nPackage Specification</h2>\n<tt>IReconciler</tt> defines the concept of a reconciler. It collaborates\nwith content type specific reconciling strategies (<tt>IReconcilingStrategy</tt>)\nwhich perform the synchronization for a given dirty region. The package\ncontains a default implementation of <tt>IReconciler</tt> (<tt>Reconciler</tt>).\n\n<tt>Reconciler</tt> and <tt>MonoReconciler</tt> implements reconciling\nas a periodic background activity and folds co-located changes while being\ninactive.\n"
"package","org/eclipse/jface/text/link",""
"package","org/eclipse/jface/text/contentassist","\nProvides a content assist add-on for an <tt>ITextViewer</tt>.\nContent assist supports the user in writing&nbsp; by proposing context\nsensitive completions at a given document position. A completion can also\nbe a incomplete in itself and content assist provides means to deal with\nnested completions.\n<h2>\nPackage Specification</h2>\n<tt>IContentAssistant</tt> defines the concept of the content assist add-on.\nIt collaborates with content type specific completion processors (<tt>IContentAssistProcessor</tt>)\nin order to generate completion proposals (<tt>ICompletionProposal</tt>)\nvalid at the current document position. The package provides a default\nimplementation <tt>ContentAssistant</tt> which completely defines and implements\nthe UI and the control flow for content assist.\n<br>&nbsp;\n"
"package","org/eclipse/jface/text/templates",""
"package","org/eclipse/jface/text/templates/persistence","\nProvides persistence support for templates.\n<h3>Packages</h3>\n<ul>\n  <li><tt><big><strong>org.eclipse.jface.text.templates</strong></big></tt></li>\n  <li><tt><big><strong>org.eclipse.ui.workbench.texteditor.templates</strong></big></tt></li>\n  <li><tt><big><strong>org.eclipse.ui.editors.templates</strong></big></tt></li>\n</ul>\n<h3>Introduction</h3>\nTemplates are shortcuts for frequently used fragments of text such as\ncode patterns or complex text entities. They may contain variables\nwhich are only resolved at the time when the template is inserted\nwithin a context. Together with linked mode, inserting a template can\ncreate a on-the-fly edit mask within a text viewer.<br>\n<br>\nTemplates are specified as text, variables are defined using the <tt>${variable}</tt>\nnotation known from\nAnt, for example. The following snippet shows an example template for\nan instance check in Java:<br>\n<pre>if (${name} instanceof ${type}) {\n&nbsp;&nbsp;&nbsp; ${type} ${new_name} = (${type})${name};\n&nbsp;&nbsp;&nbsp; ${cursor}\n}\n</pre>\nIn this template, the variables (<tt>name,type, ...</tt>) are resolved\nwhen inserted into java source and changing one variable instance will\nalso change the other. When leaving linked mode, the caret is placed at\nthe <tt>cursor</tt> variable.<br>\n<br>\nTemplate functionality can be added to a custom text editor by offering\n<tt>TemplateProposal</tt>s as content assist choices, which is\nsimplified by using a subclass of <tt>TemplateCompletionProcessor</tt>. User template management can be\noffered by including a <tt>TemplatePreferencePage</tt> which uses a <tt>TemplateStore</tt> and <tt>ContextTypeRegistry</tt> as the\nunderlying model to store templates. The <tt>org.eclipse.ui.editors.templates</tt>\nextension point can be used to allow other plug-ins to contribute\ntemplates to an editor. This is accomplished by using the <tt>ContributionTemplateStore</tt> and <tt>ContributionContextTypeRegistry</tt>\nsubclasses of the above types.<br>\n<br>\nTemplate variables are resolved by a <tt>TemplateVariableResolver.</tt> <tt>GlobalTemplateVariables</tt> offers\nsome default variables such as date, user, and selection, but advanced\nfeatures such as resolving to language constructs can be performed in\nsubclasses.<br>\n<h4>Classes</h4>\n<ul>\n  <li><tt>Template</tt> a template consists of name, context\ntype identifier, and a pattern.</li>\n  <li><tt>TemplateTranslator</tt> and <tt>TemplateBuffer</tt> are used to\nparse the template grammar and don't need to be used usually.</li>\n  <li>A <tt>TemplateProposal </tt>can be\noffered in content assist, possibly created by a subclass of <tt>TemplateCompletionProcessor.</tt></li>\n  <li><tt>TemplateStore</tt> and <tt>ContextTypeRegistry</tt> manage a\nset of templates within a plug-in and offer ways to store them in the\npreferences or externally in XML streams via a <tt>TemplateReaderWriter</tt>.<br></li>\n  <li><tt>ContributionTemplateStore</tt> and <tt>ContributionContextTypeRegistry</tt>\nadd awareness for the  <tt>org.eclipse.ui.editors.templates</tt>\nextension point.</li>\n  <li><tt>TemplatePreferencePage</tt> allows\nthe user to access the templates within a <tt>TemplateStore.</tt></li>\n</ul>\n<ul>\n</ul>\n<h4>Example</h4>\nSee the Template Editor Example in the <strong>org.eclipse.ui.examples.javaeditor</strong> project.<br>\n"
"package","org/eclipse/jface/text/information","\nProvides an information provider add-on for an <tt>ITextViewer</tt>.\nAn information provider presents information for a certain subject in a\nspecific information control. An information control usually is a floating\nwindow.\n<h2>\nPackage Specification</h2>\n<tt>IInformationPresenter</tt> defines the concept of an information provider.\nIt collaborates with content type specific information providers (<tt>IInformationProvider</tt>)\nwhich determine for a certain offset in a text viewer an information subject\nand the information available about this subject.. The package contains\na default implementation of <tt>IInformationPresenter</tt> (<tt>InformationPresenter</tt>).\n"
"package","org/eclipse/jface/text/rules","\nProvides a framework for rule based text scanning\nand uses the framework to provide rule-driven default implementations of\n<tt>IPresentationDamager</tt>, <tt>IPresentationRepairer</tt> and <tt>IDocumentPartitioner</tt>.\n<h2>\nPackage Specification</h2>\n<tt>RuleBasedScanner</tt> is a document-based scanner controlled by <tt>IRule</tt>\nobjects. When evaluated an <tt>IRule</tt> always returns an <tt>IToken</tt>.\nThe package provides a set of rules whereby <tt>PatternRule</tt> is the\nmost important one. <tt>PatternRule</tt> defines a pattern-configurable\nrule.\n"
"package","org/eclipse/jface/text/formatter","\nProvides a content formatter add-on for an <tt>ITextViewer</tt>.\nA content formatter changes the formatting of a document region while\npreserving and correctly updating the positions of the document.\n<h2>Package Specification</h2>\n<tt>IContentFormatter</tt> defines the concept of a text formatter. It\ncollaborates with content type specific formatting stratgies (<tt>IFormattingStrategy</tt>)\nwhich for a given document region format the subregion with the\nmatching\ncontent type. The package contains a default implementation of <tt>IContentFormatter</tt>\n(<tt>ContentFormatter</tt>).<br>\nAdditionally, an implementation of <tt>IContentFormatterExtension</tt>\nis provided\nfor text edit based formatting strategies. This implementation only\naccepts formatting strategies\nimplementing the extension interface <tt>IFormattingStrategyExtension</tt>.\nThese formatting strategies are required to handle the position\nupdating of the document. To facilitate the work with these text edit\nbased formatting strategies, a default implementation called <tt>ContextBasedFormattingStrategy</tt>\nis provided. Formatting strategies inheriting from this class are text\nedit based and behave context dependent. Depending on the formatting\ncontext that is passed\nto the content formatter, different preferences and modes can be used\nto format different parts of a document.\n<p>To set up a proper working text edit based content formatter, the\nfollowing steps are needed:\n</p>\n<ul>\n  <li>Create an instance of <tt>IFormattingContext</tt>. The default\nimplementation <tt>FormattingContext</tt> already\nprovides support for the conversion of preferences from a preference\nstore to a map and vice versa. The method <tt>getPreferenceKeys</tt>\nusually has to be overridden to return the appropriate keys of the\npreferences used during the formatting process. Then register a map of\npreferences\nwith the formatting context by calling <tt>setProperty(String, Object)</tt>\nwith the property identifier <tt>FormattingContextProperties.CONTEXT_PREFERENCES</tt>.</li>\n  <li>Create an instance of the text edit based content formatter class\n    <tt>MultiPassContentFormatter</tt>. The document partitioning and\nits associated\ndefault content type have to be passed to the constructor. This\ninformation is needed since the content formatter is able to format\ndocuments\naccording to arbitrary partitionings and default content types.</li>\n  <li>Register the formatting strategies for the content types that\nhave to be formatted. If a formatting strategy is\nregistered as master strategy, it is automatically associated with the\ndefault content type of the specified partitioning.\nIf the formatting strategy is registered as slave strategy, it is\nassociated with the indicated content type during the registration.\nNote that the master strategy can also be registered as a slave\nstrategy for a content type other than the default content type.</li>\n  <li>Specify the proper formatting mode (see\nFormattingContextProperties):\n    <ul>\n      <li>For whole document formatting set the property <tt>CONTEXT_DOCUMENT</tt>\nof the created formatting context to <tt>true</tt>. This is\nequivalent to setting <code>CONTEXT_REGION</code> with a region\nspanning the whole document.</li>\n      <li>For multiple region formatting set the property <code>CONTEXT_REGION</code>\nof the formatting context. Note that the content formatter\nautomatically aligns the offset of a region to a line start for the\nmaster formatting strategy, it also completes eventual partitions\ncovered only partially by the region for the slave formatting\nstrategies.</li>\n      <li>For explicit formatting of a partition with the formatting\nstrategy registered for a certain content type use the\nproperty <tt>CONTEXT_PARTITION</tt>. Note that the region denoted by\nthis property must correspond to a partition relative to the specified\npartitioning in the document to be formatted. The content type of this\nproperty overrides the content type of the partition\nin the document.</li>\n    </ul>\n  </li>\n  <li>Call the method <tt>MultiPassContentFormatter#format(IDocument,\nIFormattingContext)</tt> with the created formatting context\nand the document to be formatted.</li>\n</ul>\n<p></p>\n"
"package","org/eclipse/jface/text/hyperlink","\nProvides support for detecting and displaying hyperlinks in <tt>ISourceViewer</tt>s.\n<p>\n<tt>SourceViewer</tt> supports hyperlinked text regions inline in the displayed text. It delegates \nthe detection and presentation of hyperlinks to <tt>IHyperlinkDetector</tt> and <tt>IHyperlinkPresenter</tt>, respectively.\n</p>\n<p>\nOverride the following methods in <tt>SourceViewerConfiguration</tt> to customize the hyperlink behavior of a source viewer:\n<ul>\n  <li><tt>getHyperlinkDetectors()</tt> to specify the set of hyperlink detectors used by the viewer</li>\n  <li><tt>getHyperlinkPresenter()</tt> to specify the set of hyperlink presenters used by the viewer</li>\n  <li><tt>getHyperlinkStateMask()</tt> to specify when hyperlinks are activated</li>\n</ul>\n</p>\n\n"
"package","org/eclipse/jface/text/presentation","\nProvides a presentation reconciler add-on for an <tt>ITextViewer</tt>.\nA presentation reconciler keep the presentation (styles and colors) in\nsync with the content of the document serving as the <tt>ITextViewer</tt>'s\ninput.\n<h2>\nPackage Specification</h2>\n<tt>IPresentationReconciler</tt> defines the concept of a presentation\nreconciler. It collaborates with content type specific presentation damagers\n(<tt>IPresentationDamager</tt>) which for a given document change determine\nthe region of the presentation which must be rebuild, and content type\nspecific presentation repairers (<tt>IPresentationRepairer</tt>) which\nconstruct for a given damage region the document presentation. The package\ncontains a default implementation of <tt>IPresentationReconciler </tt>(<tt>PresentationReconciler</tt>).\n"
"package","org/eclipse/jface/text/source",""
"package","org/eclipse/jface/text/quickassist","\nThis package provides the quick assist assistant add-on for an <tt>ISourceViewer</tt>.\nThe quick assist assistant's purpose is to propose, display, and insert quick assists and quick fixes\navailable at the current source viewer's quick assist invocation context.\n<p>\nA quick fix is a completion that can correct a problem reported and visible through an <tt>Annotation</tt>\nwhile a quick assist is not related to a problem or <tt>Annotation</tt>. Since quick assists can be proposed\nwhere appropriate they are normally not visible in the viewer. The quick assist assistant implementation in\nthis package can show the quick assists that are available on the current line.\n</p>\n\n<h2>\nPackage Specification</h2>\n<tt>IQuickAssistAssistant</tt> defines the concept of the quick assist assistant add-on.\nIt collaborates with a quick assist processor (<tt>IQuickAssistProcessor</tt>)\nin order to generate quick fix and quick assist completion proposals (<tt>ICompletionProposal</tt>)\navailable at the current quick assist invocation context (<tt>IQuickAssistInvocationContext</tt>).\nThe package provides a default implementation <tt>QuickAssistAssistant</tt> which completely defines\nand implements the UI and the control flow for a quick assist assistant.\n<br>&nbsp;\n"
"package","org/eclipse/jface/commands","\n<p>Provides JFace-specific support for commands.</p>\n\n<h2>Package Specification</h2>\n<p>\nThis package provides a handler that wraps a legacy instance of\n<code>IAction</code>, as well as a manager for associating images with commands.\n</p>\n"




</body>
</html>



