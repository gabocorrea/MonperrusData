id,type,path,apidoc_Text
id,ï»¿type,path,apidoc_Text
3,package,org/eclipse/jface/layout,\nProvides support for layout generation. \n<h2>\nPackage Specification</h2>\n<p> This package provides classes that can be used to generate layouts.\n
9,package,org/eclipse/jface/internal/text,
12,package,org/eclipse/jface/internal/text/html,
13,package,org/eclipse/jface/internal/text/source,\n<p>\nInternal support classes and helpers for the <tt>org.eclipse.jface.text.source</tt> package.\n
20,package,org/eclipse/jface/menus,\nProvides support for trim specification. \n<h2>\nPackage Specification</h2>\n<p> This package provides classes for trim widgets.\n
21,package,org/eclipse/jface/text,
22,package,org/eclipse/jface/text/revisions,"\nProvides a revision model and a protocol to display revision information in a vertical ruler column.\n<h2>Package Specification</h2>\n<tt>IRevisionRulerColumn</tt> is the protocol that a team provider can use to display line based revision control information to a document.\n<tt>RevisionInformation</tt> defines the revision model, which contains a list of <tt>Revision</tt>s, which in turn contain <tt>RevisionRange</tt>s.\n"
24,package,org/eclipse/jface/text/link,
25,package,org/eclipse/jface/text/contentassist,\nProvides a content assist add-on for an <tt>ITextViewer</tt>.\nContent assist supports the user in writing&nbsp; by proposing context\nsensitive completions at a given document position. A completion can also\nbe a incomplete in itself and content assist provides means to deal with\nnested completions.\n<h2>\nPackage Specification</h2>\n<tt>IContentAssistant</tt> defines the concept of the content assist add-on.\nIt collaborates with content type specific completion processors (<tt>IContentAssistProcessor</tt>)\nin order to generate completion proposals (<tt>ICompletionProposal</tt>)\nvalid at the current document position. The package provides a default\nimplementation <tt>ContentAssistant</tt> which completely defines and implements\nthe UI and the control flow for content assist.\n<br>&nbsp;\n
26,package,org/eclipse/jface/text/templates,
28,package,org/eclipse/jface/text/information,\nProvides an information provider add-on for an <tt>ITextViewer</tt>.\nAn information provider presents information for a certain subject in a\nspecific information control. An information control usually is a floating\nwindow.\n<h2>\nPackage Specification</h2>\n<tt>IInformationPresenter</tt> defines the concept of an information provider.\nIt collaborates with content type specific information providers (<tt>IInformationProvider</tt>)\nwhich determine for a certain offset in a text viewer an information subject\nand the information available about this subject.. The package contains\na default implementation of <tt>IInformationPresenter</tt> (<tt>InformationPresenter</tt>).\n
29,package,org/eclipse/jface/text/rules,"\nProvides a framework for rule based text scanning\nand uses the framework to provide rule-driven default implementations of\n<tt>IPresentationDamager</tt>, <tt>IPresentationRepairer</tt> and <tt>IDocumentPartitioner</tt>.\n<h2>\nPackage Specification</h2>\n<tt>RuleBasedScanner</tt> is a document-based scanner controlled by <tt>IRule</tt>\nobjects. When evaluated an <tt>IRule</tt> always returns an <tt>IToken</tt>.\nThe package provides a set of rules whereby <tt>PatternRule</tt> is the\nmost important one. <tt>PatternRule</tt> defines a pattern-configurable\nrule.\n"
31,package,org/eclipse/jface/text/hyperlink,"\nProvides support for detecting and displaying hyperlinks in <tt>ISourceViewer</tt>s.\n<p>\n<tt>SourceViewer</tt> supports hyperlinked text regions inline in the displayed text. It delegates \nthe detection and presentation of hyperlinks to <tt>IHyperlinkDetector</tt> and <tt>IHyperlinkPresenter</tt>, respectively.\n</p>\n<p>\nOverride the following methods in <tt>SourceViewerConfiguration</tt> to customize the hyperlink behavior of a source viewer:\n<ul>\n  <li><tt>getHyperlinkDetectors()</tt> to specify the set of hyperlink detectors used by the viewer</li>\n  <li><tt>getHyperlinkPresenter()</tt> to specify the set of hyperlink presenters used by the viewer</li>\n  <li><tt>getHyperlinkStateMask()</tt> to specify when hyperlinks are activated</li>\n</ul>\n</p>\n\n"
33,package,org/eclipse/jface/text/source,
35,package,org/eclipse/jface/commands,"\n<p>Provides JFace-specific support for commands.</p>\n\n<h2>Package Specification</h2>\n<p>\nThis package provides a handler that wraps a legacy instance of\n<code>IAction</code>, as well as a manager for associating images with commands.\n</p>\n"
37,package,org/eclipse/jface/contexts,\n<p>Provides JFace-specific support for contexts.</p>\n\n<h2>Package Specification</h2>\n<p>\nThis package provides some context identifiers that have special meaning in the\ncontext of JFace.\n</p>\n
38,package,org/eclipse/jface/util,"\nProvides useful building blocks used throughout JFace,\nincluding property change events, a listener list implementation, and runtime\nchecked assertions.\n<br>&nbsp;\n"
45,package,org/apache/commons/collections/splitmap,"\n<p>The split map concept is that of an object that implements\nthe {@link org.apache.commons.collections.Put Put} and\n{@link org.apache.commons.collections.Get Get} interfaces,\nwith <i>differing</i> generic types. This is like a pre-generics\n{@link java.util.Map Map} whose input key/value constraints are\ndifferent than its output key/value constraints.  While it would\nbe possible to declare a split map with matching input/output\nkey/value constraints, this would be a {@link java.util.Map Map}\nand would therefore make little sense (any Commons Collections\n{@link java.util.Map Map} implementation will also implement\n{@link org.apache.commons.collections.Put Put} and\n{@link org.apache.commons.collections.Get Get} with matching\ngeneric parameters).\n\n<p>\nThe following decorators are provided:\n<ul>\n<li>Transformed - transforms each element added\n</ul>\n</pre>\n"
48,package,org/apache/commons/collections/keyvalue,"\n<p>\nThis package contains implementations of collection and map related key/value classes.\nThese are usually used in maps, however they can be used as data holders in any collection.\n<p>\nThe following key/value designs are included:\n<ul>\n<li>Map Entry - various map entry implementations\n<li>KeyValue - a key and value pair, without map entry semantics\n<li>MultiKey - a holder of multiple keys tied together\n</ul>\n</pre>\n"
55,package,java/rmi/activation,"\n\nProvides support for RMI Object Activation.  A remote\nobject's reference can be made ``persistent'' and later activated into a\n``live'' object using the RMI activation mechanism.\n\n<!--\n<h2>Package Specification</h2>\n\n##### FILL IN ANY SPECS NEEDED BY JAVA COMPATIBILITY KIT #####\n<ul>\n  <li><a href="">##### REFER TO ANY FRAMEMAKER SPECIFICATION HERE #####</a>\n</ul>\n\n<h2>Related Documentation</h2>\n\nFor overviews, tutorials, examples, guides, and tool documentation, please see:\n<ul>\n  <li><a href="">##### REFER TO NON-SPEC DOCUMENTATION HERE #####</a>\n</ul>\n-->\n\n@since 1.2\n"
