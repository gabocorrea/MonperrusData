directive_Text
@param iterator the iterator to add to the collation, must not be null
@param entry the entry to query, must not be null
@param set the set to decorate, must not be null
@param bag the bag to decorate, must not be null
@param set the set to decorate, must not be null
@param transformer the transformer to use for conversion, must not be null
@param set the set to decorate, must not be null
@param set the set to decorate, must not be null
@param set the set to decorate, must not be null
@param map the map to decorate, must not be null
@param timestamp is the timestamp's date and time. It must not be null
@param signerCertPath is the TSA's certificate path. It must not be null
@param buffer the buffer to decorate, must not be null
@param map the map to decorate, must not be null
@param key the key to add, must not be null
@param value the value to add, must not be null
@param entry the entry to copy, must not be null
@param actions Must be either null or the empty string.
Context must not be null
@param pair the pair to copy, must not be null
@param map the map to decorate, must not be null
@param list the list to decorate, must not be null
@param map the map to decorate, must not be null
@param set the set to decorate, must not be null
May not be null.
May not be null
@param list the list to decorate, must be empty and not null
@param map the map to decorate, must not be null
For instance, for types Http, and Socks, a SocketAddress must be provided.
Note: You must specify the parameter's SQL type.
@param pair the pair to copy, must not be null
@param bindingManager The binding manager which will provide the callback; must not be null.
@param commandManager The command manager which will provide the callback; must not be null.
@param bindingManager The binding manager which will provide the callback; must not be null.
@param commandManager The command manager which will provide the callback; must not be null.
@param activeChecker The callback mechanism for checking whether a command is active; must not be null
@param commandManager The command manager which will provide the callback; must not be null.
@param activeChecker The callback mechanism for checking whether a command is active; must not be null
@exception IllegalArgumentException if listener is null
@exception IllegalArgumentException if listener is null
@param bag the bag to decorate, must not be null
@return The string representation; never null.
@param lock the lock to use, must not be null
@param bag the bag to decorate, must not be nul
@throws IllegalArgumentException if bag is null
@param collection the collection to decorate, must not be null
@param lock the lock object to use, must not be null
@throws IllegalArgumentException if the collection is null
@param lock the lock object to use, must not be null
@throws IllegalArgumentException if the buffer is null
@param list the list to decorate, must not be null
@param lock the lock to use, must not be null
@throws IllegalArgumentException if list is null
@param list the list to decorate, must not be null
@param factory the factory to use for creation, must not be null
@throws IllegalArgumentException if list or factory is null
@param list the list to decorate, must not be null
@param factory the factory to use for creation, must not be null
@throws IllegalArgumentException if list or factory is null
@param factory the factory to use, must not be null
@throws IllegalArgumentException if map or factory is null
@param map the map to decorate, must not be null
@param map the map to decorate, must not be null
@param factory the factory to use, must not be null
@throws IllegalArgumentException if map or factory is null
@param map the map to decorate, must not be null
@param factory the factory to use, must not be null
@throws IllegalArgumentException if map or factory is null
@param factory the factory to use, must not be null
@param map the map to decorate, must not be null
@throws IllegalArgumentException if map or factory is null
@param map the map to decorate, must not be null
@param factory the factory to use, must not be null
@throws IllegalArgumentException if map or factory is null
@param map the map to decorate, must not be null
@param factory the factory to use, must not be null
@throws IllegalArgumentException if map or factory is null
@param map the map to decorate, must not be null
@param factory the factory to use, must not be null
@throws IllegalArgumentException if map or factory is null
@param factory the factory to use, must not be null
@throws IllegalArgumentException if map or factory is null
@param map the map to decorate, must not be null
@param factory the factory to use, must not be null
@throws IllegalArgumentException if map or factory is null
@param map the map to decorate, must not be null
@param factory the factory to use, must not be null
@throws IllegalArgumentException if map or factory is null
@param set the set to decorate, must not be null
@param lock the lock object to use, must not be null
@throws IllegalArgumentException if set is null
@param set the set to decorate, must not be null
@param lock the lock object to use, must not be null
@throws IllegalArgumentException if set is null
@param bag the bag to decorate, must not be null
@throws IllegalArgumentException if bag is null
@param bag the bag to decorate, must not be null
@throws IllegalArgumentException if bag is null
@param bag the bag to decorate, must not be null
@throws IllegalArgumentException if bag is null
@param bag the bag to decorate, must not be null
@throws IllegalArgumentException if list is null
@throws IllegalArgumentException if list is null
@param collection the collection to decorate, must not be null
@throws IllegalArgumentException if the collection is null
@param coll the collection to decorate, must not be null
@throws IllegalArgumentException if the collection is null
@param buffer the buffer to decorate, must not be null
@throws IllegalArgumentException if the buffer is null
@param buffer the buffer to decorate, must not be null
@throws IllegalArgumentException if the buffer is null
@param buffer the buffer to decorate, must not be null
@throws IllegalArgumentException if list is null
@param list the list to decorate, must not be null
@throws IllegalArgumentException if list is null
@param list the list to decorate, must not be null
@throws IllegalArgumentException if list is null
@param list the list to decorate, must not be null
@throws IllegalArgumentException if list is null
@throws IllegalArgumentException if list is null
@param list the list to decorate, must not be null
@throws IllegalArgumentException if list is null
@param list the list to decorate, must not be null
@throws IllegalArgumentException if list is null
@param list the list to decorate, must not be null
throws IllegalArgumentException if list is null
@param list the list to decorate, must not be null
@throws IllegalArgumentException if list is null
@param list the list to decorate, must not be null
@throws IllegalArgumentException if list is null
@param iterator the iterator to decorate, must not be null
@throws IllegalArgumentException if the collection is null
@param iterator the iterator to decorate, must not be null
@throws IllegalArgumentException if the collection is null
@param iterator the iterator to decorate, must not be null
@throws IllegalArgumentException if the collection is null
@param iterator the iterator to decorate, must not be null
@throws IllegalArgumentException if the collection is null
@param map the map to decorate, must not be null
@throws IllegalArgumentException if map is null
@param set the set to decorate, must not be null
@throws IllegalArgumentException if set is null
@param map the map to decorate, must not be null
@throws IllegalArgumentException if map is null
@param map the map to decorate, must not be null
@throws IllegalArgumentException if map is null
@throws IllegalArgumentException if map is null
@throws IllegalArgumentException if map is null
@param map the map to decorate, must not be null
@throws IllegalArgumentException if map is null
@param map the map to decorate, must not be null
@throws IllegalArgumentException if the collection is null
@param map the map to decorate, must not be null
@throws IllegalArgumentException if map is null
@param map the map to decorate, must not be null
@throws IllegalArgumentException if map is null
@param map the map to decorate, must not be null
@throws IllegalArgumentException if the collection is null
@throws NullPointerException if the entry is null
@param entry the entry to copy, must not be null
@throws NullPointerException if the entry is null
@param pair the pair to copy, must not be null
@throws NullPointerException if the entry is null
@throws NullPointerException if the entry is null
@param entry the Map.Entry to decorate, must not be null
@throws IllegalArgumentException if the collection is null
@throws NullPointerException if the entry is null
@param entry the entry to copy, must not be null
@throws NullPointerException if the entry is null
@throws IllegalArgumentException if set is null
@param set the set to decorate, must not be null
@throws IllegalArgumentException if set is null
@param set the set to decorate, must not be null
@throws IllegalArgumentException if set is null
@throws IllegalArgumentException if set is null
@param set the set to decorate, must not be null
@throws IllegalArgumentException if set is null
@param set the set to decorate, must not be null
@throws IllegalArgumentException if set is null
@throws IllegalArgumentException if set is null
@param map the map to decorate, must not be null
@throws IllegalArgumentException if set is null
@param set the set to decorate, must not be null
@throws IllegalArgumentException if set is null
@param map the map to decorate, must not be null
@param map the map to decorate, must not be null
@throws IllegalArgumentException if the collection is null
@throws IllegalArgumentException if the collection is null
@param map the map to decorate, must not be null
@throws IllegalArgumentException if the collection is null
@param transformer the transformer to use for conversion, must not be null
@throws IllegalArgumentException if bag or transformer is null
@param bag the bag to decorate, must not be null
@param bag the bag to decorate, must not be null
@param transformer the transformer to use for conversion, must not be null
@throws IllegalArgumentException if bag or transformer is null
@param bag the bag to decorate, must not be null
@param predicate the predicate to use for validation, must not be null
@throws IllegalArgumentException if bag or predicate is null
@param transformer the transformer to use for conversion, must not be null
@param bag the bag to decorate, must not be null
@throws IllegalArgumentException if bag or transformer is null
@throws NullPointerException If str is null
@exception IllegalArgumentException if groupID is null
@throws NullPointerException if name is null.
@throws NullPointerException if name is null.
Note: You must specify the parameter's SQL type.
@param signerCertPath The signer's certificate path. It must not be null.
@throws NullPointerException if the map is null
@param predicate1 the first predicate, may not be null
@param predicate2 the second predicate, may not be null
@throws IllegalArgumentException if either predicate is null
@param predicate the predicate to use as a filter, not null
@param iterator the iterator to use, not null
@throws NullPointerException if either parameter is null
@param listIterator the list iterator to use, not null
@throws NullPointerException if either parameter is null
@param predicate the predicate to use as a filter, not null
@throws NullPointerException if the collection is null
@param coll the collection to iterate over, not null
@param list the list to iterate over, not null
@throws NullPointerException if the list is null
@throws IllegalArgumentException if the key array is null
@param keys the array of keys, not null
@param buffer the buffer to wrap, must not be null
@param put to wrap, must not be null
throws NullPointerException if either list is null
@throws IllegalArgumentException if the predicates array is null
@throws IllegalArgumentException if any predicate in the array is null
@param predicates an array of predicates to check, may not be null
@param predicates a collection of predicates to check, may not be null
@throws IllegalArgumentException if the predicates collection is null
@throws IllegalArgumentException if any predicate in the collection is null
@throws IllegalArgumentException if the predicates array is nul
@throws IllegalArgumentException if any predicate in the array is null
@param predicates an array of predicates to check, may not be null
@param predicates a collection of predicates to check, may not be null
@throws IllegalArgumentException if the predicates collection is null
@throws IllegalArgumentException if any predicate in the collection is null
@param coll the collection to get the cardinality map for, must not be null
@param list the list to predicate, must not be null
@throws IllegalArgumentException if the List or Predicate is null
If s is null, then a NullPointerException is thrown.
@param a the first (sub?) collection, must not be null
@param map the map to add to, may not be null
@throws NullPointerException if the map is null
Attempting to add a null key or value to the map will raise a NullPointerException.
Attempting to add a null key or value to the map will raise a NullPointerException.
@param bag the bag to decorate, must not be null
@param transformer the transformer to use for conversion, must not be null
@param bag the bag to decorate, must not be null
@param predicate the predicate to use for validation, must not be null
@param coll the collection to decorate, must not be null
@param transformer the transformer to use for conversion, must not be null
@param coll the collection to decorate, must not be null
@param predicate the predicate to use for validation, must not be null
@param buffer the buffer to decorate, must not be null
@param transformer the transformer to use for conversion, must not be null
@param buffer the buffer to decorate, must not be null
@param transformer the transformer to use for conversion, must not be null
@param buffer the buffer to decorate, must not be null
@param predicate the predicate to use for validation, must not be null
@param set the set to decorate, must not be null
@param list the list to decorate, must not be null
@param list the list to decorate, must not be null
@param transformer the transformer to use for conversion, must not be null
@param list the list to decorate, must not be null
@param transformer the transformer to use for conversion, must not be null
@param list the list to decorate, must not be null
@param predicate the predicate to use for validation, must not be null
@param map the map to decorate, must not be null
@param factory the factory to use, must not be null
@param map the map to decorate, must not be null
@param factory the factory to use, must not be null
@param set the set to decorate, must not be null
@param list the list to decorate, must not be null
@param set the set to decorate, must not be null
@param predicate the predicate to use for validation, must not be null
@param set the set to decorate, must not be null
@param transformer the transformer to use for conversion, must not be null
@param set the set to decorate, must not be null
@param transformer the transformer to use for conversion, must not be null
@param set the set to decorate, must not be null
@param predicate the predicate to use for validation, must not be null
@param coll1 the first collection, must not be null
@param coll2 the first collection, must not be null
@param collection the collection to add to, must not be null
@param iterator the iterator of elements to add, must not be null
@param collection the collection to add to, must not be null
@param enumeration the enumeration of elements to add, must not be null
@param collection the collection to add to, must not be null
@param elements the array of elements to add, must not be null
@param bag the bag to decorate, must not be null
@param bag the bag to decorate, must not be null
@param bag the bag to decorate, must not be null
@param coll the BoundedCollection to decorate, must not be null
@param coll the collection to decorate, must not be null
@param buffer the buffer to decorate, must not be null
@param buffer the buffer to decorate, must not be null
@param buffer the buffer to decorate, must not be null
@param buffer the buffer to decorate, must not be null
@param map the map to decorate, must not be null
@param map the map to decorate, not null
@param map the map to decorate, must not be null
@param set the set to decorate, must not be null
@param map the map to decorate, must not be null
@param map the map to decorate, must not be null
@param map the map to decorate, must not be null
@param map the map to decorate, must not be null
@param buffer the buffer to make unmodifiable, must not be null
@param bag the bag to decorate, must not be null
@param transformer the transformer to use for conversion, must not be null
@param bag the bag to decorate, must not be null
@param predicate the predicate to use for validation, must not be null
@param bag the bag to decorate, must not be null
@param transformer the transformer to use for conversion, must not be null
@param bag the bag to decorate, must not be null
@param predicate the predicate to use for validation, must not be null
@param collection the collection to decorate, must not be null
@param transformer the transformer to use for conversion, must not be null
@param coll the collection to decorate, must not be null
@param predicate the predicate to use for validation, must not be null
@param buffer the buffer to decorate, must not be null
@param transformer the transformer to use for conversion, must not be null
@param buffer the buffer to decorate, must not be null
@param predicate the predicate to use for validation, must not be null
@param list the list to decorate, must not be null
@param transformer the transformer to use for conversion, must not be null
@param list the list to decorate, must not be null
@param predicate the predicate to use for validation, must not be null
@param map the map to decorate, must not be null
@param transformer the transformer to use as a factory to create entries, must not be null
@param set the set to decorate, must not be null
@param transformer the transformer to use for conversion, must not be null
@param set the set to decorate, must not be null
@param predicate the predicate to use for validation, must not be null
@param set the set to decorate, must not be null
@param transformer the transformer to use for conversion, must not be null
@param set the set to decorate, must not be null
@param predicate the predicate to use for validation, must not be null
@param b the second (super?) collection, must not be null
@param a the first (sub?) collection, must not be null
@param a the first collection, must not be null
@param b the second collection, must not be null
@param collection the collection to add to, must not be null
@param iterable the iterable of elements to add, must not be null
@param buffer the buffer to predicate, must not be null
@param predicate the predicate used to evaluate new elements, must not be null
@param buffer the buffer to predicate, must not be null
@param transformer the transformer for the buffer, must not be null
@param a the first collection, must not be null
@param b the second collection, must not be null
@param a the first collection, must not be null
@param b the second collection, must not be null
@param a the collection to subtract from, must not be null
@param b the collection to subtract, must not be null
@param collection the collection to predicate, must not be null
@param predicate the predicate for the collection, must not be null
@param collection the collection to predicate, must not be null
@param transformer the transformer for the collection, must not be null
@param bag the bag to predicate, must not be null
@param predicate the predicate for the bag, must not be null
@throws FunctorException if input is null
@param closure the closure the execute, not null
@throws IllegalArgumentException if the predicate or closure is null
@param predicate the predicate used to evaluate when the loop terminates, not null
@param predicate the predicate used to evaluate when the loop terminates, not null
@param closure the closure the execute, not null
@param closure the closure to call repeatedly, not null
@param predicate the predicate to use as an end of loop test, not null
@throws IllegalArgumentException if either argument is null
@throws NullPointerException if the key is null
@throws NullPointerException if either parameter is null
@throws NullPointerException if either parameter is null
@throws NullPointerException the specified map is null,
or if this map does not permit null keys or values, and the specified map contains null keys or values.
@throws NullPointerException if the key is null and the composited map does not not permit null keys (optional).
@throws NullPointerException (optional) if the map limits the values to non-null and null was specified
@param lock the lock to use, must not be null
@throws IllegalArgumentException if bag is null
@param map the map to transform, must not be null, typically empty
@throws IllegalArgumentException if the Map is null
@param map the map to transform, must not be null, typically empty
@throws IllegalArgumentException if the SortedMap is null
@throws NullPointerException if the key or value is null and null is invalid
@throws NullPointerException if the key is null and null keys are invalid
@throws NullPointerException if the key or value is null and null is invalid
@throws NullPointerException if the key is null and null keys are invalid
@param map the map to populate, must not be null
@throws NullPointerException if map is null
@throws NullPointerException if the map is null
@param map the map to invert, may not be null
This implementation uses the equals method and assumes neither value is null.
This implementation uses the equals method and assumes neither key is null.
@param enumeration the enumeration to traverse, which should not be null.
@throws NullPointerException if the enumeration parameter is null.
@param bag the bag to synchronize, must not be null
@throws IllegalArgumentException if the Bag is null
@throws IllegalArgumentException if the SortedBag is null
@param bag the bag to synchronize, must not be null
@throws IllegalArgumentException if bag is null
@throws IllegalArgumentException if collection is null
@throws IllegalArgumentException if buffer is null
. @param map the map to synchronize, must not be null
@throws IllegalArgumentException if the map is null
@param map the map to make lazy, must not be null
@throws IllegalArgumentException if the Map or Transformer is null
@param transformerFactory the factory for creating new objects, must not be null
@throws IllegalArgumentException if the map is null
@param map the map to synchronize, must not be null
@throws IllegalArgumentException if the Map or Transformer is null
@param map the map to make lazy, must not be null
@param transformerFactory the factory for creating new objects, must not be null
@param list the list to synchronize, must not be nul
@throws IllegalArgumentException if the list is null
@param buffer the buffer to synchronize, must not be null
@throws IllegalArgumentException if the Buffer is null
@param buffer the buffer to synchronize, must not be null
@throws IllegalArgumentException if the Buffer is null
. @param buffer the buffer to synchronize, must not be null
@throws IllegalArgumentException if the Buffer is null
@throws IllegalArgumentException if the collection is null
@param collection the collection to synchronize, must not be null
@param set the sorted set to synchronize, must not be null
@throws IllegalArgumentException if the set is null
@param bag the bag to predicate, must not be null
@param transformer the transformer for the bag, must not be null
@param bag the sorted bag to predicate, must not be null
@param predicate the predicate for the bag, must not be null
@param bag the bag to predicate, must not be null
@param transformer the transformer for the bag, must not be null
@param predicate the predicate for the set, must not be null
@param set the set to predicate, must not be null
@param set the set to transform, must not be null
@param transformer the transformer for the set, must not be null
@param predicate the predicate for the sorted set, must not be null
@param set the sorted set to predicate, must not be null
@param set the set to transform, must not be null
@param transformer the transformer for the set, must not be null
@param coll the BoundedCollection to decorate, must not be null
@param coll the collection to decorate, must not be null
@param buffer the buffer to decorate, must not be null
@param list the list to decorate, must not be null
@param map the map to decorate, must not be null
@param map the map to decorate, must not be null
@param map the map to decorate, must not be null
@param entry the entry to query, must not be null
@param entry the entry to query, must not be null
@param entry the entry to query, must not be null
@param entry the entry to query, must not be null
@param map the map to decorate, must not be null
@param entry the entry to query, must not be null
@param map the map to decorate, must not be null
@param map the map to decorate, must not be null
@param get to wrap, must not be null
@param map the map to decorate, must not be null
@param list the list to decorate, must not be null
@param map the map to make unmodifiable, must not be null
@param map the sorted map to make unmodifiable, must not be null
@param list the list to make unmodifiable, must not be null
@param collection the collection to add to, must not be null
@param collection the collection to make unmodifiable, must not be null
@param bag the bag whose unmodifiable view is to be returned, must not be null
@param bag the bag whose unmodifiable view is to be returned, must not be null
@param set the set to make unmodifiable, must not be null
@param set the sorted set to make unmodifiable, must not be null
@param map the map to make lazy, must not be null
@param factory the factory for creating new objects, must not be null
@param map the map to make lazy, must not be null
@param factory the factory for creating new objects, must not be null
@param list the list to predicate, must not be null
@param transformer the transformer for the list, must not be null
@param list the list to make lazy, must not be null
@param factory the factory for creating new objects, must not be null
@param buffer the buffer to decorate, must not be null
@param buffer the buffer to decorate, must not be null
@param map the map to decorate, must not be null
@param map the map to decorate, must not be null
@param map the map to decorate, must not be null
@param map the map whose size to fix, must not be null
@param map the map to order, must not be null
@param map the map whose size to fix, must not be null
@param list the list whose size to fix, must not be null
@param buffer the buffer to make bounded, must not be null
@param set the set to synchronize, must not be null
@param set the set to order, must not be null
@param map the map to decorate, must not be null
@param map the map to decorate, must not be null
@param buffer the buffer to make bounded, must not be null
@param map the map to predicate, must not be null
@param map the map to predicate, must not be null
@param keys the array of keys, not null
@param a the first collection, must not be null
@param b the second collection, must not be null
@param map the map to decorate, must not be null
@param closures matching array of closures, cloned, no nulls
@param predicates array of predicates, cloned, no nulls
@param predicates array of predicates, not cloned, no nulls
@param closures matching array of closures, not cloned, no nulls
@param predicates array of predicates, cloned, no nulls
@param transformers matching array of transformers, cloned, no nulls
@param predicates array of predicates, not cloned, no nulls
@param transformers matching array of transformers, not cloned, no nulls
@param closures the closures to chain, not copied, no nulls
@param transformers the transformers to chain, not copied, no nulls
@param closures the closures to chain, copied, no nulls
@param transformers the transformers to chain, copied, no nulls
The map must be empty and non-null.
Puts the key and value into the map, where the key must be a non-null MultiKey object.
Copies all of the keys and values from the specified map to this map. Each key must be non-null and a MultiKey object.
@throws NullPointerException if either node is null
@throws NullPointerException if either node is null
@throws NullPointerException if node is null
@throws NullPointerException if the entry is null
The comparator throws NullPointerException if a null value is compared.
@throws NullPointerException if array is null
@throws IllegalArgumentException if the transformer or the predicate is null
@throws NullPointerException if array is null
@throws NullPointerException if array is null
@throws NullPointerException if array is null
@throws NullPointerException if array is null
@throws NullPointerException if array is null
@throws NullPointerException if array is null
@throws NullPointerException this map does not permit null keys or values, and the specified key or value is null.
@throws IllegalArgumentException if the Map is null
@throws IllegalArgumentException if the Set or Predicate is null
@throws IllegalArgumentException if the Set or Predicate is null
@throws IllegalArgumentException if the SortedBag or Predicate is null
@return a predicated bag backed by the given bag @throws IllegalArgumentException if the Bag or Predicate is null
@throws IllegalArgumentException if the Collection is null
@throws IllegalArgumentException if the Buffer or Predicate is null
@throws IllegalArgumentException if the closure is null
@param closure the closure to run each time in the transformer, not null
@throws IllegalArgumentException if the predicate is null
@param predicate the predicate to run each time in the transformer, not null
@param factory the factory to run each time in the transformer, not null
@throws IllegalArgumentException if the factory is null
@throws IllegalArgumentException if the buffer is null
@throws IllegalArgumentException if the prototype is null
@throws IllegalArgumentException if the prototype is null
@throws IllegalArgumentException if the classToInstantiate is null
@throws IllegalArgumentException if the classToInstantiate is null
@throws NullPointerException if the value is null and this map does not not permit null values (optional).
@param defaultLookup the default look-up. Must not be null.
@param defaultKeyFormatter the default key formatter. Must not be null.
@throws NullPointerException if name is null
@throws NullPointerException if either srcCspace or dstCspace is null
@param loggerName The name of the Logger to be set. Must be non-null.
@throws NullPointerException if name is null.
@throws NullPointerException if array is null
@param out the stream to print to, must not be null
@throws NullPointerException if the stream is null
@throws IllegalArgumentException if the buffer is null
@throws NullPointerException if the key is null and this map does not not permit null keys (optional).
Even in the implementations that permit it, null should not be inserted into a Queue, as null is also used as a special return value by the poll method to indicate that the queue contains no elements.
@throws NullPointerException if iterator parameter is null
@param out the stream to print to, must not be null
@throws NullPointerException if the stream is null
@throws IllegalArgumentException if set is null
The map must not be null and should be empty or only contain valid keys.
This method requires that none of its arguments is null.
This method requires that none of its arguments is null.
Must not be null.
@param text the text to be displayed, must not be null
@param identifier The identifier of the item from which the accelerator text should be obtained ; must not be null.
@param action the action. Must not be null.
The given element array must not be null.
Insert the specified contents into the control's current contents. Must not be null.
@param listener The listener to be removed; must not be null.
@param schemeListener the instance of ISchemeListener to register. Must not be null.
@param platform The new platform; must not be null.
@return The object representing an input event that will trigger this binding; must not be null.
@param keyStroke a single key stroke. Must not be null.
@param identifier The identifier of the item to which the listener should be attached; must not be null.
@param trigger The prefix to look for; must not be null.
@param parent The composite in which the toggle button should be placed; must not be null.
@param predicate1 the first predicate, may not be null
@param predicate2 the second predicate, may not be null
@param text String The label to set. This value should not be null.
Cannot be null.
Unless otherwise noted, passing a null argument to a constructor or method in this class will cause a {@link NullPointerException} to be thrown.
@throws NullPointerException if { b} is null
@throws NullPointerException If the specified address is null.
@throws NullPointerException If the format is null
@throws NullPointerException if the specified element is null
@throws NullPointerException if the specified element is null
@exception NullPointerException if filename is null
@param exception The NotEnabledException, never null.
@param action The action contribution that caused the exception, never null.
The scanner may not be null
@param exception The ExecutionException, never null.
@throws NullPointerException If the format is null
@throws IllegalArgumentException if the collection is null
@param key the key for the entry, may be null
@param value the value for the entry, may be null
null means that the catalog name should not be used to narrow the search
@param readMethodName May be null if the property is write-only
@param readMethod May be null if the property is write-only
@param message the raw message string (may be null)
If this parameter is null, then only a specified keyStroke will invoke content proposal
If this parameter is null, then only a specified keyStroke will invoke content proposal.
the IContentProposalProvider used to obtain content proposals for this control, or null if no content proposal is available
the preference store, or null
@param labelProvider the label provider, or null if none
null means catalog name should not be used to narrow down the search.
null means that the catalog name should not be used to narrow the search
null returns all types
@param bindings The new array of bindings; may be null.
@param store the IPreference store in which the user's preference should be persisted; null if you don't want it persisted automatically.
@param key the key to use when persisting the user's preference; null if you don't want it persisted.
@param store the IPreference store in which the user's preference should be persisted; null if you don't want it persisted automatically.
@return a MemoryUsage object represented by cd if cd is not null; null otherwise.
@return a MemoryNotificationInfo object represented by cd if cd is not null; null otherwise.
the font or null to use the default font
@param label The label to be used, may be null. If null, the label is not output.
@param map The map to print, may be null. If null, the text 'null' is output.
@param label The label to be used, may be null. If null, the label is not output.
param map The map to print, may be null. If null, the text 'null' is output.
Specifying a handler of null indicates that the URL should use a default stream handler for the protocol, as outlined for: java.net.URL#URL(java.lang.String, java.lang.String, int, java.lang.String)
null means that the catalog name should not be used to narrow the search
null means that the schema name should not be used to narrow the search
null means drop catalog name from the selection criteria
null means drop schema name from the selection criteria
null means drop catalog name from the selection criteria
If the list is null, all available attribute information should be made accessible.
If the list is null, all available attribute information should be made accessible.
If issuerDN is not null, it should contain a distinguished name, in RFC 2253 format.
If null, the current time is used.
If subjectDN is not null, it should contain a single DER encoded distinguished name, as defined in X.501.
If issuerDN is not null, it should contain a single DER encoded distinguished name, as defined in X.501.
If subjectKeyID is not null, it should contain a single DER encoded value corresponding to the contents of the extension value (not including the object identifier, criticality setting, and encapsulating OCTET STRING) for a SubjectKeyIdentifier extension.
If key is not null, it should contain a single DER encoded SubjectPublicKeyInfo structure, as defined in X.509.
Specify null to return all Certificates (if supported).
Specify null to return all CRLs (if supported).
Specify null to return all Certificates (if supported).
Specify null to return all CRLs (if supported).
null means that the schema name should not be used to narrow the search
@param envp array of strings, each element of which has environment variable settings in the format name=value, or null if the subprocess should inherit the environment of the current process.
@param dir the working directory of the subprocess, or null if the subprocess should inherit the working directory of the current process.
@param envp array of strings, each element of which has environment variable settings in the format name=value, or null if the subprocess should inherit the environment of the current process.
@param envp array of strings, each element of which has environment variable settings in the format name=value, or null if the subprocess should inherit the environment of the current process.
@param dir the working directory of the subprocess, or null if the subprocess should inherit the working directory of the current process.
@param envp array of strings, each element of which has environment variable settings in the format name=value, or null if the subprocess should inherit the environment of the current process.
@param encoding The name of a supported character encoding. May be null, to indicate the default platform encoding.
@param inputCollection the collection to get the input from, may be null
@param transformer the transformer to use, may be null
@param outputCollection the collection to output into, may not be null
@param inputIterator the iterator to get the input from, may be null
@param transformer the transformer to use, may be null
@param outputCollection the collection to output into, may not be null
@param root the root object, null will result in an empty iterator
@param transformer the transformer to use, null will use a no effect transformer
@param transformer the transformer to use, see above, null uses no effect transformer
@param root the root object to start iterating from, null results in an empty iterator
Neither map is validated, so nulls may be passed in.
@param valueTransformer the transformer for the map values, null means no transformation
@param valueTransformer the transformer for the map values, null means no transformation
@param array an array to populate from, null ignored
@param keyPredicate the predicate to validate the keys, null means no check
@param valuePredicate the predicate to validate to values, null means no check
@param keyTransformer the transformer to use for key conversion, null means no conversion
@param valueTransformer the transformer to use for value conversion, null means no conversion
@param keyTransformer the predicate to validate the keys, null means no transformation
@param valueTransformer the predicate to validate to values, null means no transformation
@param keyPredicate the predicate to validate the keys, null means no check
@param valuePredicate the predicate to validate to values, null means no check
@param keyPredicate the predicate to validate the keys, null means no check
@param valuePredicate the predicate to validate to values, null means no check
@param object the object to add, if null it will not be added @return true if the collection changed
@param keyTransformer the transformer to use for key conversion, null means no transformation
@param valueTransformer the transformer to use for value conversion, null means no transformation
@param keyTransformer the transformer to use for key conversion, null means no transformation
@param valueTransformer the transformer to use for value conversion, null means no transformation
@param keyTransformer the transformer to use for key conversion, null means no transformation
@param valueTransformer the transformer to use for value conversion, null means no transformation
@param keyTransformer the transformer to use for key conversion, null means no transformation
@param valueTransformer the transformer to use for value conversion, null means no transformation
@param keyPred the predicate for keys, null means no check
@param valuePred the predicate for values, null means no check
@param keyPred the predicate for keys, null means no check
@param valuePred the predicate for values, null means no check
@param keyTransformer the predicate to validate the keys, null means no transformation
@param valueTransformer the predicate to validate to values, null means no transformation
@param comparator the comparator used to order the elements, null means use natural order
@param transformer the transformer to call, null means nop
@param keyTransformer the transformer to use for key conversion, null means no conversion
@param keyTransformer the transformer to use for key conversion, null means no conversion
@param valueTransformer the transformer to use for value conversion, null means no conversion
@param keyPredicate the predicate to validate the keys, null means no check
@param valuePredicate the predicate to validate to values, null means no check
@param comparator the comparator used to order the elements, null means use natural order
@param comparator the comparator used to order the elements, null means use natural order
@param comparator the comparator used to order the elements, null means use natural order
@param defaultClosure the closure to use if no match, null means nop
@param defaultClosure the closure to use if no match, null means nop
@param defaultTransformer the transformer to use if no match, null means return null @return the chained transformer
@param defaultTransformer the transformer to use if no match, null means return null
@param transformer the transformer to run each time in the closure, null means nop
@param defaultTransformer the default to call if no predicate matches, null means return null
If the input object is null, null is returned.
@param list1 the first list, may be null
@param list2 the second list, may be null
A null input object is accepted and will return true the first time, and false subsequently as well.
When called the first time, priorVariables should be null.
@param args the arguments to pass to the constructor, can be null
@param extensions a list of file extension, or null to set the filter to the system's default value
@param actions should be null
A null value indicates that the elements' {@linkplain Comparable natural ordering} should be used.
may be null, in which case the suffix .tmp will be used
@param suffix The suffix string to be used in generating the file's name; may be null, in which case the suffix .tmp will be used
Specifying a handler of null indicates that the URL should use a default stream handler for the protocol, as outlined for: java.net.URL#URL(java.lang.String, java.lang.String, int, java.lang.String)
the actions String is currently unused and should be null
The actions should be null; they are ignored.
the actions String is currently unused and should be null.
A null value indicates that the elements' {@linkplain Comparable natural ordering} should be used.
A null value indicates that the elements' {@linkplain Comparable natural ordering} should be used.
@param q the queue with which the reference is to be registered, or null if registration is not required
@param q the queue with which the reference is to be registered, or null if registration is not required
@param q the queue with which the reference is to be registered, or null if registration is not required
If the number of formal parameters required by the underlying method is 0, the supplied args array may be of length 0 or null.
If the number of formal parameters required by the underlying constructor is 0, the supplied initargs array may be of length 0 or null.
@param actions should be null.
@param resourceBundleName name of ResourceBundle to be used for localizing messages for this logger. May be null if none of the messages require localization.
@param l event listener (can be null)
The group name must not be null or the empty string.
@param cause the underlying reason for this SQLException (which is saved for later retrieval by the getCause() method); may be null indicating the cause is non-existent or unknown
@param cause the underlying reason for this SQLException (which is saved for later retrieval bythe getCause() method); may be null indicating the cause is non-existent or unknown.
@param params parameters for the Policy, which may be null.
@param key the key for the entry, may be null
@param coll the collection to check, may be null
@param collection the collection to get the input from, may be null @param predicate the predicate to use as a filter, may be null
@param coll the collection to check, may be null
@param key the key for the entry, may be null
@param input the {@link Iterable} to get the input from, may be null
@param predicate the predicate to use, may be null
@param text the text to be shown in the info hover, or null if no text should be shown.
Specify null to omit the parameter.
Note that the empty string is not treated the same as null; it indicates an error state but with no message to display.
This parameter may be null if there are no inherited ProtectionDomains.
@param comment a description of the property list, or null if no comment is desired.
@param toolBarManager the manager or null if toolbar is not desired
If the Guard object is null, then no restrictions will be placed on who can access the object.
@param array The array to convert; may be null
@param annotationHover the hover to be used, null is a valid argument
@param context an access control context representing the restriction to be applied to the caller's domain's privileges before performing the specified action. If the context is null, then no additional restriction is applied.
@param newSelection the selection after the update, or null if none
@param text the text for the action; may be null.
@param output an OutputStream, may be null
If the number of copies to remove is greater than the actual number of copies in the Bag, no error is thrown.
@param maximumSize the maximum size, must be size one or greater
@param maximumSize the maximum size, must be size one or greater
@param initialCapacity the initial capacity, must be a power of two @param loadFactor the load factor, must be > 0.0f and generally < 1.0f
@param initialCapacity the initial capacity, must be a power of two @param loadFactor the load factor, must be > 0.0f and generally < 1.0f
Constructs an UnboundedFifoBuffer with the specified number of elements. The integer must be a positive integer.
The port must be non-zero.
The parameter { n} must be in the range 0 through 999999999, inclusive.
The timeout must be > 0.
@param position must be non-negative
@param size must be non-negative, and the sum position + size must be non-negative
The block increment must be greater than zero
The unit increment must be greater than zero.
minimumIntegerDigits must be <= maximumIntegerDigits.
The timeout must be > 0.
The ttl must be in the range 0 <= ttl <= 255
@param size the size to which to set the receive buffer size. This value must be greater than 0.
The port must be between 0 and 65535, inclusive.
The backlog argument must be a positive value greater than 0.
The tc must be in the range 0 <= tc <= 255 or an IllegalArgumentException will be thrown.
The local port must be between 0 and 65535 inclusive.
The tc must be in the range 0 <= tc <= 255 or an IllegalArgumentException will be thrown.
Hours must be between 0 to 23
Minutes must be between 00 to 59.
The backlog argument must be a positive value greater than 0.
@param size the number of log records to buffer (must be greater than zero)
maximumIntegerDigits must be >= minimumIntegerDigits.
(as of 3.6 a negative argument will be set to 0)
The timeout must be > 0.
@param size the size to which to set the send buffer size. This value must be greater than 0.
@param year the year minus 1900; must be 0 to 8099.
The ttl is an unsigned 8-bit quantity, and so must be in the range 0 <= ttl <= 0xFF
@param size the size to which to set the send buffer size. This value must be greater than 0.
The backlog argument must be a positive value greater than 0.
The mode argument must be either OPEN_READ or OPEN_READ | OPEN_DELETE.
The index must be a value greater than or equal to { 0} and less than the current size of the vector.
@param size the size to which to set the receive buffer size. This value must be greater than 0
The mode argument must be either OPEN_READ or OPEN_READ | OPEN_DELETE.
The index must be a value greater than or equal to { 0} and less than the current size of the vector.
@param threshold the new threshold value in bytes. Must be non-negative.
@param threhsold the new collection usage threshold value in bytes. Must be non-negative.
@exception IllegalArgumentException if pipeSize <= 0.
so this argument must not be negative, but is otherwise ignored
Hours must be between 0 and 23, and Minutes must be between 00 and 59. The format is locale independent and digits must be taken from the Basic Latin block of the Unicode standard.
woDigitHours must be between 00 and 23. Other definitions are as for general time zones.
@throws IndexOutOfBoundsException if the index is out of range (index < 0 || index > size()).
@param scale the desired number of digits to the right of the decimal point. It must be greater than or equal to zero.
@param maximumSize the maximum size, must be size one or greater
@throws IllegalArgumentException if the maximum size is zero or less
The initial index of the range (from) must lie between zero and original.length, inclusive.
The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case 0 is placed in all elements of the copy whose index is greater than or equal to original.length - from.
@param v 0 if the cookie should comply with the original Netscape specification; 1 if the cookie should comply with RFC 2965/2109
A negative value for the ttl will result in an IllegalArgumentException being thrown.
A negative value will result in an IllegalArgumentException being thrown
@throws IllegalArgumentException if timeout is negative.
Specifying a port number of -1 indicates that the URL should use the default port for the protocol.
@param id the thread ID of the thread. Must be positive.
@param id the thread ID of the thread. Must be positive.
This value may be negative, in which case releases must occur before any acquires will be granted.
This value may be negative, in which case releases must occur before any acquires will be granted.
This value should always be nonnegative and not larger than the value of count.
This value should always be nonnegative and not larger than the length of buf.
A valid reduction polynomial is either a trinomial (X^m + X^k + 1 with m > k >= 1) or a pentanomial (X^m + X^k3 + X^k2 + X^k1 + 1 with m > k3 > k2 > k1 >= 1), so ks should have length 1 or 3.
@param autoGeneratedKeys a flag indicating whether auto-generated keys should be returned; one of Statement.RETURN_GENERATED_KEYS or Statement.NO_GENERATED_KEYS
If the argument is any value in the range 0x7f800001 through 0x7fffffff or in the range 0xff800001 through 0xffffffff, the result is a NaN. all NaN bit patterns, quiet or signaling, must be in the NaN range identified above.
At a minimum, the unpacker must set progress to 0 at the beginning of a packing operation, and to 100 at the end.
To specify BC year numbers, 1 - year number must be given.
The initial index of the range (from) must lie between zero and original.length, inclusive.
@param current one of the following Statement constants indicating what should happen to current ResultSet objects obtained using the method getResultSet: Statement.CLOSE_CURRENT_RESULT, Statement.KEEP_CURRENT_RESULT, or Statement.CLOSE_ALL_RESULTS
The initial index of the range (from) must lie between zero and original.length, inclusive.
If the argument is any value in the range 0x7ff0000000000001L through 0x7fffffffffffffffL or in the range 0xfff0000000000001L through 0xffffffffffffffffL, the result is a NaN. all NaN bit patterns, quiet or signaling, must be in the NaN range identified above.
@param scale the desired number of digits to the right of the decimal point. It must be greater than or equal to zero
The initial index of the range (from) must lie between zero and original.length, inclusive.
@param capacity the initial capacity for the buffer, greater than zero
@param valueType the type of reference to use for values; must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}
@param keyType the type of reference to use for keys; must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}
@param valueType the type of reference to use for values; must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}
@param keyType the type of reference to use for keys; must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}
@param keyType the type of reference to use for keys; must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}
@param valueType the type of reference to use for values; must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}
@param keyType the type of reference to use for keys; must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}
@param valueType the type of reference to use for values; must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}
@param keyType the type of reference to use for keys; must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}
@param valueType the type of reference to use for values; must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}
@param keyType the type of reference to use for keys; must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}
@param valueType the type of reference to use for values; must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}
@param keyType the type of reference to use for keys; must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}
@param valueType the type of reference to use for values; must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}
@param keyType the type of reference to use for keys; must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}
@param valueType the type of reference to use for values; must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}
@param keyType the type of reference to use for keys; must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}
@param valueType the type of reference to use for values; must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}
The number of buckets is never below 17, and is always an odd number (StaticBucketMap ensures this)
The count must be at least 1.
@param length the number of consecutive characters to be copied; the value for length must be 0 or greater
@param length the number of consecutive bytes to be copied; the value for length must be 0 or greater
The count must be at least 1
@param autoGeneratedKeys one of the following constants: Statement.RETURN_GENERATED_KEYS or Statement.NO_GENERATED_KEYS
If the value of the len parameter is negative then no characters are written. This is contrary to the specification of this method in the {@linkplain java.io.Writer#write(java.lang.String,int,int) superclass}, which requires that an {@link IndexOutOfBoundsException} be thrown.
This value is always in the range 0 through count. If it is less than count, then buf[pos] is the next byte to be supplied as input; if it is equal to count, then the next read or skip operation will require more bytes to be read from the contained input stream.
In general clients of logging should use one of the constant Level objects such as SEVERE or FINEST.
At a minimum, the unpacker must set progress to 0 at the beginning of a packing operation, and to 100 at the end.
@param tabWidth the tabulator width in space equivalents, must be >=0
@param steps the requested size, must be > 0
@param length the new length, must be > 0
@param nLines the number of lines to be reverted, must be > 0.
@param index the index of the color, must be >= 0
@param filterStyle a constant indicating how keystrokes received in the proposal popup affect filtering of the proposals shown. FILTER_NONE specifies that no automatic filtering of the content proposal list will occur as keys are typed in the popup. FILTER_CHARACTER specifies that the content of the popup will be filtered by the most recently typed character. FILTER_CUMULATIVE is deprecated and no longer recommended. It specifies that the content of the popup will be filtered by a string containing all the characters typed since the popup has been open.
Must be in [0, numberOfLines]  note the inclusive end; there may be a hunk with line == numberOfLines to describe deleted lines at then end of the document.
The valid message types are one of NONE, INFORMATION,WARNING, or ERROR.
@param dialogImageType one of the following values: MessageDialog.NONE for a dialog with no image MessageDialog.ERROR for a dialog with an error image MessageDialog.INFORMATION for a dialog with an information image MessageDialog.QUESTION for a dialog with a question image MessageDialog.WARNING for a dialog with a warning image
@param kind the kind of dialog to open, one of {@link #ERROR}, {@link #INFORMATION}, {@link #QUESTION}, {@link #WARNING}, {@link #CONFIRM}, or {#QUESTION_WITH_CANCEL}.
@throws IllegalArgumentException { numBits} is negative.
@throws IndexOutOfBoundsException for an illegal endpoint index value (fromIndex < 0 || toIndex > size || fromIndex > toIndex)
@param month the month between 0-11. @param date the day of the month between 1-31. @param hrs the hours between 0-23. @param min the minutes between 0-59. @param sec the seconds between 0-59.
@param nanos additional time, in nanoseconds range 0-999999.
@param nanos 0-999999 additional nanoseconds to wait. @exception IllegalArgumentException if the value of millis is negative the value of nanos is not in the range 0-999999.
@param kind the kind of dialog to open, one of {@link #ERROR}, {@link #INFORMATION}, {@link #QUESTION}, {@link #WARNING}, {@link #CONFIRM}, or {@link #QUESTION_WITH_CANCEL}.
Sets the cycling mode to either of CYCLING_ALWAYS, CYCLING_NEVER, or CYCLING_WHEN_NO_PARENT, which is the default.
A valid port value is between 0 and 65535.
@param month the month value between 0-11
A valid port value is between 0 and 65535.
@param name Permission name. Must be control.
The string must contain at least one digit in either the integer or the fraction.
@param name Permission name. Must be either monitor or control.
tive - Parameter: too vague): @param actions Must be either null or the empty string
The name must conform to RFC 2965.
An IPv6 address must be enclosed in square brackets ('[' and ']') as specified by RFC 2732. The IPv6 address itself must parse according to RFC 2373.
The host is expressed as a DNS name, as a numerical IP address, or as localhost (for the local machine). The wildcard * may be included once in a DNS name host specification. If it is included, it must be in the leftmost position, as in *.sun.com.
The format of the IPv6reference should follow that specified in RFC 2732: Format for Literal IPv6 Addresses in URLs
The format is locale independent and digits must be taken from the Basic Latin block of the Unicode standard.
The named program must be able to accept multiple -Dpropname=value options (as documented for the java tool)
The characters in the string must all be decimal digits, except that the first character may be an ASCII minus sign '-' ('\u002D') to indicate a negative value
This sequence of characters must represent a positive value
The characters in the string must all be digits, of the specified radix
This sequence of characters must represent a positive value
The characters in the string must all be digits, of the specified radix
@param name the name of this SQLPermission object, which must be setLog
@param name the name of this SQLPermission object, which must be setLog
The characters in the string must all be digits of the specified radix (as determined by whether {@link java.lang.Character#digit(char, int)} returns a nonnegative value), except that the first character may be an ASCII minus sign '-' ('\u002D') to indicate a negative value
This sequence of characters must represent a positive value or a {@link NumberFormatException} will be thrown.
@param name Permission name. Must be either monitor or control.
The characters in the string must all be digits of the specified radix (as determined by whether {@link java.lang.Character#digit(char, int)} returns a nonnegative value), except that the first character may be an ASCII minus sign '-' ('\u002D') to indicate a negative value.
In this class octal escapes must always begin with a zero.
This sequence of characters must represent a positive value
If a scheme is given then the path, if also given, must either be empty or begin with a slash character ('/').
If the authority contains a literal IPv6 address then the address must be enclosed in square brackets ('[' and ']').
A cookie's path must include the servlet that set the cookie, for example, /catalog, which makes the cookie visible to all directories on the server under /catalog.
The formats must be equal to one of {@link Control#FORMAT_PROPERTIES}, {@link Control#FORMAT_CLASS} or {@link Control#FORMAT_DEFAULT}.
If a scheme is given then the path, if also given, must either be empty or begin with a slash character ('/').
The filename argument must be a complete path name.
The characters in the string must all be decimal digits, except that the first character may be an ASCII minus sign '-' ('\u002D') to indicate a negative value.
The name must match exactly an identifier used to declare an enum constant in this type. (Extraneous whitespace characters are not permitted.)
The prefix string to be used in generating the file's name; must be at least three characters long
The prefix argument must be at least three characters long.
An UnquotedPattern can contain arbitrary characters except single quotes, but curly braces within it must be balanced
The characters in the string must all be decimal digits, except that the first character may be an ASCII minus sign '-' ('\u002D') to indicate a negative value.
The filename argument must be a complete path name, (for example Runtime.getRuntime().load(/home/avh/lib/libX11.so);).
Either the text-argument must already be present in the sequence, or some initial substring of the text-argument must be present. (e.g. a < b & ae < e is valid since a is present in the sequence before ae is reset). In this latter case, ae is not entered and treated as a single character; instead, e is sorted as if it were expanded to two characters: a followed by an e. This difference appears in natural languages: in traditional Spanish ch is treated as though it contracts to a single character (expressed as c < ch < d), while in traditional German a-umlaut is treated as though it expanded to two characters (expressed as a
It also understands the continental U.S. time-zone abbreviations, but for general use, a time-zone offset should be used: Sat
The baseName argument should be a fully qualified class name.
The class name must be of the form: {package-prefix}.{major}.{minor} e.g. YoyoDyne.experimental.text.plain
@param header a String specifying the set-cookie header. The header should start with set-cookie, or set-cookie2 token; or it should have no leading token at all.
The World Wide Web Consortium Recommendation states that UTF-8 should be used. Not doing so may introduce incompatibilites.
@throws IllegalArgumentException If the given string violates RFC 2396
If IPv6 literal address is used, it should be enclosed in square brackets ('[' and ']'), as specified by RFC 2732; However, the literal IPv6 address format defined in RFC 2373: IP Version 6 Addressing Architecture is also accepted.
The characters in the string must all be decimal digits, except that the first character may be an ASCII minus sign '-' (\u002D') to indicate a negative value.
With Version 0 cookies, values should not contain white space, brackets, parentheses, equals signs, commas, double quotes, slashes, question marks, at signs, colons, and semicolons. Empty values may not behave the same way on all browsers.
Note: The World Wide Web Consortium Recommendation states that UTF-8 should be used. Not doing so may introduce incompatibilites.
The algorithm name should be a standard name. See Appendix A in the Java Cryptography Architecture API Specification & Reference for information about standard algorithm names.
@param mxbeanName the name of a platform MXBean within connection to forward to. mxbeanName must be in the format of {@link ObjectName ObjectName}.
Strings starting with java. are reserved for future extensions and must not be used by application-defined formats.
If the conversion is 'a' or 'A', then the precision must not be specified.
For ignorable characters, the first rule must start with a relation (the examples we have used above are really fragments; a < b really should be < a < b).
The byte format of the Unicode stream must be a Java UTF-8, as defined in the Java Virtual Machine Specification.
The selection criterion must be specified in one of the following two formats:
The specified provider must be registered in the security provider list.
The specified provider must be registered in the security provider list.
The specified provider must be registered in the security provider list.
The specified provider must be registered in the security provider list.
The specified provider must be registered in the security provider list.
The specified provider must be registered in the security provider list.
The specified provider must be registered in the security provider list.
The specified provider must be registered in the security provider list.
The specified provider must be registered in the security provider list.
The specified provider must be registered in the security provider list.
The specified provider must be registered in the provider list.
The specified provider must be registered in the security provider list.
The specified provider must be registered in the security provider list.
The file should contain a list of fully-qualified concrete provider class names, one per line.
@param name A name for the logger. This should be a dot-separated name and should normally be based on the package name or class name of the subsystem, such as java.net or javax.swing
Note that there must be at least one nonzero digit in a subnormal significand.
@param name A name for the logger. This should be a dot-separated name and should normally be based on the package name or class name of the subsystem, such as java.net or javax.swing.
In that case, characters that cannot be represented in ISO-8859-1 encoding must be represented by Unicode Escapes, whereas the other constructor which takes a Reader does not have that limitation.
The rest of s should constitute a FloatValue as described by the lexical syntax rules: FloatValue: Signopt NaN Signopt Infinity Signopt FloatingPointLiteral Signopt HexFloatingPointLiteral SignedInteger HexFloatingPointLiteral: HexSignificand BinaryExponent FloatTypeSuffixopt HexSignificand: HexNumeral HexNumeral . 0x HexDigitsopt . HexDigits 0X HexDigitsopt . HexDigits BinaryExponent: BinaryExponentIndicator SignedInteger BinaryExponentIndicator: p P where Sign, FloatingPointLiteral, HexNumeral, HexDigits, SignedInteger and FloatTypeSuffix are as defined in the lexical structure sections of the of the Java Language Specification.
For a user-defined parameter, the fully-qualified SQL type name of the parameter should also be given, while a REF parameter requires that the fully-qualified type name of the referenced type be given.
This call is not required if the entire paragraph fits on one line.
To be portable, applications must give the SQL type code and the fully-qualified SQL type name when specifying a NULL user-defined or REF parameter. In the case of a user-defined type the name is the type name of the parameter itself.
The key for any entry in such a map must be in one of the following two formats: * . The cryptographic service name must not contain any dots. The value associated with the key must be an empty string. A provider satisfies this selection criterion iff the provider implements the specified algorithm or type for the specified cryptographic service. * . The cryptographic service name must not contain any dots. There must be one or more space charaters between the and the . The value associated with the key must be a non-empty string. A provider satisfies this selection criterion iff the provider implements the specified algorithm or type for the specified cryptographic service and its implementation meets the constraint expressed by the specified attribute name/value pair.
In the case of a certificate factory for X.509 certificates, the certificate provided in inStream must be DER-encoded and may be supplied in binary or printable (Base64) encoding. If the certificate is provided in Base64 encoding, it must be bounded at the beginning by -----BEGIN CERTIFICATE-----, and must be bounded at the end by -----END CERTIFICATE-----.
In the case of a certificate factory for X.509 certificates, the certificate provided in inStream must be DER-encoded and may be supplied in binary or printable (Base64) encoding. If the certificate is provided in Base64 encoding, it must be bounded at the beginning by -----BEGIN CERTIFICATE-----, and must be bounded at the end by -----END CERTIFICATE-----.
The algorithm name must be specified, as there is no default.
This byte array should contain the DER encoded name, as it would appear in the GeneralName structure defined in RFC 2459 and X.509. The encoded byte array should only contain the encoded value of the name, and should not include the tag associated with the name in the GeneralName structure. The ASN.1 definition of this structure appears below.
The name is provided as a byte array. This byte array should contain the DER encoded name, as it would appear in the GeneralName structure defined in RFC 2459 and X.509.
If a name is specified as a byte array, it should contain a single DER encoded distinguished name, as defined in X.501.
To be portable, however, applications should always provide these values for user-defined and REF parameters.
Note that a comment line cannot be extended in this manner; every natural line that is a comment must have its own comment indicator, as described below.
Note that it is not sufficient to only examine the character preceding a line terminator sequence to decide if the line terminator is escaped; there must be an odd number of contiguous backslashes for the line terminator to be escaped.
@param name A name for the logger. This should be a dot-separated name and should normally be based on the package name or class name of the subsystem, such as java.net or javax.swing
The algorithm name must be specified, as there is no default.
This byte array should contain the DER encoded name, as it would appear in the GeneralName structure defined in RFC 2459 and X.509. The encoded byte array should only contain the encoded value of the name, and should not include the tag associated with the name in the GeneralName structure. The ASN.1 definition of this structure appears below.
The name is provided in string format. RFC 822, DNS, and URI names use the well-established string formats for those types (subject to the restrictions included in RFC 2459). IPv4 address names are supplied using dotted quad notation. OID address names are represented as a series of nonnegative integers separated by periods. And directory names (distinguished names) are supplied in RFC 2253 format. No standard string format is defined for otherNames, X.400 names, EDI party names, IPv6 address names, or any other type of names. They should be specified using the {@link #addPathToName(int type, byte [] name) addPathToName(int type, byte [] name)} method.
If authorityKeyID is not null, it should contain a single DER encoded value corresponding to the contents of the extension value (not including the object identifier, criticality setting, and encapsulating OCTET STRING) for an AuthorityKeyIdentifier extension.
To be portable, applications must give the SQL type code and the fully-qualified SQL type name when specifying a NULL user-defined or REF parameter.
If key is not null, it should contain a single DER encoded SubjectPublicKeyInfo structure, as defined in X.509.
For a user-named parameter the fully-qualified SQL type name of the parameter should also be given, while a REF parameter requires that the fully-qualified type name of the referenced type be given. A JDBC driver that does not need the type code and type name information may ignore it. To be portable, however, applications should always provide these values for user-named and REF parameters.
hed string formats for those types (subject to the restrictions included in RFC 2459). IPv4 address names are supplied using dotted quad notation. OID address names are represented as a series of nonnegative integers separated by periods. And directory names (distinguished names) are supplied in RFC 2253 format. No standard string format is defined for otherNames, X.400 names, EDI party names, IPv6 address names, or any other type of names. They should be specified using the {@link #addSubjectAlternativeName(int type, byte [] name) addSubjectAlternativeName(int type, byte [] name)} method.
Valid strings are Base64 encoded binary data, as defined in RFC 2045, Section 6.8, with one minor change: the string must consist solely of characters from the Base64 Alphabet; no newline characters or extraneous characters are permitted.
If issuerDN is not null, it should contain a distinguished name, in RFC 2253 format.
The name constraints are specified as a byte array. This byte array should contain the DER encoded form of the name constraints, as they would appear in the NameConstraints structure defined in RFC 2459 and X.509.
@param ID the ID for a TimeZone, either an abbreviation such as PST, a full name such as America/Los_Angeles, or a custom ID such as GMT-8:00. Note that the support of abbreviations is for JDK 1.1.x compatibility only and full names should be used.
The rest of s should constitute a FloatValue as described by the lexical syntax rules: FloatValue: Signopt NaN Signopt Infinity Signopt FloatingPointLiteral Signopt HexFloatingPointLiteral SignedInteger HexFloatingPointLiteral: HexSignificand BinaryExponent FloatTypeSuffixopt HexSignificand: HexNumeral HexNumeral . 0x HexDigitsopt . HexDigits 0X HexDigitsopt . HexDigits BinaryExponent: BinaryExponentIndicator SignedInteger BinaryExponentIndicator: p P where Sign, FloatingPointLiteral, HexNumeral, HexDigits, SignedInteger and FloatTypeSuffix are as defined in the lexical structure sections of the of the Java Language Specification.
The mode argument specifies the access mode in which the file is to be opened. The permitted values and their meanings are: Value 	 Meaning r 	Open for reading only. Invoking any of the write methods of the resulting object will cause an {@link java.io.IOException} to be thrown. rw 	Open for reading and writing. If the file does not already exist then an attempt will be made to create it. rws 	Open for reading and writing, as with rw, and also require that every update to the file's content or metadata be written synchronously to the underlying storage device. rwd 	Open for reading and writing, as with rw, and also require that every update to the file's content be written synchronously to the underlying storage device.
HTTP requires all request properties which can legally have multiple instances with the same key to use a comma-seperated list syntax which enables multiple properties to be appended into a single property.
The behavior of aforementioned conversion process can be adjusted by various flags: If the ALLOW_UNASSIGNED flag is used, the domain name string to be converted can contain code points that are unassigned in Unicode 3.2, which is the Unicode version on which IDN conversion is based. If the flag is not used, the presence of such unassigned code points is treated as an error. If the USE_STD3_ASCII_RULES flag is used, ASCII strings are checked against RFC 1122 and RFC 1123. It is an error if they don't meet the requirements.
If the system property java.util.jar.Pack200.Packer is defined, then the value is taken to be the fully-qualified name of a concrete implementation class, which must implement Packer.
Other strings starting with java. are reserved for future extensions and must not be used for application-defined formats.
The family should have a default resource bundle which simply has the same name as its family - MyResources - and will be used as the bundle of last resort if a specific locale is not supported.
The range may no only contain complete partitions but starts at the beginning of a line in the middle of a partition of the given content type. This requires that a partition delimiter can not contain a line delimiter.
The XMLFormatter can be used with arbitrary character encodings, but it is recommended that it normally be used with UTF-8.
The recommended encoding scheme to use is UTF-8. However, for compatibility reasons, if an encoding is not specified, then the default encoding of the platform is used.
@param nameConstraints a byte array containing the ASN.1 DER encoding of a NameConstraints extension to be used for checking name constraints. Only the value of the extension is included, not the OID or criticality flag.
This class also accepts dangling brackets but is strict about dangling metacharacters like +, ? and *, and will throw a {@link PatternSyntaxException} if it encounters them.
A character may start a Java identifier if and only if one of the following conditions is true: {@link #isLetter(char) isLetter(ch)} returns true {@link #getType(char) getType(ch)} returns LETTER_NUMBER ch is a currency symbol (such as $) ch is a connecting punctuation character (such as _).
Any URL that ends with a '/' is assumed to refer to a directory. Otherwise, the URL is assumed to refer to a JAR file which will be downloaded and opened as needed.
Any URL that ends with a '/' is assumed to refer to a directory. Otherwise, the URL is assumed to refer to a JAR file which will be opened as needed.
This method can handle both label and entire domain name, by assuming that labels in a domain name are always separated by dots.
It is assumed that all characters in the encoded string are one of the following: a through z, A through Z, 0 through 9, and -, _, ., and *. The character % is allowed but is interpreted as the start of a special escaped sequence.
Whether aliases are case sensitive is implementation dependent. In order to avoid problems, it is recommended not to use aliases in a KeyStore that only differ in case.
A URL can optionally specify a port, which is the port number to which the TCP connection is made on the remote host machine. If the port is not specified, the default port for the protocol is used instead. For example, the default port for http is 80. An alternative port could be specified as: http://www.socs.uts.edu.au:80/MosaicDocs-old/url-primer.html
@throws IllegalFormatException If a format string contains an illegal syntax, a format specifier that is incompatible with the given arguments, insufficient arguments given the format string, or other illegal conditions. For specification of all possible formatting errors, see the Details section of the formatter class specification.
With lenient interpretation, a date such as February 942
@param encodedKey the key, which is assumed to be encoded according to the PKCS #8 standard.
@param encodedKey the key, which is assumed to be encoded according to the X.509 standard.
@param currencyCode the ISO 4217 currency code, which consists of three upper-case letters between 'A' (U+0041) and 'Z' (U+005A)
The group class specified by the ActivationGroupDesc must be a concrete subclass of ActivationGroup and have a public constructor that takes two arguments: the ActivationGroupID for the group and the MarshalledObject containing the group's initialization data (obtained from the ActivationGroupDesc
@param obj the server object for which a stub is required. must either be a subclass of PortableRemoteObject
All elements inserted into the set must implement the {@link Comparable} interface.
All elements inserted into the set must implement the {@link Comparable} interface
all such keys must be mutually comparable: k1.compareTo(k2) must not throw a ClassCastException for any keys k1 and k2 in the map.
Compares this URI to another object, which must be a URI.
Compares this Timestamp object to the given Date, which must be a Timestamp object.
created SequenceInputStream by remembering the argument, which must be an Enumeration that produces objects whose run-time type is InputStream
param obj must be a Number or a Date.
The CertPath specified must be of a type that is supported by the validation algorithm, otherwise an InvalidAlgorithmParameterException will be thrown.
The CertPath specified must be of a type that is supported by the validation algorithm, otherwise an InvalidAlgorithmParameterException will be thrown.
All elements in the collection must be mutually comparable by the specified comparator (that is, comp.compare(e1, e2) must not throw a ClassCastException for any elements e1 and e2 in the collection).
All elements in the collection must be mutually comparable by the specified comparator (that is, comp.compare(e1, e2) must not throw a ClassCastException for any elements e1 and e2 in the collection).
All elements in the list must be mutually comparable using the specified comparator (that is, c.compare(e1, e2) must not throw a ClassCastException for any elements e1 and e2 in the list).
Furthermore, all elements in this range must be mutually comparable (that is, e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the array).
All elements in the range must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a ClassCastException for any elements e1 and e2 in the range).
Furthermore, all such elements must be mutually comparable: e1.compareTo(e2) (or comparator.compare(e1, e2)) must not throw a ClassCastException for any elements e1 and e2 in the sorted set.
Furthermore, all such keys must be mutually comparable: k1.compareTo(k2) (or comparator.compare(k1, k2)) must not throw a ClassCastException for any keys k1 and k2 in the sorted map.
Furthermore, all elements in the collection must be mutually comparable (that is, e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the collection).
Furthermore, all elements in the array must be mutually comparable (that is, e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the array).
All elements inserted into the set must be mutually comparable by the specified comparator: { comparator.compare(e1, e2)} must not throw a { ClassCastException} for any elements { e1} and { e2} in the set
All keys inserted into the map must be mutually comparable by the given comparator: comparator.compare(k1, k2) must not throw a ClassCastException for any keys k1 and k2 in the map
@param className the class name of the preference page; this class must implement IPreferencePage
@param node the node to add, which must implement IPreferenceNode
@param strategy The master formatting strategy, must implement {@link IFormattingStrategyExtension}
@param type The content type to register this strategy with, must implement {@link IFormattingStrategyExtension}
@param contentAssistant the content assistant which implements {@link IContentAssistantExtension2} and {@link IContentAssistantExtension4}
A regular expression, specified as a string, must first be compiled into an instance of this class.
All of the elements in an enum set must come from a single enum type that is specified, explicitly or implicitly, when the set is created.
All of the keys in an enum map must come from a single enum type that is specified, explicitly or implicitly, when the map is created.
The first element of each pair is the key, which must be a String, and the second element is the value associated with that key.
All keys and values must implement Comparable
The key must implement Comparable.
The key must implement Comparable.
The value must implement Comparable
The key must implement Comparable.
Copies all of the keys and values from the specified map to this map. Each key must be non-null and a MultiKey object.
The key must implement Comparable.
@param c Must implement Set
The value must implement Comparable.
Both key and value must implement Comparable.
The key must implement Comparable.
The value must implement Comparable.
@param obj the object to be serialized (must be serializable)
The group's class must be a concrete subclass of ActivationGroup.
The createGroup method has two requirements on the group to be created: 1) the group must be a concrete subclass of ActivationGroup, and 2) the group must have a constructor that takes two arguments: the group's ActivationGroupID, and the group's initialization data (in a java.rmi.MarshalledObject)
All keys inserted into the map must implement the {@link Comparable} interface.
@throws IllegalArgumentException if the constructor doesn't exist
@param the output type of the transformer - this extends O.
@param the output type of the transformer - this extends O.
Exceptions are thrown for problems with the OutputStream and for classes that should not be serialized. All exceptions are fatal to the OutputStream, which is left in an indeterminate state, and it is up to the caller to ignore or recover the stream state. @throws InvalidClassException Something is wrong with a class used by serialization. @throws NotSerializableException Some object to be serialized does not implement the java.io.Serializable interface.
Exceptions are thrown for problems with the InputStream and for classes that should not be deserialized. All exceptions are fatal to the InputStream and leave it in an indeterminate state; it is up to the caller to ignore or recover the stream state. @throws ClassNotFoundException Class of a serialized object cannot be found. @throws InvalidClassException Something is wrong with a class used by serialization. @throws StreamCorruptedException Control information in the stream is inconsistent. @throws OptionalDataException Primitive data was found in the stream instead of objects.
The property must implement java.util#Map.
The property must implement org.eclipse.jface.text#TypedPosition.
The property must implement org.eclipse.jface.text#IRegion.
The property must implement org.eclipse.jface.text#IDocument.
All elements in the list must implement the Comparable interface
The property must implement java.lang#Boolean.
The second parameter must be of type Object; therefore, the java.lang equivalent objects should be used for built-in types.
If the object is of a class implementing the interface SQLData, the JDBC driver should call the method SQLData.writeSQL to write it to the SQL data stream. If, on the other hand, the object is of a class implementing Ref, Blob, Clob, NClob, Struct, java.net.URL, RowId, SQLXML or Array, the driver should pass it to the database as a value of the corresponding SQL type.
@throws ClassCastException if the key or value is of an invalid type
@throws ClassCastException if the key or value is of an invalid type
If the system property java.util.jar.Pack200.Unpacker is defined, then the value is taken to be the fully-qualified name of a concrete implementation class, which must implement Unpacker.
The class is loaded using the default system class loader and must define a public constructor that takes a single parameter of type ClassLoader which is used as the delegation parent.
The parseObject method in the various Format classes requires a ParsePosition object as an argument.
One version of the format method in the various Format classes requires a FieldPosition object as an argument.
The second argument must be an object type; for integral values, the java.lang equivalent objects should be used.
The second argument must be an object type; for integral values, the java.lang equivalent objects should be used
@param collectionClass the type of collections to return from the map (must contain public no-arg constructor and extend Collection)
All keys inserted into a sorted map must implement the Comparable interface (or be accepted by the specified comparator).
@throws ClassCastException if the key is of an invalid type
The second parameter must be of type Object; therefore, the java.lang equivalent objects should be used for built-in types.
All keys inserted into the new map must implement the {@link Comparable} interface
All elements in the array must implement the {@link Comparable} interface
For an option that has a notion of on and off, and requires a non-boolean parameter, setting its value to anything other than Boolean(false) implicitly enables it.
All elements in this range must implement the {@link Comparable} interface
All elements inserted into a sorted set must implement the Comparable interface (or be accepted by the specified comparator).
All elements in the collection must implement the Comparable interface.
To successfully store and retrieve objects from a hashtable, the objects used as keys must implement the hashCode method and the equals method.
@throws ArrayStoreException if the runtime type of the specified array is not a supertype of the runtime type of every element in this queue
@throws ArrayStoreException if the runtime type of the specified array is not a supertype of the runtime type of every element in this list
@throws ArrayStoreException if the runtime type of the specified array is not a supertype of the runtime type of every element in this queue
@throws ArrayStoreException if the runtime type of the specified array is not a supertype of the runtime type of every element in this queue
@throws ArrayStoreException if the runtime type of the specified array is not a supertype of the runtime type of every element in this queue
@throws ArrayStoreException if the runtime type of the specified array is not a supertype of the runtime type of every element in this list
@throws ArrayStoreException if the runtime type of a is not a supertype of the runtime type of every element in this Vector
Any attempt to insert an element of the wrong type will result in an immediate ClassCastException.
@throws ClassCastException if the specified key cannot be compared with the keys currently in the map
@param size must be non-negative, and the sum position + size must be non-negative
@param limit the index after the last character. Must be greater than start
The length argument must be less than or equal to buf.length.
The length argument must be less than or equal to buf.length.
The length must be lesser or equal to the offset plus the length of the packet's buffer.
The initial index of the range (from) must lie between zero and original.length, inclusive.
The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case null is placed in all elements of the copy whose index is greater than or equal to original.length - from.
@param insertPos the position in the text where the character was inserted. Must not be less than the start of newParagraph, and must be less than the end of newParagraph.
The source and destination must have the same number of bands.
In that case, the number of bands in the source Raster must match the number of components in srcCspace, and the number of bands in the destination Raster must match the number of components in dstCspace
If the protected key is of type java.security.PrivateKey, it must be accompanied by a certificate chain certifying the corresponding public key
If the underlying keystore implementation is of type jks, key must be encoded as an EncryptedPrivateKeyInfo as defined in the PKCS #8 standard.
The length argument must be less than or equal to buf.length
aContainer must be a focus cycle root of aComponent or a focus traversal policy provider.
The length argument must be less than or equal to buf.length
The formats must be equal to one of {@link Control#FORMAT_PROPERTIES}, {@link Control#FORMAT_CLASS} or {@link Control#FORMAT_DEFAULT}.
The destination list must be at least as long as the source list.
The length argument must be less than or equal to buf.length.
The characters in the string must all be digits of the specified radix (as determined by whether {@link java.lang.Character#digit(char, int)} returns a nonnegative value), except that the first character may be an ASCII minus sign '-' ('\u002D') to indicate a negative value.
If the second argument is an InputStream then the stream must contain the number of bytes specified by scaleOrLength.
aContainer must be a focus cycle root of aComponent or a focus traversal policy provider
@param deletePos the position in the text where the character was removed. Must not be less than the start of newParagraph, and must not be greater than the end of newParagraph.
The length argument must be less than or equal to buf.length.
All elements in the array must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a ClassCastException for any elements e1 and e2 in the array)
The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case 0f is placed in all elements of the copy whose index is greater than or equal to original.length - from.
The initial index of the range (from) must lie between zero and original.length, inclusive.
The initial index of the range (from) must lie between zero and original.length, inclusive.
The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case 0L is placed in all elements of the copy whose index is greater than or equal to original.length - from.
The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case '\\u000' is placed in all elements of the copy whose index is greater than or equal to original.length - from.
The initial index of the range (from) must lie between zero and original.length, inclusive.
@param types a list of table types, which must be from the list of table types returned from {@link #getTableTypes}
A SubformatPattern must be a valid pattern string for the Format subclass used.
The initial index of the range (from) must lie between zero and original.length, inclusive.
The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case null is placed in all elements of the copy whose index is greater than or equal to original.length - from.
The initial index of the range (from) must lie between zero and original.length, inclusive.
The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case (byte)0 is placed in all elements of the copy whose index is greater than or equal to original.length - from.
Ideally, you should choose a value to accommodate as many threads as will ever concurrently modify the table.
@throws IllegalArgumentException if end is before start
@throws IllegalArgumentException if end is before start
@throws IllegalArgumentException if end is before start
@throws IllegalArgumentException if end index is before the start
@throws IllegalArgumentException if end index is before the start
When creating a ChoiceFormat, you must specify an array of formats and an array of limits. The length of these arrays must be the same.
If name is not null, it must be equal to the binary name of the class specified by the byte array b, otherwise a {@link NoClassDefFoundError} will be thrown.
You should always pass in the binary name of the class you are defining as well as the bytes.
If subjectKeyID is not null, it should contain a single DER encoded value corresponding to the contents of the extension value (not including the object identifier, criticality setting, and encapsulating OCTET STRING) for a SubjectKeyIdentifier extension.
@param b the bytes that make up the class data. The bytes in positions off through off+len-1 should have the format of a valid class file as defined by the Java Virtual Machine Specification.
If the JDBC type expected to be returned to this output parameter is specific to this particular database, sqlType should be java.sql.Types.OTHER.
If the JDBC type expected to be returned to this output parameter is specific to this particular database, sqlType should be java.sql.Types.OTHER.
The range must be sorted (as by the {@link #sort(double[], int, int)} method) prior to making this call.
The range must be sorted (as by the {@link #sort(float[], int, int)} method) prior to making this call.
Furthermore, all elements in the list must be mutually comparable (that is, e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the list).
The initial index of the range (from) must lie between zero and original.length, inclusive.
The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case (short)0 is placed in all elements of the copy whose index is greater than or equal to original.length - from.
The bytes in positions off through off+len-1 should have the format of a valid class file as defined by the Java Virtual Machine Specification
@param b The bytes that make up the class data. The bytes from positions b.position() through b.position() + b.limit() -1 should have the format of a valid class file as defined by the Java Virtual Machine Specification.
The initial index of the range (from) must lie between zero and original.length, inclusive.
The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case false is placed in all elements of the copy whose index is greater than or equal to original.length - from.
The implementation assumes * a.size() and b.size() represent the total cardinality of a and b, resp. * a.size() < Integer.MAXVALUE
The initial index of the range (from) must lie between zero and original.length, inclusive.
The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case 0d is placed in all elements of the copy whose index is greater than or equal to original.length - from.
The reader must contain the number of characters specified by length otherwise a SQLException will be generated when the PreparedStatement is executed.
The inputstream must contain the number of characters specified by length otherwise a SQLException will be generated when the PreparedStatement is executed.
The reader must contain the number of characters specified by length otherwise a SQLException will be generated when the PreparedStatement is executed.
@throws IllegalArgumentException if end index is before the start
The two maps must be a matching pair, normal and reverse.
@param b the bytes that make up the class data. The bytes from positions b.position() through b.position() + b.limit() -1 should have the format of a valid class file as defined by the Java Virtual Machine Specification.
If the given key is of type java.security.PrivateKey, it must be accompanied by a certificate chain certifying the corresponding public key.
If the given key is of type java.security.PrivateKey, it must be accompanied by a certificate chain certifying the corresponding public key.
. @throws ArithmeticException if { divisor==0} @throws ArithmeticException if { mc.precision} {@literal >} 0 and the result requires a precision of more than { mc.precision} digits.
@throws ArithmeticException if the result is inexact but the rounding mode is { UNNECESSARY}, or { mc.precision} {@literal >} 0 and the result of { this.divideToIntgralValue(divisor)} would require a precision of more than { mc.precision} digits.
@throws ArithmeticException if the result is inexact but the rounding mode is { UNNECESSARY}, or { mc.precision} {@literal >} 0 and the result of { this.divideToIntgralValue(divisor)} would require a precision of more than { mc.precision} digits.
If the second argument is an InputStream then the stream must contain the number of bytes specified by scaleOrLength.
If the second argument is an InputStream then the stream must contain the number of bytes specified by scaleOrLength. If the second argument is a Reader then the reader must contain the number of characters specified by scaleOrLength.
The inputstream must contain the number of characters specified by length, otherwise a SQLException will be generated when the CallableStatement is executed.
@param b The bytes that make up the class data. The bytes in positions off through off+len-1 should have the format of a valid class file as defined by the Java Virtual Machine Specification.
If the protected key is of type java.security.PrivateKey, it must be accompanied by a certificate chain certifying the corresponding public key.
The reader must contain the number of characters specified by length otherwise a SQLException will be generated when the CallableStatement is executed.
The reader must contain the number of characters specified by length otherwise a SQLException will be generated when the CallableStatement is executed.
When using the 'nowrap' option it is also necessary to provide an extra dummy byte as input. This is required by the ZLIB native library in order to support certain optimizations.
If both the language and country fields are missing, this function will return the empty string, even if the variant field is filled in (you can't have a locale with just a variant-- the variant must accompany a valid language or country code).
In a simple case, a partition token scanner must always start at a partition boundary.
Note that thes margins will be added to the ones specified by {@link #margins(int, int)}.
The data is assumed to be in the specified encoding.
@exception IndexOutOfBoundsException If off is negative, len is negative, or len is greater than b.length - off
If it is critical to obtain every active thread in this thread group and its subgroups, the caller should verify that the returned int value is strictly less than the length of list.
This value should not be cached, as it may be changed by a call to setPolicy.
The returned parameter object must be initialized via a call to init, using an appropriate parameter specification or parameter encoding.
The returned parameter object must be initialized via a call to init, using an appropriate parameter specification or parameter encoding.
Once an AlgorithmParameters object is obtained, it must be initialized via a call to init, using an appropriate parameter specification or parameter encoding.
The returned parameter object must be initialized via a call to init, using an appropriate parameter specification or parameter encoding.
The method readObject is used to read an object from the stream. Java's safe casting should be used to get the desired type.
The return value should always be checked to make sure that the rename operation was successful.
@return the dialog, after being closed by the user, which the client can only call getReturnCode() or getToggleState()
@return the dialog, after being closed by the user, which the client can only call getReturnCode() or getToggleState()
@return the dialog, after being closed by the user, which the client can only call getReturnCode() or getToggleState()
@return the dialog, after being closed by the user, which the client can only call getReturnCode() or getToggleState()
@return the dialog, after being closed by the user, which the client can only call getReturnCode() or getToggleState()
@return the dialog, after being closed by the user, which the client can only call getReturnCode() or getToggleState()
@return the dialog, after being closed by the user, which the client can only call getReturnCode() or getToggleState()
callers can only use the viewer row locally and until the next call to this method.
If it is not then it must not be changed.
The keys should be immutable If they are not then they must not be changed after adding to the MultiKey.
The keys should be immutable If they are not then they must not be changed after adding to the MultiKey.
The keys should be immutable If they are not then they must not be changed after adding to the MultiKey.
If getKey() or getValue() returns null, it means the mapping is stale and should be removed.
To achieve laziness the actual work of parsing the available provider-configuration files and instantiating providers must be done by the iterator itself.
The returned image must be explicitly disposed using the image's dispose call.
The image is owned by the label provider and must not be disposed directly.
Any color allocated in this manner must be disposed by calling {@link #destroyColor(RGB)}, or by an eventual call to {@link #dispose()}. {@link Color#dispose()} must never been called directly on the returned color.
Creates an image, given an image descriptor. Images allocated in this manner must be disposed by {@link #destroyImage(ImageDescriptor)}, and never by calling {@link Image#dispose()}.
After the use of the context, clients are required to call its dispose method.
Note: Even if returnMissingImageOnError is true, it is still possible for this method to return null in extreme cases, for example if SWT runs out of image handles.
If uppercase letters are desired, the {@link java.lang.String#toUpperCase()} method may be called on the result: Integer.toString(n, 16).toUpperCase()
If uppercase letters are desired, the {@link java.lang.String#toUpperCase()} method may be called on the result: Integer.toHexString(n).toUpperCase()
If the method returns true, then the window can be shown without any special restrictions.
{@link Color#dispose()} must never been called directly on the returned color.
The resources returned from this method are reference counted and may be shared internally with other resource managers. They should never be disposed outside of the ResourceManager framework, or it will cause exceptions in other code that shares them. For example, never call {@link org.eclipse.swt.graphics.Resource#dispose()} on anything returned from this method.
t is never correct to use the return value of this method to allocate a buffer intended to hold all data in this stream.
@return the corresponding widget, or null if none
These Map.Entry objects are valid only for the duration of the iteration; more formally, the behavior of a map entry is undefined if the backing map has been modified after the entry was returned by the iterator, except through the setValue operation on the map entry.
Note: Clients must not make any assumptions about the returned proposals. This can change from release to release to adapt to changes made in {@link FindReplaceDocumentAdapter}.
The method {@link Font#dispose()} must never be called directly on the returned font.
Return a list of controls which should never have their foreground color reset.
Unlike the otherwise equivalent newScheduledThreadPool(1, threadFactory) the returned executor is guaranteed not to be reconfigurable to use additional threads.
Unlike the otherwise equivalent newScheduledThreadPool(1) the returned executor is guaranteed not to be reconfigurable to use additional threads.
The atomic classes also support method weakCompareAndSet, which has limited applicability. On some platforms, the weak version may be more efficient than compareAndSet in the normal case, but differs in that any given invocation of the weakCompareAndSet method may return false spuriously (that is, for no apparent reason). A false return means only that the operation may be retried if desired, relying on the guarantee that repeated invocation when the variable holds expectedValue and no other thread is also attempting to set the variable will eventually succeed.
@return the message, or null if none
If a thread does not lock any object monitor or lockedMonitors is false, the returned ThreadInfo object will have an empty MonitorInfo array. Similarly, if a thread does not lock any synchronizer or lockedSynchronizers is false, the returned ThreadInfo object will have an empty LockInfo array.
@return the quick assist assistant or null if none is configured
Because the actual set of threads may change dynamically while constructing this result, the returned collection is only a best-effort estimate.
Best effort method, meaning we may not be able to return the FQDN depending on the underlying system configuration.
@return All of the active bindings (Binding), not sorted in any fashion. This collection may be empty, but it is never null.
@return The key sequence; never null.
@return A map of triggers (TriggerSequence) to bindings (Binding). This map may be empty, but it is never null.
@return The key sequence representation; never null.
@return The Xemacs formatter; never null.
@return The SWT look-up table for key stroke format information; never null.
@return a newly allocated Font (never null)
@return {@link String} or null if the tool tip text was never set.
@return The singleton instance; this value is never null.
Clients should always assume that running the action succeeded in the absence of notification to the contrary.
@return the accelerator text, or null
@return the button for the ID or null
If createButton was never called with this parameter, or if createButton is overridden, getOKButton will return null. @return the OK button or null
Returns 0 after EOF has been reached, otherwise always return 1.
@return 1 before EOF and 0 after EOF.
@return the type of Certificates in this certification path (never null)
@return the public key of the subject (never null)
@return a ResultSet object that contains the data produced by the given query; never null
@return settings the dialog settings used to store the dialog's location and/or size, or null if the dialog's bounds should never be stored.
@return The raw scheme-specific part of this URI (never null)
@return An array of the command options which will be passed to the new child command by rmid. Note that rmid may add other options before or after these options, or both. Never returns null.
@return The default formatter; never null.
@return The active locale; never null.
@return The scheme identifier; never null.
@return The context identifier; never null.
@return the font descriptor (never null)
@return an instance of IKeyFormatter appropriate for the current instance; never null.
@return The default look-up; never null.
@return Read-only {@link Map} of the current conflicts. If no conflicts, then return an empty map. Never null
@return The child nodes; may be null, but never empty.
@return the font descriptor (never null)
@return The array of active triggers (TriggerSequence) for a particular command identifier. This value is guaranteed to never be null, but it may be empty.
Returns the viewer represented by this target, never null.
The returned map will never contain null keys or values.
@return the OID (never null)
@return a ResultSet object that contains the data produced by the query; never null
@return The decoded scheme-specific part of this URI (never null)
@return the ASN.1 DER encoded bytes (never null)
@return the number of processors available to the virtual machine; never smaller than one.
The value returned is between 0 and 61.
Should return null if no value is returned by the script execution.
The computed result must be within 1 ulp of the exact result.
Results must be semi-monotonic
@param iface A Class defining an interface that the result must implement
The returned control's layout data must be an instance of GridData.
The returned control's layout data must be an instance of GridData.
@return an integer array of 3 elements. The first element must be greater than 0. The second element must be must be greater than 0. The third element must be either 3 or 4.
@param printerResolution an integer array of 3 elements. The first element must be greater than 0. The second element must be must be greater than 0. The third element must be either 3 or 4.
Ranges must be in ascending order and must not overlap.
The computed result must be within 1 ulp of the exact result. Results must be semi-monotonic.
Override to only return true when there is a value transformer.
It must contain at least a Locale instance equal to {@link java.util.Locale#US Locale.US}.
Returns an array of all locales for which the getInstance methods of this class can return localized instances. It must contain at least a Locale instance equal to {@link java.util.Locale#US Locale.US}
Returns an array of all locales for which the getInstance methods of this class can return localized instances. It must contain at least a Locale instance equal to {@link java.util.Locale#US Locale.US}
Returns an array of all locales for which the get*Instance methods of this class can return localized instances. It must contain at least a Locale instance equal to {@link java.util.Locale#US Locale.US}
Returns an array of all locales for which the getInstance methods of this class can return localized instances. It must contain at least a Locale instance equal to {@link java.util.Locale#US Locale.US}.
Returns an array of all locales for which the get*Instance methods of this class can return localized instances. It must contain at least a Locale instance equal to {@link java.util.Locale#US Locale.US}
Thus, a custom equals method for a collection class that implements neither the List nor Set interface must return false when this collection is compared to any list or set.
The returned set will contain the endpoints themselves, which may be identical but must not be out of order.
If the resource is to be cached, then put() must return a CacheRequest object which contains a WriteableByteChannel that the protocol handler will use to write the resource into the cache. If the resource is not to be cached, then put must return null.
If this set makes any guarantees as to what order its elements are returned by its iterator, this method must return the elements in the same order.
If a like-named child of this node was previously removed, the implementer must return a newly constructed AbstractPreferences node; once removed, an AbstractPreferences node cannot be resuscitated.
An applet should override this method to return a String containing information about the author, version, and copyright of the applet.
This value may be null if there is no extra information.
The returned control's layout data must be an instance of GridData.
The computed result must be within 1 ulp of the exact result. Results must be semi-monotonic.
The computed result must be within 1 ulp of the exact result. Results must be semi-monotonic.
The computed result must be within 1 ulp of the exact result. Results must be semi-monotonic.
The computed result must be within 1 ulp of the exact result. Results must be semi-monotonic.
The computed result must be within 1 ulp of the exact result. Results must be semi-monotonic.
The computed result must be within 1 ulp of the exact result. Results must be semi-monotonic.
The computed result must be within 1 ulp of the exact result. Results must be semi-monotonic.
The computed result must be within 1 ulp of the exact result. Results must be semi-monotonic.
The computed result must be within 1 ulp of the exact result. If one parameter is held constant, the results must be semi-monotonic in the other parameter.
This version string must be a sequence of positive decimal integers separated by .'s and may have leading zeros.
The resulting proxy class must not exceed any limits imposed on classes by the virtual machine. For example, the VM may limit the number of interfaces that a class may implement to 65535; in that case, the size of the interfaces array must not exceed 65535.
The computed result must be within 1 ulp of the exact result. Results must be semi-monotonic. The result of expm1 for any finite input must be greater than or equal to -1.0.
How many digits must be printed for the fractional part of m or a? There must be at least one digit to represent the fractional part, and beyond that as many, but only as many, more digits as are needed to uniquely distinguish the argument value from adjacent values of type float. That is, suppose that x is the exact mathematical value represented by the decimal representation produced by this method for a finite nonzero argument f. Then f must be the float value nearest to x; or, if two float values are equally close to x, then f must be one of them and the least significant bit of the significand of f must be 0.
How many digits must be printed for the fractional part of m or a? There must be at least one digit to represent the fractional part, and beyond that as many, but only as many, more digits as are needed to uniquely distinguish the argument value from adjacent values of type double. That is, suppose that x is the exact mathematical value represented by the decimal representation produced by this method for a finite nonzero argument d. Then d must be the double value nearest to x; or if two double values are equally close to x, then d must be one of them and the least significant bit of the significand of d must be 0.
The computed result must be within 1 ulp of the exact result.
The computed result must be within 2.5 ulps of the exact result.
*The computed result must be within 2.5 ulps of the exact result. The result of tanh for any finite input must have an absolute value less than or equal to 1. Note that once the exact result of tanh is within 1/2 of an ulp of the limit value of 1, correctly signed 1.0 should be returned.
If the declared return type of the interface method is a primitive type, then the value returned by this method must be an instance of the corresponding primitive wrapper class; otherwise, it must be a type assignable to the declared return type.
If the return type is a parameterized type, the Type object returned must accurately reflect the actual type parameters used in the source code.
If the Type is a parameterized type, the Type object returned must accurately reflect the actual type parameters used in the source code.
by subclasses to use an alternate loading mechanism but must return a Class object
Any subclass returning a Composite object whose Layout has default margins (for example, a GridLayout) are expected to set the margins of this Layout to 0 pixels.
If a subclass that overrides this method creates a Composite that has a layout with default margins (for example, a GridLayout) it is expected to set the margins of this Layout to 0 pixels.
@return a new cursor iterator
@return a new synchronized Bag
@return a new transformed Bag
@return a new transformed SortedBag
This method should return the object to be substituted or the original object.
The computed result must be within 2.5 ulps of the exact result.
If a formal parameter type is a parameterized type, the Type object returned for it must accurately reflect the actual type parameters used in the source code.
If an exception type is a parameterized type, the Type object returned for it must accurately reflect the actual type parameters used in the source code.
If a formal parameter type is a parameterized type, the Type object returned for it must accurately reflect the actual type parameters used in the source code.
If an exception type is a parameterized type, the Type object returned for it must accurately reflect the actual type parameters used in the source code.
If the superclass is a parameterized type, the Type object returned must accurately reflect the actual type parameters used in the source code.
If a superinterface is a parameterized type, the Type object returned for it must accurately reflect the actual type parameters used in the source code.
Note that there must be at least one nonzero digit in a subnormal significand.
Note that there must be at least one nonzero digit in a subnormal significand.
The List returned must be immutable and thread-safe.
f this operation is supported, the returned set of permissions must be a new mutable instance and it must support heterogeneous Permission types.
the returned set of permissions must be a new mutable instance and it must support heterogeneous Permission types.
It must be unique for each certificate issued by a given CA (i.e., the issuer name and serial number identify a unique certificate).
All results returned by the {@link CertPathValidator#validate CertPathValidator.validate} method must implement this interface.
The specified date must be equal to or later than the value of the thisUpdate component of the X509CRL and earlier than the value of the nextUpdate component.
The certificate chain must have been associated with the alias by a call to setKeyEntry, or by a call to setEntry with a PrivateKeyEntry.
The certificate chain must have been associated with the alias by a call to setKeyEntry, or by a call to setEntry with a PrivateKeyEntry.
The certificates supplied must be of a type supported by the CertificateFactory.
The key must have been associated with the alias by a call to setKeyEntry, or by a call to setEntry with a PrivateKeyEntry or SecretKeyEntry.
The key must have been associated with the alias by a call to setKeyEntry, or by a call to setEntry with a PrivateKeyEntry or SecretKeyEntry.
@return a set of permissions granted to the specified ProtectionDomain. If this operation is supported, the returned set of permissions must be a new mutable instance and it must support heterogeneous Permission types
. All results returned by the {@link CertPathBuilder#build CertPathBuilder.build} method must implement this interface.
A certificate factory for X.509 must return certificates that are an instance of java.security.cert.X509Certificate, and CRLs that are an instance of java.security.cert.X509CRL.
If a zone does not implement daylight saving time, the daylight saving time names should not be used.
keySpec identifies the specification class in which the key material should be returned. It could, for example, be DSAPublicKeySpec.class, to indicate that the key material should be returned in an instance of the DSAPublicKeySpec class.
keySpec identifies the specification class in which the key material should be returned. It could, for example, be DSAPublicKeySpec.class, to indicate that the key material should be returned in an instance of the DSAPublicKeySpec class.
Subclasses should always return actions in what they consider to be their canonical form.
All X.509 certificate extensions that a PKIXCertPathChecker might possibly be able to process should be included in the set.
@return the predicate as the only element in an array
@return the predicate as the only element in an array
@return the predicate as the only element in an array
@return the predicate as the only element in an array
@return the predicate as the only element in an array
Override to only return true when there is a value transformer.
@return a new looping iterator
@return a new looping iterator
@return a new list containing the results
The driver should return null if it realizes it is the wrong kind of driver to connect to the given URL.
Subclasses that hook their own focus listener should override this method and return false.
Subclasses that hook their own focus listener should override this method and return false.
The result should be a concise but informative representation that is easy for a person to read.
If this set makes any guarantees as to what order its elements are returned by its iterator, this method must return the elements in the same order.
If this collection makes any guarantees as to what order its elements are returned by its iterator, this method must return the elements in the same order.
The first element of each pair is the key, which must be a String, and the second element is the value associated with that key.
Note that a new OutputStream object must be returned each time this method is called
An implementation of this method must either return a class with the given name or throw an exception.
An implementation of this method must either return a proxy class that implements the named interfaces or throw an exception.
In dialogs implemented by JFace, this will be an IDialogPage.
In dialogs implemented by JFace, this will be an IDialogPage.
In dialogs implemented by JFace, this will be an IDialogPage.
Note that once the exact result of ex - 1 is within 1/2 ulp of the limit value -1, -1.0 should be returned.
If the implementing method determines that no transformations are needed, it should return null. Otherwise, it should create a new byte[] array, copy the input classfileBuffer into it, along with all desired transformations, and return the new array.
The backtrace for a throwable with an initialized, non-null cause should generally include the backtrace for the cause.
Implementers have to ensure that {@link ITextHoverExtension#getHoverControlCreator()} returns {@link IInformationControl}s that implement {@link IInformationControlExtension2} and whose {@link IInformationControlExtension2#setInput(Object)} can handle the information objects returned by this method.
The returned information control creator must create information controls that implement {@link IInformationControlExtension3} and {@link IInformationControlExtension2}, and whose {@link IInformationControlExtension2#setInput(Object)} accepts all inputs that are also supported by this information control.
It is the responsibility of the implementor to fully format the message before returning it.
It must contain at least a Locale instance equal to {@link java.util.Locale#US Locale.US}.
The array returned must contain at least a Locale instance equal to {@link java.util.Locale#US Locale.US}.
The resulting file names must match exactly as strings with their occurrences in the JAR file.
The list returned by this method must have at least one String.
However, the returned List must not be mutated after it has been returned by getFormats.
If this collection makes any guarantees as to what order its elements are returned by its iterator, this method must return the elements in the same order.
It is permitted for this method to modify the map directly, but if it does so, it must return false (indicating that the map should not attempt any further modification).
If this set makes any guarantees as to what order its elements are returned by its iterator, this method must return the elements in the same order.
The last element of the list must be a {@linkplain Locale#ROOT root locale} if it is desired to have the base bundle as the terminal of the parent chain.
If the given locale is equal to Locale.ROOT (the root locale), a List containing only the root Locale must be returned.
However, the returned List must not be mutated after it has been returned by getCandidateLocales.
That is, for every nonnegative int index k,((BitSet)obj).get(k) == this.get(k)must be true.
The computed result must be within 1 ulp of the exact result. Results must be semi-monotonic.
A return value of 0 indicates that needsInput() should be called in order to determine if more input data is required.
The exact meaning of the three levels will vary between subsystems, but in general, FINEST should be used for the most voluminous detailed output, FINER for somewhat less detailed output, and FINE for the lowest volume (and most important) messages.
Subsets of any { NavigableSet} must implement the { NavigableSet} interface.
Submaps of any { NavigableMap} must implement the { NavigableMap} interface.
The value 0 indicates that a bundle must be validated each time it is retrieved from the cache.
Checks whether the map is currently empty, which it never is.
@return the array this iterator iterates over, or null if the no-arg constructor was used and {@link #setArray} has never been called with a valid array.
@return the array this iterator iterates over, or null if the no-arg constructor was used and {@link #setArray(Object)} has never been called with a valid array.
@return a suitable iterator, never null
This set should not support the add or remove methods, and its iterator should not support the remove method.
Reinitialize the logging properties and reread the logging configuration from the given stream, which should be in java.util.Properties format.
Under these circumstances, however, all subsequent invocations of flush() and sync should return false, as returning true would imply that all previous operations had successfully been made permanent.
If no symbol can be determined, null should be returned.
If daylight is true, the method should return a name appropriate for daylight saving time even if the specified time zone has not observed daylight saving time in the past.
The array may be the internal data structure of the predicate and thus should not be altered.
To be equal, the other object must be a MultiKey with the same number of keys which are also equal.
Implementations must return a SortedBidiMap instance, usually by forwarding to inverseSortedBidiMap().
Implementations must return an OrderedBidiMap instance, usually by forwarding to inverseOrderedBidiMap().
Gets the previous key before the key specified, always null.
Since this method always increases the size of the bag, according to the {@link Collection#add(Object)} contract, it should always return true.
Note that a new InputStream object must be returned each time this method is called, and the stream must be positioned at the beginning of the data.
Gets the next key after the key specified, always null.
If this set makes any guarantees as to what order its elements are returned by its iterator, this method must return the elements in the same order.
The method must return either a boolean or a non-null Boolean, and have no parameters.
A certificate factory for X.509 must return certificates that are an instance of java.security.cert.X509Certificate, and CRLs that are an instance of java.security.cert.X509CRL
In other words, this method must allocate a new array
In other words, this method must allocate a new array
The implementer must ensure that the returned node has not been removed.
@return never
The computed result must be within 2 ulps of the exact result. Results must be semi-monotonic.
If the minimal days required must be a full week, this method returns 7.
In other words, this method must allocate a new array
In other words, this method must allocate a new array
@return never @throws FunctorException always
@return never @throws FunctorException always
A cryptographically strong random number minimally complies with the statistical random number generator tests specified in FIPS 140-2, Security Requirements for Cryptographic Modules, section 4.9.1. Additionally, SecureRandom must produce non-deterministic output. Therefore any seed material passed to a SecureRandom object must be unpredictable, and all SecureRandom output sequences must be cryptographically strong, as described in RFC 1750: Randomness Recommendations for Security.
@return true if the range of characters requires bidi analysis
The returned parameters may be the same that were used to initialize this signature engine, or may contain a combination of default and randomly generated parameter values used by the underlying signature implementation if this signature engine requires algorithm parameters but was not initialized with any.
@return true if this call changed the collection
By convention, the object returned by this method should be independent of this object (which is being cloned). To achieve this independence, it may be necessary to modify one or more fields of the object returned by super.clone before returning it.
The iterator returned by the iterator method must implement hasNext and next.
In other words, this method must allocate a new array even if this list is backed by an array
The triggers can be anything, but above all it must be hashable.
Gets the key from the entry. This method dereferences weak and soft keys and thus may return null. @return the key, which may be null if it was garbage collected
The List interface requires that this method returns true always.
Evaluates the rule by examining the characters available from the provided character scanner. The token returned by this rule returns true when calling isUndefined, if the text that the rule investigated does not match the rule's requirements. Otherwise, this method returns this rule's success token.
Evaluates the rule by examining the characters available from the provided character scanner. The token returned by this rule returns true when calling isUndefined, if the text that the rule investigated does not match the rule's requirements
It is required that unequal key sequences return unequal strings.
@param returnValue The command's result, may be null.
@return a constant indicating how keystrokes in the proposal popup affect filtering of the proposals shown. FILTER_NONE specifies that no filtering will occur in the content proposal list as keys are typed. FILTER_CHARACTER specifies the content of the popup will be filtered by the most recently typed character. FILTER_CUMULATIVE is deprecated and no longer recommended.
@return true if cool bar layout is locked, false otherwise
@return the image to be shown or null if no image is desired
@param toolBarManager the manager or null if toolbar is not desired
Even under these circumstances it is generally better to simply ignore the invocation and return, rather than throwing an exception.
For instances where the viewer is displaying a tree containing a single 'root' element it is still necessary that the 'input' does not return itself from this method. This leads to recursion issues (see bug 9262).
Returns the greatest key strictly less than the given key, or { null} if there is no such key.
Returns the least element in this set strictly greater than the given element, or { null} if there is no such element.
Returns the least key strictly greater than the given key, or { null} if there is no such key.
The returned value is of nanoseconds precision but not necessarily nanoseconds accuracy.
Get the designated column's specified column size. For numeric data, this is the maximum precision. For character data, this is the length in characters. For datetime datatypes, this is the length in characters of the String representation (assuming the maximum allowed precision of the fractional seconds component). For binary data, this is the length in bytes. For the ROWID datatype, this is the length in bytes. 0 is returned for data types where the column size is not applicable.
The PRECISION column represents the specified column size for the given parameter or column. For numeric data, this is the maximum precision. For character data, this is the length in characters. For datetime datatypes, this is the length in characters of the String representation (assuming the maximum allowed precision of the fractional seconds component). For binary data, this is the length in bytes. For the ROWID datatype, this is the length in bytes. Null is returned for data types where the column size is not applicable
If the implementation distinguishes between user mode time and system mode time, the returned CPU time is the amount of time that the current thread has executed in user mode or system mode.
it should not normally be necessary to use this method.
It should not be called from application code.
Constructor only used in deserialization, do not use otherwise.
This is not intended to be called outside of the workbench.
This is not intended to be called outside of the workbench.
This is not intended to be called outside of the workbench.
Clients should not call this method directly, unless they have removed this contribution item from the containing IContributionManager before the contribution lifecycle has ended.
This method is internal to the framework; subclassers should not call this method.
This field should not be referenced by subclasses.
This field should not be referenced by subclasses.
This field should not be referenced by subclasses.
This field should not be referenced by subclasses.
Note: Using this method (as well as the Activatable constructors that both register and export an activatable remote object) is strongly discouraged because the actions of registering and exporting the remote object are not guaranteed to be atomic.
Note: Using the Activatable constructors that both register and export an activatable remote object is strongly discouraged because the actions of registering and exporting the remote object are not guaranteed to be atomic.
Note: Using the Activatable constructors that both register and export an activatable remote object is strongly discouraged because the actions of registering and exporting the remote object are not guaranteed to be atomic.
Note: Using this method (as well as the Activatable constructors that both register and export an activatable remote object) is strongly discouraged because the actions of registering and exporting the remote object are not guaranteed to be atomic.
Applications are discouraged from calling this method since this operation may not be supported by all policy implementations.
This constructor is used for serialization only and should not be used by subclasses.
This constructor should only be used for serialization.
Denigrated, use {@linkplain #setSubject(X500Principal)} or {@linkplain #setSubject(byte[])} instead. This method should not be relied on as it can fail to match some certificates because of a loss of encoding information in the RFC 2253 String form of some distinguished names.
Denigrated, replaced by {@linkplain #getSubjectX500Principal()}. This method returns the subject as an implementation specific Principal object, which should not be relied upon by portable code.
Denigrated, use {@linkplain #getIssuer()} or {@linkplain #getIssuerAsBytes()} instead. This method should not be relied on as it can fail to match some certificates because of a loss of encoding information in the RFC 2253 String form of some distinguished names.
Denigrated, use {@linkplain #getSubject()} or {@linkplain #getSubjectAsBytes()} instead. This method should not be relied on as it can fail to match some certificates because of a loss of encoding information in the RFC 2253 String form of some distinguished names.
Denigrated, replaced by {@linkplain #getIssuerX500Principal()}. This method returns the issuer as an implementation specific Principal object, which should not be relied upon by portable code.
Denigrated, use {@linkplain #addIssuer(X500Principal)} or {@linkplain #addIssuerName(byte[])} instead. This method should not be relied on as it can fail to match some CRLs because of a loss of encoding information in the RFC 2253 String form of some distinguished names.
Denigrated, replaced by {@linkplain #getIssuerX500Principal()}. This method returns the issuer as an implementation specific Principal object, which should not be relied upon by portable code.
Constructor only used in deserialization, do not use otherwise.
Constructor only used in deserialization, do not use otherwise.
Constructor only used in deserialization, do not use otherwise.
Constructor only used in deserialization,
Constructor only used in deserialization, do not use otherwise.
Constructor only used in deserialization, do not use otherwise.
Constructor only used in deserialization, do not use otherwise.
Constructor only used in deserialization, do not use otherwise.
Constructor only used in deserialization, do not use otherwise.
Constructor only used in deserialization, do not use otherwise.
Constructor only used in deserialization, do not use otherwise.
Application developers should only take notice of the methods defined in this MessageDigest class; all the methods in the superclass are intended for cryptographic service providers who wish to supply their own implementations of message digest algorithms
Applications are discouraged from calling this method since this operation may not be supported by all policy implementations. Applications should rely on the implies method to perform policy checks.
Note that this class is abstract and extends from SignatureSpi for historical reasons. Application developers should only take notice of the methods defined in this Signature class; all the methods in the superclass are intended for cryptographic service providers who wish to supply their own implementations of digital signature algorithms.
Note that this class is abstract and extends from KeyPairGeneratorSpi for historical reasons. Application developers should only take notice of the methods defined in this KeyPairGenerator class; all the methods in the superclass are intended for cryptographic service providers who wish to supply their own implementations of key pair generators.
This method is public for performance reasons only, to avoid a clone.
This method is deprecated and should not be used because SQL TIME values do not have a year component.
This method is deprecated and should not be used because SQL TIME values do not have a month component.
This method is deprecated and should not be used because SQL TIME values do not have a day component.
This method is deprecated and should not be used because SQL TIME values do not have a date component.
This method is deprecated and should not be used because SQL TIME values do not have a year component.
This method is deprecated and should not be used because SQL TIME values do not have a month component.
This method is deprecated and should not be used because SQL TIME values do not have a date component.
This method is deprecated and should not be used because SQL Date values do not have a time component.
This method is deprecated and should not be used because SQL Date values do not have a time component.
This method is deprecated and should not be used because SQL Date values do not have a time component.
This method is deprecated and should not be used because SQL Date values do not have a time component.
This method is deprecated and should not be used because SQL Date values do not have a time component.
This method is deprecated and should not be used because SQL Date values do not have a time component.
This method is internal to the framework; subclassers should not call this method.
This method is internal to the framework; subclassers should not call this method.
This method is internal to the framework; subclassers should not call this method.
This method is internal to the framework; subclassers should not call this method.
This method is internal to the framework; subclassers should not call this method.
This method is internal to the framework; subclassers should not call this method.
This method is internal to the framework; subclassers should not call this method.
This method is internal to the framework; subclassers should not call this method.
This method is internal to the framework; subclassers should not call this method.
This method is internal to the framework; subclassers should not call this method.
This method is internal to the framework; subclassers should not call this method.
This method is internal to the framework; subclassers should not call this method.
This method is internal to the framework; subclassers should not call this method.
This method is internal to the framework; subclassers should not call this method.
@noreference This method is not intended to be referenced by clients.
@noreference This method is not intended to be referenced by clients.
Do neither call nor override.
@deprecated this method should not be used.
This method should be used with extreme caution.
Due to the platform-dependent nature of the behavior of this constructor, extreme care should be exercised in its use.
This support will likely be removed in Eclipse 3.3 in favor of proper support for multiple equal elements (which was implemented for AbtractTreeViewer in 3.2).
@deprecated Initialization of this field is prone to deadlocks.
After close has been called this Handler should no longer be used.
Note: In general, clients should use Calendar.get(ZONE_OFFSET) + Calendar.get(DST_OFFSET) instead of calling this method.
SplitMapUtils should not normally be instantiated.
MapUtils should not normally be instantiated.
ListUtils should not normally be instantiated.
BufferUtils should not normally be instantiated.
ComparatorUtils should not normally be instantiated.
CollectionUtils should not normally be instantiated.
SetUtils should not normally be instantiated.
Because Properties inherits from Hashtable, the put and putAll methods can be applied to a Properties object. Their use is strongly discouraged as they allow the caller to insert entries whose keys or values are not Strings. The setProperty method should be used instead.
Ordinary applications should have no need to invoke any of these methods, which can be identified by the fact that they are declared to throw {@link BackingStoreException}.
Constructor whose use should be avoided.
Not intended for interactive use outside of subclasses.
As of 3.4, you should only call this method if you want to override the {@link JFacePreferences#CONTENT_ASSIST_FOREGROUND_COLOR}.
As of 3.4, you should only call this method if you want to override the {@link JFacePreferences#CONTENT_ASSIST_BACKGROUND_COLOR}.
This method should only be called from overriding methods or from setInformation.
If {@link ICompletionProposalExtension5} is implemented, this method should not be called any longer.
Since changing the default locale may affect many different areas of functionality, this method should only be used if the caller is prepared to reinitialize locale-sensitive code running within the same Java Virtual Machine.
Note: This is an internal framework method and must not be called by clients.
Note, that although NodeChangeEvent inherits Serializable interface from java.util.EventObject, it is not intended to be Serializable.
Note, that although PreferenceChangeEvent inherits Serializable interface from EventObject, it is not intended to be Serializable.
Users of SWT.VIRTUAL should also avoid using getItems() from the Table within the TreeViewer as this does not necessarily generate a callback for the TreeViewer to populate the items. It also has the side effect of creating all of the items thereby eliminating the performance improvements of SWT.VIRTUAL.
This interface, used only for custom mapping, is used by the driver behind the scenes, and a programmer never directly invokes SQLInput methods.
The string representation of this binding -- for debugging purposes only.
Internal method which returns a string representation of this selection suitable for debug purposes only.
The string representation of this command -- for debugging purposes only.
Internal debug method for printing statistics about this manager to System.out.
This string is for debugging purposes only, and is not meant to be displayed to the user.
Returns a printable representation of this wizard page suitable only for debug purposes.
Returns a string representation of this contribution item suitable only for debugging.
Note: This method is not intended to be referenced or overridden by clients.
Note, the keeper must not call releaseWidgetToken(IWidgetTokenKeeper) explicitly.
@exception java.lang.IllegalArgumentException if this method is invoked
This method is intended to be used only for debugging purposes, and the format of the returned string may vary between implementations.
This method is used only for debugging.
The output stream for writing the attributes of a user-defined type back to the database. This interface, used only for custom mapping, is used by the driver, and its methods are never directly invoked by a programmer.
Clients may neither instantiate this class nor extend.
Clients may neither instantiate nor extend this class.
This class is not intended to be called or extended by any external clients.
@noinstantiate This class is not intended to be instantiated by clients.
@noinstantiate This class is not intended to be instantiated by clients.
@noinstantiate This class is not intended to be instantiated by clients.
@noinstantiate This class is not intended to be instantiated by clients.
It should never be accessed by application code.
It should never be accessed by application code.
Application code should never directly reference this class
Therefore an RMI application should use the SecurityManager class or another application-specific SecurityManager implementation instead of this class.
An application should not normally try to catch ThreadDeath unless it must do some extraordinary cleanup operation (note that the throwing of ThreadDeath causes finally clauses of try statements to be executed before the thread officially dies). If a catch clause catches a ThreadDeath object, it is important to rethrow the object so that the thread actually dies.
Granting AllPermission should be done with extreme care, as it implies all other permissions. Thus, it grants code the ability to run with security disabled. Extreme caution should be taken before granting such a permission to code. This permission should be used only during testing, or in extremely rare cases where an application or applet is completely trusted and adding the necessary permissions to the policy is prohibitively cumbersome.
@noinstantiate This class is not intended to be instantiated by clients.
NOTE: This class is obsolete. New implementations should implement the Map interface, rather than extending this class.
This class is for Preferences implementers only. Normal users of the Preferences facility should have no need to consult this documentation.
A more complete and consistent set of LIFO stack operations is provided by the {@link Deque} interface and its implementations, which should be used in preference to this class.
For sequential access data (such as a linked list), {@link AbstractSequentialList} should be used in preference to this class.
When a LogRecord is passed into the logging framework it logically belongs to the framework and should no longer be used or updated by the client application.
This class is for Preferences implementers only. Normal users of the Preferences facility should have no need to consult this documentation.
Therefore, it would be wrong to write a program that depended on this exception for its correctness: ConcurrentModificationException should be used only to detect bugs.
Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs.
Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs.
Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs.
Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs.
Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs.
Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs.
Therefore, it would be wrong to write a program that depended on this exception for its correctness: fail-fast iterators should be used only to detect bugs.
Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs.
Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs.
Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs.
Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs.
Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs.
Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs.
@deprecated no replacement. Skeletons are no longer required for remote method calls in the Java 2 platform v1.2 and greater.
@deprecated no replacement. Skeletons are no longer required for remote method calls in the Java 2 platform v1.2 and greater.
@deprecated As of 3.3, this class is no longer necessary.
@deprecated As of 3.3, this class is no longer necessary.
@deprecated This class incorrectly assumes that bytes adequately represent characters. As of JDK 1.1, the preferred way to operate on character streams is via the new character-stream classes, which include a class for counting line numbers.
It should never be accessed by application code.
This class may be instantiated;
This class may be instantiated;
This class may be instantiated;
This class may be instantiated;
This class may be instantiated
This class may be instantiated;
{@link CoolBarManager}, which clients may instantiate or subclass.
This class may be instantiated;
This class may be instantiated;
This class may be instantiated;
This concrete dialog class can be instantiated as is
This concrete dialog class can be instantiated as is
This concrete dialog class can be instantiated as is
This class is intended to be instantiated and used by clients.
This class may be instantiated;
This class may be used as is
This class may be used as is
Clients may instantiate this class
Clients may instantiate this class
Clients may instantiate this class
Clients may use this class, although this is not usually needed except when implementing a custom template preference page or template store.
Clients can implement this interface and its extension interfaces, subclass {@link AbstractInformationControl}, or use the (text-based) default implementation {@link DefaultInformationControl}.
Clients may instantiate this class.
This class may be instantiated;
This class may be instantiated;
This class may be instantiated;
This class may be instantiated;
This class may be instantiated;
Clients may call this framework method
Constructor for use by subclasses.
This method is used by subclasses to explicitly close the popup based on additional logic.
Subclasses may use this.
The setFeedbackEnabled method can be called to turn on and off visual insertion feedback (on by default).
This is used for computing the initial window position, and subclasses can use this as a utility method if they want to limit the region in which the window may be moved.
This method may be called from subclasses to enable or disable owner draw dynamically.
Clients may call this framework method
Clients may call this framework method
Clients may call this framework method
Clients may call this framework method
Call this internal framework method to superimpose another image atop this composite image.
It is generally true of all the reading routines in this class that if end-of-file is reached before the desired number of bytes has been read, an EOFException (which is a kind of IOException) is thrown.
@exception IOException if an I/O error occurs.
@exception ZipException if a ZIP format error has occurred
@exception IOException if an I/O error has occurred
@exception IOException if an I/O error occurs when binding this socket.
@exception SQLException if the parameterIndex is not valid; if a database access error occurs or this method is called on a closed CallableStatement
@exception SQLFeatureNotSupportedException if the JDBC driver does not support this method
@throws IOException if an I/O error occurs or this stream is already closed
@throws ZipException if a compression (ZIP) format error occurs
@exception IOException if an I/O error occurs.
@throws SQLException if an error occurs releasing the Blob's resources @exception SQLFeatureNotSupportedException if the JDBC driver does not support this method
@exception IOException on encoding errors, or if this parameter object has not been initialized.
@exception SQLException if a database access error occurs or this method is called on a closed Statement
@exception java.io.IOException if an I/O error occurs. @exception java.io.StreamCorruptedException If already been called.
@throws IOException if an I/O error occurs when waiting for a connection.
@throws SQLException if a database access error occurs
@exception SQLException if the columnIndex is not valid; if a database access error occurs; the result set concurrency is CONCUR_READ_ONLY or this method is called on a closed result set @exception SQLFeatureNotSupportedException if the JDBC driver does not support this method
@exception IOException if there is an error joining or when the address is not a multicast address.
@throws SocketException If an I/O error occurs.
@exception IOException if an I/O error occurs. @exception SocketTimeoutException if setSoTimeout was previously called and the timeout has expired. @exception PortUnreachableException may be thrown if the socket is connected to a currently unreachable destination. Note, there is no guarantee that the exception will be thrown. @exception java.nio.channels.IllegalBlockingModeException if this socket has an associated channel, and the channel is in non-blocking mode
@throws SQLException if parameterName does not correspond to a named parameter; if the driver does not support national character sets; if the driver can detect that a data conversion error could occur; if a database access error occurs or this method is called on a closed CallableStatement @exception SQLFeatureNotSupportedException if the JDBC driver does not support this method
@exception SQLException if the parameterIndex is not valid; if a database access error occurs or this method is called on a closed CallableStatement @exception SQLFeatureNotSupportedException if the JDBC driver does not support this method
@exception SocketException if there is an error in the underlying protocol, such as a TCP error.
@throws IOException if an I/O error occurs.
@exception SQLException if a database access error occurs
@exception SQLException if a database access error occurs
@exception IOException if an I/O error occurs.
@exception IOException if an I/O error occurs.
@exception IOException if an I/O error occurs
@exception SocketException if there is an error in the underlying protocol, such as a TCP error.
@throws EOFException If end of file is reached. @throws IOException If other I/O error has occurred.
@exception IOException if an I/O error occurs.
@exception SocketException if there is an error in the underlying protocol, such as an UDP error.
@throws IllegalStateException if not all the elements can be added at this time due to insertion restrictions
@throws IllegalStateException if the element cannot be added at this time due to capacity restrictions @throws ClassCastException if the class of the specified element prevents it from being added to this queue @throws NullPointerException if the specified element is null and this queue does not permit null elements @throws IllegalArgumentException if some property of this element prevents it from being added to this queue
If a security manager exists, its {@link SecurityManager#checkPermission checkPermission} method is called with a {@link RuntimePermission}(getenv.+name) permission. This may result in a {@link SecurityException} being thrown. If no exception is thrown the value of the variable name is returned.
@throws SecurityException If a security manager exists and its {@link java.lang.SecurityManager#checkWrite(java.lang.String)} method denies write access to the file
@param filename the file to load. @exception SecurityException if a security manager exists and its checkLink method doesn't allow loading of the specified dynamic library @exception UnsatisfiedLinkError if the file does not exist.
Unlike other output streams, a PrintStream never throws an IOException; instead, exceptional situations merely set an internal flag that can be tested via the checkError method.
The returned Iterator is a weakly consistent iterator that will never throw {@link ConcurrentModificationException}, and guarantees to traverse elements as they existed upon construction of the iterator, and may (but is not guaranteed to) reflect any modifications subsequent to construction.
The returned Iterator is a weakly consistent iterator that will never throw {@link ConcurrentModificationException}, and guarantees to traverse elements as they existed upon construction of the iterator, and may (but is not guaranteed to) reflect any modifications subsequent to construction.
The view's iterator is a weakly consistent iterator that will never throw {@link ConcurrentModificationException}, and guarantees to traverse elements as they existed upon construction of the iterator, and may (but is not guaranteed to) reflect any modifications subsequent to construction.
The view's iterator is a weakly consistent iterator that will never throw {@link ConcurrentModificationException}, and guarantees to traverse elements as they existed upon construction of the iterator, and may (but is not guaranteed to) reflect any modifications subsequent to construction.
The view's iterator is a weakly consistent iterator that will never throw {@link ConcurrentModificationException}, and guarantees to traverse elements as they existed upon construction of the iterator, and may (but is not guaranteed to) reflect any modifications subsequent to construction.
This method never throws an EOFException.
@throws IllegalFormatException If a format string contains an illegal syntax, a format specifier that is incompatible with the given arguments, insufficient arguments given the format string, or other illegal conditions. For specification of all possible formatting errors, see the Details section of the formatter class specification.
@exception SecurityException If a security manager, s, is present and any of the following conditions is met
@throws IllegalMonitorStateException if exclusive synchronization is not held @throws IllegalArgumentException if the given condition is not associated with this synchronizer @throws NullPointerException if the condition is null
@throws IllegalFormatException If a format string contains an illegal syntax, a format specifier that is incompatible with the given arguments, insufficient arguments given the format string, or other illegal conditions. For specification of all possible formatting errors, see the Details section of the Formatter class specification.
@throws NullPointerException If the format is null
@throws IllegalFormatException If a format string contains an illegal syntax, a format specifier that is incompatible with the given arguments, insufficient arguments given the format string, or other illegal conditions. For specification of all possible formatting errors, see the Details section of the formatter class specification.
@throws IllegalMonitorStateException if this lock is not held @throws IllegalArgumentException if the given condition is not associated with this lock @throws NullPointerException if the condition is null
@exception SecurityException If a security manager, s, is present and any of the following conditions is met
@exception SecurityException If a security manager, s, is present and any of the following conditions is met
@throws IllegalFormatException If a format string contains an illegal syntax, a format specifier that is incompatible with the given arguments, insufficient arguments given the format string, or other illegal conditions. For specification of all possible formatting errors, see the Details section of the formatter class specification.
@exception SecurityException If a security manager, s, is present and any of the following conditions is met: invocation of {@link SecurityManager#checkMemberAccess s.checkMemberAccess(this, Member.PUBLIC)} denies access to the constructors within this class the caller's class loader is not the same as or an ancestor of the class loader for the current class and invocation of {@link SecurityManager#checkPackageAccess s.checkPackageAccess()} denies access to the package of this class
Throws CloneNotSupportedException. This guarantees that enums are never cloned, which is necessary to preserve their singleton status. @return (never returns)
@throws IllegalArgumentException if the collection is null
l @throws IllegalArgumentException if obj1 or obj2 are not known to this Comparator and an alternative behavior has not been set via {@link #setUnknownObjectBehavior(UnknownObjectBehavior)}.
@throws ConcurrentModificationException If the list's modification count isn't the value that was expected.
@throws ClassCastException (runtime) if the input is the wrong class @throws IllegalArgumentException (runtime) if the input is invalid @throws FunctorException (runtime) if any other error occurs
@throws IOException if an IO error occurs
@throws IOException if an IO error occurs
@throws IOException if an IO error occurs
@throws IOException if a file error occurs
@throws IOException if a file error occurs
@throws IllegalArgumentException if end is before start @throws NullPointerException if array is null
@throws SecurityException If a security manager exists and its checkPermission method doesn't allow access to the system class loader. @throws IllegalStateException If invoked recursively during the construction of the class loader specified by the java.system.class.loader property. @throws Error If the system property java.system.class.loader is defined but the named class could not be loaded, the provider class does not define the required constructor, or an exception is thrown by that constructor when it is invoked. The underlying cause of the error can be retrieved via the {@link Throwable#getCause()} method.
@throws SecurityException If a required system property value cannot be accessed. @see java.io.File#isAbsolute()
@throws SecurityException If a required system property value cannot be accessed.
@throws IOException If an I/O error occurs, which is possible because the construction of the canonical pathname may require filesystem queries @throws SecurityException If a required system property value cannot be accessed, or if a security manager exists and its {@link java.lang.SecurityManager#checkRead} method denies read access to the file
@throws IOException If an I/O error occurs, which is possible because the construction of the canonical pathname may require filesystem queries @throws SecurityException If a required system property value cannot be accessed, or if a security manager exists and its {@link java.lang.SecurityManager#checkRead} method denies read access to the file
@throws SecurityException If a required system property value cannot be accessed.
@throws IOException if I/O errors occur while writing to the underlying stream
@throws IllegalFormatException If a format string contains an illegal syntax, a format specifier that is incompatible with the given arguments, insufficient arguments given the format string, or other illegal conditions. For specification of all possible formatting errors, see the Details section of the formatter class specification. @throws FormatterClosedException If this formatter has been closed by invoking its {@link #close()} method
@throws java.lang.instrument.UnmodifiableClassException if a specified class cannot be modified ({@link #isModifiableClass} would return false) @throws java.lang.UnsupportedOperationException if the current configuration of the JVM does not allow redefinition ({@link #isRedefineClassesSupported} is false) or the redefinition attempted to make unsupported changes @throws java.lang.ClassFormatError if the data did not contain a valid class @throws java.lang.NoClassDefFoundError if the name in the class file is not equal to the name of the class @throws java.lang.UnsupportedClassVersionError if the class file version numbers are not supported @throws java.lang.ClassCircularityError if the new classes contain a circularity @throws java.lang.LinkageError if a linkage error occurs @throws java.lang.NullPointerException if the supplied definitions array or any of its components is null @throws java.lang.ClassNotFoundException Can never be thrown (present for compatibility reasons only)
. @exception IOException if an I/O error occurs.
@exception NullPointerException If b is null. @exception IndexOutOfBoundsException If off is negative, len is negative, or len is greater than b.length - off
@exception IOException If an I/O error occurs
@exception IOException If an I/O error occurs
@exception IOException if an error is encountered.
@exception IOException if an I/O error occurs.
@exception IOException if I/O errors occur @exception ClassNotFoundException If the class for an object being restored cannot be found.
@exception SQLException if a database access error occurs @exception SQLFeatureNotSupportedException if the JDBC driver does not support this method
@exception SQLException if a database access error occurs; the result set concurrency is CONCUR_READ_ONLY, this method is called on a closed result set, if this method is called when the cursor is not on the insert row, or if not all of non-nullable columns in the insert row have been given a non-null value @exception SQLFeatureNotSupportedException if the JDBC driver does not support this method
@exception IOException if an I/O error occurs.
@exception IOException if an I/O error occurs.
@exception SQLException if the parameterIndex is not valid; if a database access error occurs or this method is called on a closed CallableStatement
@exception IOException If an I/O error occurs
@exception SQLException if the columnLabel is not valid; if a database access error occurs; the result set concurrency is CONCUR_READ_ONLY or this method is called on a closed result set @exception SQLFeatureNotSupportedException if the JDBC driver does not support this method
@exception IOException If the stream has not been marked, or if the mark has been invalidated, or if the stream does not support reset(), or if some other I/O error occurs
@exception SQLException if a database access error occurs
@exception SQLException if the columnIndex is not valid; if a database access error occurs; the result set concurrency is CONCUR_READ_ONLY or this method is called on a closed result set @exception SQLFeatureNotSupportedException if the JDBC driver does not support this method
@exception InvocationTargetException if the run method must propagate a checked exception, it should wrap it inside an InvocationTargetException; runtime exceptions and errors are automatically wrapped in an InvocationTargetException by this method @exception InterruptedException if the operation detects a request to cancel, using IProgressMonitor.isCanceled(), it should exit by throwing InterruptedException; this method propagates the exception
@exception NoSuchFieldException if a field with the specified name is not found. @exception NullPointerException if name is null @exception SecurityException If a security manager, s, is present and any of the following conditions is met: invocation of {@link SecurityManager#checkMemberAccess s.checkMemberAccess(this, Member.PUBLIC)} denies access to the field the caller's class loader is not the same as or an ancestor of the class loader for the current class and invocation of {@link SecurityManager#checkPackageAccess s.checkPackageAccess()} denies access to the package of this class
@exception SecurityException If a security manager, s, is present and any of the following conditions is met: invocation of {@link SecurityManager#checkMemberAccess s.checkMemberAccess(this, Member.PUBLIC)} denies access to the fields within this class the caller's class loader is not the same as or an ancestor of the class loader for the current class and invocation of {@link SecurityManager#checkPackageAccess s.checkPackageAccess()} denies access to the package of this class
@exception EOFException if this input stream has reached the end. @exception IOException the stream has been closed and the contained input stream does not support reading after close, or another I/O error occurs.
@exception EOFException if this input stream reaches the end before reading two bytes. @exception IOException the stream has been closed and the contained input stream does not support reading after close, or another I/O error occurs. @see java.io.FilterInputStream#in
@exception IllegalArgumentException - if the array is null, or if any of the indices is not between 0 and the number of elements in the list minus 1 (inclusive)
@exception IllegalArgumentException - if the index is not between 0 and the number of elements in the list minus 1 (inclusive)
@exception EOFException if this input stream reaches the end before reading all the bytes. @exception IOException the stream has been closed and the contained input stream does not support reading after close, or another I/O error occurs.
@exception EOFException if this input stream reaches the end before reading all the bytes. @exception IOException the stream has been closed and the contained input stream does not support reading after close, or another I/O error occurs. @exception UTFDataFormatException if the bytes do not represent a valid modified UTF-8 encoding of a string.
@exception SQLException if a database access error occurs, this method is called on a closed Statement or the condition seconds >= 0 is not satisfied
Each method of a remote interface, an interface that extends java.rmi.Remote, must list RemoteException in its throws clause.
@throws IllegalStateException implementations may, but are not required to, throw this exception if the entry has been removed from the backing map.
This constructor also must throw an IllegalArgumentException if it does not understand the Policy.Parameters input.
all such elements must be mutually comparable: { e1.compareTo(e2)} must not throw a { ClassCastException} for any elements { e1} and { e2} in the set
all such elements must be mutually comparable: { e1.compareTo(e2)} must not throw a { ClassCastException} for any elements { e1} and { e2} in the set.
Checked exception types thrown by underlying scripting implementations must be wrapped in instances of ScriptException.
This exception must be thrown in a consistent fashion for synchronization to work correctly.
This exception must be thrown in a consistent fashion for synchronization to work correctly.
@throws IllegalMonitorStateException if acquiring would place this synchronizer in an illegal state. This exception must be thrown in a consistent fashion for synchronization to work correctly.
This implies that compare(x, y) must throw an exception if and only if compare(y, x) throws an exception.
This exception must be thrown in a consistent fashion for synchronization to work correctly.
This exception must be thrown in a consistent fashion for synchronization to work correctly.
@throws org.eclipse.swt.SWTException in these cases: * {@link org.eclipse.swt.SWT#ERROR_WIDGET_DISPOSED} - if the receiver has been disposed * {@link org.eclipse.swt.SWT#ERROR_THREAD_INVALID_ACCESS} - if not called from the thread that created the receiver
@throws org.eclipse.swt.SWTException in these cases: * {@link org.eclipse.swt.SWT#ERROR_WIDGET_DISPOSED} - if the receiver has been disposed * {@link org.eclipse.swt.SWT#ERROR_THREAD_INVALID_ACCESS} - if not called from the thread that created the receiver
@throws org.eclipse.swt.SWTException in these cases: * {@link org.eclipse.swt.SWT#ERROR_WIDGET_DISPOSED} - if the receiver has been disposed * {@link org.eclipse.swt.SWT#ERROR_THREAD_INVALID_ACCESS} - if not called from the thread that created the receiver
@throws org.eclipse.swt.SWTException in these cases: * {@link org.eclipse.swt.SWT#ERROR_WIDGET_DISPOSED} - if the receiver has been disposed * {@link org.eclipse.swt.SWT#ERROR_THREAD_INVALID_ACCESS} - if not called from the thread that created the receiver
@throws org.eclipse.swt.SWTException in these cases: * {@link org.eclipse.swt.SWT#ERROR_WIDGET_DISPOSED} - if the receiver has been disposed * {@link org.eclipse.swt.SWT#ERROR_THREAD_INVALID_ACCESS} - if not called from the thread that created the receiver
@throws org.eclipse.swt.SWTException in these cases: * {@link org.eclipse.swt.SWT#ERROR_WIDGET_DISPOSED} - if the receiver has been disposed * {@link org.eclipse.swt.SWT#ERROR_THREAD_INVALID_ACCESS} - if not called from the thread that created the receiver
@throws org.eclipse.swt.SWTException in these cases: * {@link org.eclipse.swt.SWT#ERROR_WIDGET_DISPOSED} - if the receiver has been disposed * {@link org.eclipse.swt.SWT#ERROR_THREAD_INVALID_ACCESS} - if not called from the thread that created the receiver
@exception org.eclipse.swt.SWTException o {@link org.eclipse.swt.SWT#ERROR_WIDGET_DISPOSED} - if the receiver has been disposed o {@link org.eclipse.swt.SWT#ERROR_THREAD_INVALID_ACCESS} - if not called from the thread that created the receiver
# {@link org.eclipse.swt.SWT#ERROR_WIDGET_DISPOSED} - if the receiver has been disposed# {@link org.eclipse.swt.SWT#ERROR_THREAD_INVALID_ACCESS} - if not called from the thread that created the receiver
@throws Throwable the exception to throw from the method invocation on the proxy instance. The exception's type must be assignable either to any of the exception types declared in the throws clause of the interface method or to the unchecked exception types java.lang.RuntimeException or java.lang.Error.
If any exception is raised during the remote invocation, invoke should take care of cleaning up the connection before raising the user or remote exception.
Any attempts to modify the children of this node through the Iterator's remove method must throw an UnsupportedOperationException.
Any parse method that does not take a ParsePosition argument should throw ParseException when no text in the required format is at the beginning of the input text.
@throws CertPathValidatorException if this PKIXCertPathChecker is unable to check certificates in the specified order; it should never be thrown if the forward flag is false since reverse checking must be supported
@exception IllegalArgumentException if the given KeyStore.LoadStoreParameter input is not recognized @exception IOException if there is an I/O or format problem with the keystore data. If the error is due to an incorrect ProtectionParameter (e.g. wrong password) the {@link Throwable#getCause cause} of the IOException should be an UnrecoverableKeyException
@exception IllegalArgumentException if the given LoadStoreParameter input is not recognized @exception IOException if there is an I/O or format problem with the keystore data. If the error is due to an incorrect ProtectionParameter (e.g. wrong password) the {@link Throwable#getCause cause} of the IOException should be an UnrecoverableKeyException
@exception IOException if there is an I/O or format problem with the keystore data, if a password is required but not given, or if the given password was incorrect. If the error is due to a wrong password, the {@link Throwable#getCause cause} of the IOException should be an UnrecoverableKeyException
@exception IOException if there is an I/O or format problem with the keystore data, if a password is required but not given, or if the given password was incorrect. If the error is due to a wrong password, the {@link Throwable#getCause cause} of the IOException should be an UnrecoverableKeyException
Some provider implementations may encounter unrecoverable internal errors during their operation, for example a failure to communicate with a security token. A {@link ProviderException} should be used to indicate such errors.
The driver should throw an SQLException if it is the right driver to connect to the given URL but has trouble connecting to the database.
Applications should throw instances of this class to indicate other illegal uses of the null object.
If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false).
Note that null is not an instance of any class, and e.compareTo(null) should throw a NullPointerException even though e.equals(null) returns false.
that is, e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the list
@throws IllegalMonitorStateException if releasing would place this synchronizer in an illegal state. This exception must be thrown in a consistent fashion for synchronization to work correctly.
@throws IllegalMonitorStateException if releasing would place this synchronizer in an illegal state. This exception must be thrown in a consistent fashion for synchronization to work correctly.
If a resource bundle can't be instantiated due to an unexpected error, the error must be reported by throwing an Error or Exception rather than simply returning null.
This exception must be thrown in a consistent fashion for synchronization to work correctly.
Only explicit subtypes of this exception which correspond to specific errors should be instantiated.
For many such operations it is possible to return a value that indicates timeout; when that is not possible or desirable then TimeoutException should be declared and thrown.
Generally speaking, this method should not throw an exception under any circumstances.
Generally speaking, these SPI methods should not throw exceptions.
There is one circumstance under which putSpi, removeSpi and childSpi should throw an exception: if the caller lacks sufficient privileges on the underlying operating system to perform the requested operation.
The predicate itself should not throw an exception, but return false to indicate that the object cannot be added.
If the input object is null, a PredicateException is thrown.
@throws FunctorException always
@throws UnsupportedOperationException if the map is unmodifiable
@throws InvalidPreferencesFormatException Data on input stream does not constitute a valid XML document with the mandated document type.
@throws InvalidPropertiesFormatException Data on input stream does not constitute a valid XML document with the mandated document type.
@exception InvalidKeyException if the public key in the certificate is not encoded properly or does not include required parameter information or cannot be used for digital signature purposes.
@throws IllegalStateException implementations may, but are not required to, throw this exception if the entry has been removed from the backing map.
@throws IllegalStateException implementations may, but are not required to, throw this exception if the entry has been removed from the backing map.
This iterator does not support modification of its backing array's size, and so will always throw an {@link UnsupportedOperationException} when this method is invoked.
This iterator does not support modification of its backing collection, and so will always throw an {@link UnsupportedOperationException} when this method is invoked.
Runs the runnable. All ISafeRunnableRunners must catch any exception thrown by the ISafeRunnable and pass the exception to ISafeRunnable.handleException().
If a Registry method chooses to deny access for a given invocation, its implementation may throw {@link java.rmi.AccessException}, which (because it extends {@link java.rmi.RemoteException}) will be wrapped in a {@link java.rmi.ServerException} when caught by a remote client.
@throws IllegalArgumentException if endpoint is null or is a SocketAddress subclass not supported by this socket
@throws IllegalArgumentException if address is null or is a SocketAddress subclass not supported by this socket
@throws IllegalArgumentException if mcastaddr is null or is a SocketAddress subclass not supported by this socket
@exception IllegalArgumentException if the specified object is not an instance of the class or interface declaring the underlying field (or a subclass or implementor thereof)
@throws IllegalStateException if not all the elements can be added at this time due to insertion restrictions
@throws IllegalArgumentException if this map itself has a restricted range, and { toKey} lies outside the bounds of the range
@throws IllegalArgumentException if this set itself has a restricted range, and toElement lies outside the bounds of the range
Even under these circumstances it is generally better to simply ignore the invocation and return, rather than throwing an exception
@param x the new column value @exception SQLException if the columnLabel is not valid; if a database access error occurs; the result set concurrency is CONCUR_READ_ONLY or this method is called on a closed result set @exception SQLFeatureNotSupportedException if the JDBC driver does not support this method
@exception SQLException if there is an error accessing the length of the BLOB @exception SQLFeatureNotSupportedException if the JDBC driver does not support this method
@exception SQLException if an error occurs while attempting to access the array @exception SQLFeatureNotSupportedException if the JDBC driver does not support this method
@exception SQLException if the columnIndex is not valid; if a database access error occurs; the result set concurrency is CONCUR_READ_ONLY or this method is called on a closed result set @exception SQLFeatureNotSupportedException if the JDBC driver does not support this method
@exception SQLException if a database access error occurs
@exception SQLException if a database access error occurs
@exception SQLException if parameterName does not correspond to a named parameter; if a database access error occurs or this method is called on a closed CallableStatement @exception SQLFeatureNotSupportedException if the JDBC driver does not support this method
@exception SQLException if the columnIndex is not valid; if a database access error occurs; the result set concurrency is CONCUR_READ_ONLY or this method is called on a closed result set @exception SQLFeatureNotSupportedException if the JDBC driver does not support this method
@exception SQLException if the columnLabel is not valid; if a database access error occurs; the result set concurrency is CONCUR_READ_ONLY or this method is called on a closed result set @exception SQLFeatureNotSupportedException if the JDBC driver does not support this method
@exception SQLException if the columnLabel is not valid; if a database access error occurs; the result set concurrency is CONCUR_READ_ONLY or this method is called on a closed result set @exception SQLFeatureNotSupportedException if the JDBC driver does not support this method
@exception SQLException if the columnLabel is not valid; if a database access error occurs; the result set concurrency is CONCUR_READ_ONLY or this method is called on a closed result set @exception SQLFeatureNotSupportedException if the JDBC driver does not support this method
@throws IllegalArgumentException if this map itself has a restricted range, and { fromKey} lies outside the bounds of the range
@throws NullPointerException if toKey is null and this map does not permit null keys @throws IllegalArgumentException if this map itself has a restricted range, and toKey lies outside the bounds of the range
@throws NullPointerException if { fromElement} or { toElement} is null and this set does not permit null elements @throws IllegalArgumentException if { fromElement} is greater than { toElement}; or if this set itself has a restricted range, and { fromElement} or { toElement} lies outside the bounds of the range.
Inserts the specified element at the front of this deque if it is possible to do so immediately without violating capacity restrictions, throwing an IllegalStateException if no space is currently available
@throws IllegalStateException if the element cannot be added at this time due to capacity restrictions @throws ClassCastException if the class of the specified element prevents it from being added to this queue @throws NullPointerException if the specified element is null @throws IllegalArgumentException if some property of the specified element prevents it from being added to this queue
The input object should be immutable to maintain the contract of Transformer (although this is not checked).
@param obj Must have been previously the target of a call to {@link #exportObject}.
The url argument that is passed as an argument must specify an absolute URL.
The url that is passed as an argument must specify an absolute URL.
The XML document must have the following DOCTYPE declaration
Furthermore, the document must satisfy the properties DTD described above
The url argument must specify an absolute URL.
The number of dimensions of the new array must not exceed the number of array dimensions supported by the implementation (typically 255).
@param catalog a catalog name; must match the catalog name as it is stored in the database
@param schema a schema name; must match the schema name as it is stored in the database; retrieves those without a schema;
@param table a table name; must match the table name as it is stored in the database
@param columnNamePattern a column name pattern; must match the column name as it is stored in the database
IPv4 address byte array must be 4 bytes long and IPv6 byte array must be 16 bytes long
A URL must be absolute, that is, it must always specify a scheme
A client must use the VMID the garbage collector uses in order to make corresponding clean calls when the client drops remote object references
Bear in mind that Sets require immutable objects to function correctly.
All elements in the collection must implement the Comparable interface.
The list must be sorted into ascending order according to the {@linkplain Comparable natural ordering} of its elements (as by the {@link #sort(List)} method) prior to making this call.
The file component must be specified.
There are several restrictions on the parameters that may be passed to Proxy.getProxyClass: * All of the Class objects in the interfaces array must represent interfaces, not classes or primitive types. * No two elements in the interfaces array may refer to identical Class objects. * All of the interface types must be visible by name through the specified class loader. In other words, for class loader cl and every interface i, the following expression must be true: Class.forName(i.getName(), false, cl) == i * All non-public interfaces must be in the same package; otherwise, it would not be possible for the proxy class to implement all of the interfaces, regardless of what package it is defined in. * For any set of member methods of the specified interfaces that have the same signature: o If the return type of any of the methods is a primitive type or void, then all of the methods must have that same return type. o Otherwise, one of the methods must have a return type that is assignable to all of the return types of the rest of the methods.
The given CompositeData must contain the following attributes as well as the attributes specified in the mapped type for the {@link LockInfo} class
The given CompositeData must contain the following attributes:
The given CompositeData must contain the following attributes:
@param actions currently unused and must be set to null
@param newWeekdays the new weekday strings. The array should be indexed by Calendar.SUNDAY, Calendar.MONDAY, etc.
@param newShortWeekdays the new short weekday strings. The array should be indexed by Calendar.SUNDAY, Calendar.MONDAY, etc.
The file must be encoded in UTF-8.
The file must be encoded in UTF-8.
Gets a Transformer that invokes a method on the input object. The method must have no parameters.
@param map the map to copy, must be size 1
The Transformer must return either Boolean.TRUE or Boolean.FALSE otherwise a PredicateException will be thrown.
The argument must be a two-dimensional array of strings of size n by m, where m is at least 5. Each of the n rows is an entry containing the localized names for a single TimeZone.
@param p the proxy through which the connection will be made. If direct connection is desired, Proxy.NO_PROXY should be specified
@param proxy the Proxy through which this connection will be made. If direct connection is desired, Proxy.NO_PROXY should be specified.
The address 224.0.0.0 is reserved and should not be used.
@param p is the packet to be sent. The packet should contain the destination multicast ip address and the data to be sent.
@param b The bytes that make up the class data. The bytes in positions off through off+len-1 should have the format of a valid class file as defined by the Java Virtual Machine Specification.
Which commands are valid is system-dependent, but at the very least the command must be a non-empty list of non-null strings
**** deprecated tag (Value Directive - Parameter: too vague): Which commands are valid is system-dependent, but at the very least the command must be a non-empty list of non-null strings.
If subjectDN is not null, it should contain a single DER encoded distinguished name, as defined in X.501.
The name is provided as a byte array. This byte array should contain a single DER encoded distinguished name, as defined in X.501.
If issuerDN is not null, it should contain a single DER encoded distinguished name, as defined in X.501.
The map must not be null and should be empty or only contain valid keys.
The name constraints are specified as a byte array. This byte array should contain the DER encoded form of the name constraints, as they would appear in the NameConstraints structure defined in RFC 2459 and X.509.
The keys should be immutable If they are not then they must not be changed after adding to the MultiKey.
The java.util.Properties argument can be used to pass arbitrary string tag/value pairs as connection arguments. Normally at least user and password properties should be included in the Properties object.
The range must be sorted (as by the {@link #sort(int[], int, int)} method) prior to making this call
The range must be sorted (as by the {@link #sort(short[], int, int)} method) prior to making this call
The range must be sorted (as by the {@link #sort(char[], int, int)} method) prior to making this call.
The range must be sorted (as by the {@link #sort(byte[], int, int)} method) prior to making this call.
The array must be sorted (as by the {@link #sort(double[])} method) prior to making this call.
The range must be sorted (as by the {@link #sort(double[], int, int)} method) prior to making this call.
The array must be sorted (as by the {@link #sort(float[])} method) prior to making this call
The range must be sorted (as by the {@link #sort(float[], int, int)} method) prior to making this call.
The array must be sorted into ascending order according to the {@linkplain Comparable natural ordering} of its elements (as by the {@link #sort(Object[])} method) prior to making this call.
The array must be sorted into ascending order according to the specified comparator (as by the {@link #sort(Object[], Comparator) sort(T[], Comparator)} method) prior to making this call.
The list must be sorted into ascending order according to the specified comparator (as by the {@link #sort(List, Comparator) sort(List, Comparator)} method), prior to making this call
The given CompositeData must contain the following attributes
@param catalog a catalog name; must match the catalog name as it is stored in the database; retrieves those without a catalog;
@param schema a schema name; must match the schema name as it is stored in the database; retrieves those without a schema
@param table a table name; must match the table name as it is stored in the database
@param catalog a catalog name; must match the catalog name as it is stored in the database; retrieves those without a catalog; null means catalog name should not be used to narrow down the search.
@param catalog a catalog name; must match the catalog name as it is stored in the database; retrieves those without a catalog; null means that the catalog name should not be used to narrow the search
@param tableNamePattern a table name pattern; must match the table name as it is stored in the database
@param parentTable the name of the table that exports the key; must match the table name as it is stored in the database
@param name the new cursor name, which must be unique within a connection
The property file read with this constructor must be encoded in ISO-8859-1.
The specified list must be modifiable, but need not be resizable.
The range must be sorted into ascending order according to the {@linkplain Comparable natural ordering} of its elements (as by the {@link #sort(Object[], int, int)} method) prior to making this call
If the specified map is an EnumMap instance, this constructor behaves identically to {@link #EnumMap(EnumMap)}. Otherwise, the specified map must contain at least one mapping (in order to determine the new enum map's key type).
@param map the map to add, must be size 0 or 1, and the key must match
@param parentCatalog a catalog name; must match the catalog name as it is stored in the database;
@param foreignCatalog a catalog name; must match the catalog name as it is stored in the database; retrieves those without a catalog;
@param foreignSchema a schema name; must match the schema name as it is stored in the database;
@param catalog a catalog name; must match the catalog name as it is stored in the database; retrieves those without a catalog; null means that the catalog name should not be used to narrow the search
@param tableNamePattern a table name pattern; must match the table name as it is stored in the database @return ResultSet - each row is a table privilege description
@param schemaPattern a schema name pattern; must match the schema name as it is stored in the database; retrieves those without a schema; null means that the schema name should not be used to narrow the search
@param catalog a catalog name; must match the catalog name as it is stored in the database; retrieves those without a catalog; null means that the catalog name should not be used to narrow the search
@param schemaPattern a schema name pattern; must match the schema name as it is stored in the database; retrieves those without a schema; null means that the schema name should not be used to narrow the search
@param procedureNamePattern a procedure name pattern; must match the procedure name as it is stored in the database
@param catalog a catalog name; must match the catalog name as it is stored in the database; retrieves those without a catalog; null means that the catalog name should not be used to narrow the search
@param schemaPattern a schema name pattern; must match the schema name as it is stored in the database; retrieves those without a schema; null means that the schema name should not be used to narrow the search
@param procedureNamePattern a procedure name pattern; must match the procedure name as it is stored in the database
@param caller the principal invoking this method. It must be an owner of this ACL.
The XML document must have the following DOCTYPE declaration:
The method must return either a boolean or a non-null Boolean, and have no parameters.
@param collectionFactory the collection factory which must return a Collection instance
@param collectionFactory the collection factory (must return a Collection object).
If the first entry in the object array implements {@link java.util.Map.Entry} or {@link KeyValue} then the key and value are added from that object. If the first entry in the object array is an object array itself, then it is assumed that index 0 in the sub-array is the key and index 1 is the value. Otherwise, the array is treated as keys and values in alternate indices.
@throws ClassCastException if the array contents is mixed
@throws IllegalArgumentException if sub-array or entry matching used and an entry is invalid
The map must be empty and non-null.
The map must not be null and must be empty.
The formatting should include localization.
The agent should take care to ensure that the JAR does not contain any classes or resources other than those to be defined by the bootstrap class loader for the purpose of instrumentation. Failure to observe this warning could result in unexpected behaviour that is difficult to diagnose.
The array must be sorted (as by the {@link #sort(byte[])} method) prior to making this call
The array must be sorted (as by the {@link #sort(long[])} method) prior to making this call.
@param info a list of arbitrary string tag/value pairs as connection arguments; normally at least a user and password property should be included
To instantiate a PKIXBuilderParameters object, an application must specify one or more most-trusted CAs as defined by the PKIX certification path validation algorithm.
In addition, an application must specify constraints on the target certificate that the CertPathBuilder will attempt to build a path to. The constraints are specified as a CertSelector object. These constraints should provide the CertPathBuilder with enough search criteria to find the target certificate. Minimal criteria for an X509Certificate usually include the subject name and/or one or more subject alternative names. If enough criteria is not specified, the CertPathBuilder may throw a CertPathBuilderException.
@param catalog a catalog name; must match the catalog name as it is stored in the database; retrieves those without a catalog; null means that the catalog name should not be used to narrow the search
@param schema a schema name; must match the schema name as it is stored in the database; retrieves those without a schema; null means that the schema name should not be used to narrow the search
@param table a table name; must match the table name as it is stored in the database
@param info a proposed list of tag/value pairs that will be sent on connect open @return an array of DriverPropertyInfo objects describing possible properties. This array may be an empty array if no properties are required.
@param catalog a catalog name; must match the catalog name as it is stored in the database; retrieves those without a catalog; null means that the catalog name should not be used to narrow the search
@param schemaPattern a schema name pattern; must match the schema name as it is stored in the database; retrieves those without a schema; null means that the schema name should not be used to narrow the search
@param functionNamePattern a function name pattern; must match the function name as it is stored in the database
@param catalog a catalog name; must match the catalog name as it is stored in the database; retrieves those without a catalog; null means that the catalog name should not be used to narrow the search
@param schema a schema name; must match the schema name as it is stored in the database; retrieves those without a schema; null means that the schema name should not be used to narrow the search
@param table a table name; must match the table name as it is stored in the database
@param catalog a catalog name; must match the catalog name as it is stored in this database; retrieves those without a catalog; null means that the catalog name should not be used to narrow the search
@param schema a schema name; must match the schema name as it is stored in this database; retrieves those without a schema; null means that the schema name should not be used to narrow the search
@param table a table name; must match the table name as it is stored in this database
@param catalog a catalog name; must match the catalog name as it is stored in the database; retrieves those without a catalog; null means that the catalog name should not be used to narrow the search
@param schemaPattern a schema name pattern; must match the schema name as it is stored in the database; retrieves those without a schema; null means that the schema name should not be used to narrow the search
@param tableNamePattern a table name pattern; must match the table name as it is stored in the database
@param columnNamePattern a column name pattern; must match the column name as it is stored in the database
@param catalog a catalog name; must match the catalog name as it is stored in the database; retrieves those without a catalog; null means that the catalog name should not be used to narrow the search
@param schemaPattern a schema name pattern; must match the schema name as it is stored in the database; retrieves those without a schema; null means that the schema name should not be used to narrow the search
@param typeNamePattern a type name pattern; must match the type name as it is stored in the database
@param attributeNamePattern an attribute name pattern; must match the attribute name as it is declared in the database
@param catalog a catalog name; must match the catalog name as it is stored in the database; retrieves those without a catalog; null means that the catalog name should not be used to narrow the search
@param schema a schema name; must match the schema name as it is stored in the database; retrieves those without a schema; null means that the schema name should not be used to narrow the search
@param table a table name; must match the table name as it is stored in the database
@param chain an array of Certificates representing the certificate chain. The chain must be ordered and contain a Certificate at index 0 corresponding to the private key.
The range must be sorted into ascending order according to the specified comparator (as by the {@link #sort(Object[], int, int, Comparator) sort(T[], int, int, Comparator)} method) prior to making this call
The array must be sorted (as by the {@link #sort(short[])} method) prior to making this call
@param b The bytes that make up the class data. The bytes in positions off through off+len-1 should have the format of a valid class file as defined by the Java Virtual Machine Specification.
Otherwise, the specified collection must contain at least one element (in order to determine the new enum set's element type)
@param catalog a catalog name; must match the catalog name as it is stored in the database; retrieves those without a catalog; null means that the catalog name should not be used to narrow the search
@param schemaPattern a schema pattern name; must match the schema name as it is stored in the database; retrieves those without a schema; null means that the schema name should not be used to narrow the search
@param typeNamePattern a type name pattern; must match the type name as it is stored in the database; may be a fully qualified name
@param catalog a catalog name; must match the catalog name as it is stored in the database; retrieves those without a catalog; null means that the catalog name should not be used to narrow the search
@param schemaPattern a schema name pattern; must match the schema name as it is stored in the database; retrieves those without a schema; null means that the schema name should not be used to narrow the search
@param functionNamePattern a procedure name pattern; must match the function name as it is stored in the database
@param columnNamePattern a parameter name pattern; must match the parameter or column name as it is stored in the database
@param catalog a catalog name; must match the catalog name as it is stored in this database; retrieves those without a catalog; null means that the catalog name should not be used to narrow the search
@param schema a schema name; must match the schema name as it is stored in the database; retrieves those without a schema; null means that the schema name should not be used to narrow the search
@param table a table name; must match the table name as it is stored in this database
The array must be sorted (as by the {@link #sort(int[])} method) prior to making this call
The range must be sorted (as by the {@link #sort(long[], int, int)} method) prior to making this call
Clients should normally use the predefined Level constants such as Level.SEVERE.
@param map the map to transform, must not be null, typically empty
@param caller the principal invoking this method. It must be an owner of this ACL.
@param limits contains the top value that you want parsed with that format,and should be in ascending sorted order.
@param caller the principal invoking this method. It must be an owner of this ACL.
The array must be sorted (as by the {@link #sort(char[])} method) prior to making this call
The certificates supplied must be of a type supported by the CertificateFactory
The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns.
Fixed-delay execution is appropriate for recurring activities that require smoothness. In other words, it is appropriate for activities where it is more important to keep the frequency accurate in the short run than in the long run.
Fixed-delay execution is appropriate for recurring activities that require smoothness. In other words, it is appropriate for activities where it is more important to keep the frequency accurate in the short run than in the lon
The value objects in a WeakHashMap are held by ordinary strong references. Thus care should be taken to ensure that value objects do not strongly refer to their own keys, either directly or indirectly, since that will prevent the keys from being discarded.
The doit field of the PageChangingEvent must be set to false to prevent the page from changing.
@param sortOrder new sort order. The comparator must be able to support being used in a background thread.
@param hyperlinkDetectors the array of hyperlink detectors, must not be empty
@param originalDevice must be the same Device that was passed into the font's constructor when it was first created.
Content provider that performs sorting and filtering in a background thread. Requires a TableViewer created with the SWT.VIRTUAL flag and an IConcurrentModel as input.
This implementation of IRunnableContext#run(boolean, boolean, IRunnableWithProgress) blocks until the runnable has been run, regardless of the value of fork. It is recommended that fork is set to true in most cases. If fork is set to false, the runnable will run in the UI thread and it is the runnable's responsibility to call Display.readAndDispatch() to ensure UI responsiveness.
This implementation of IRunnableContext#run(boolean, boolean, IRunnableWithProgress) blocks until the runnable has been run, regardless of the value of fork. It is recommended that fork is set to true in most cases. If fork is set to false, the runnable will run in the UI thread and it is the runnable's responsibility to call Display.readAndDispatch() to ensure UI responsiveness.
Note that this method assumes GridData for the layout data of the rightControl
If the token's data is not null and a string it is assumed that it is the encoded content type.
Be aware of the fact that you should at least position the tool tip 1px right to your mouse cursor else click events may not get propagated properly.
In the event of an error, a default image is returned if returnMissingImageOnError is true, otherwise null is returned.Note: Even if returnMissingImageOnError is true, it is still possible for this method to return null in extreme cases, for example if SWT runs out of image handles.
In the even of an error, a default image is returned if returnMissingImageOnError is true, otherwise null is returned.
Otherwise, if any of the following is true, an ArrayStoreException is thrown and the destination is not modified: The src argument refers to an object that is not an array. The dest argument refers to an object that is not an array. The src argument and dest argument refer to arrays whose component types are different primitive types. The src argument refers to an array with a primitive component type and the dest argument refers to an array with a reference component type. The src argument refers to an array with a reference component type and the dest argument refers to an array with a primitive component type. Otherwise, if any of the following is true, an IndexOutOfBoundsException is thrown and the destination is not modified: The srcPos argument is negative. The destPos argument is negative. The length argument is negative. srcPos+length is greater than src.length, the length of the source array. destPos+length is greater than dest.length, the length of the destination array. Because of the restrictions already itemized, this paragraph effectively applies only to the situation where both arrays have component types that are reference types.
@param arg the acquire argument. This value is always the one passed to an acquire method, or is the value saved on entry to a condition wait. The value is otherwise uninterpreted and can represent anything you like.
The input array is assumed to be in big-endian byte-order: the most significant byte is in the zeroth element.
Note that the parent's layout is assumed to be a GridLayout and the number of columns in this layout is incremented.
The default implementation of this framework method assumes that widget.getData() returns the element corresponding to the node.
The annotation hover provides the information to be displayed in a hover popup window if requested over the annotation presentation area. The annotation hover is assumed to be line oriented.
The parent composite is assumed to use GridLayout as its layout manager, since the parent is typically the composite created in {@link Dialog#createDialogArea}.
If there is a marked position in the input stream, then buf[markpos] is the first byte to be supplied as input after a reset operation.
If the class name is misspelled, it will typically result in a compile-time error.
If the token's data is not null and a text attribute it is assumed that it is the encoded text attribute.
The scanner is assumed to return only token that carry text attributes.
The annotation hover is assumed to be line oriented.
@param timeout This parameter is ignored as the method never blocks
@param unit This parameter is ignored as the method never blocks
The constructors of this class assume that the default character encoding and the default byte-buffer size are appropriate.
@param principal the principal, assumed to be a valid authenticated Principal.
Clients must not implement this interface and must not extend.
Clients may neither instantiate this class nor extend.
Clients may neither instantiate nor extend this class.
Clients are not permitted to extend this class.
Clients are not permitted to extend this class.
Clients are not permitted to extend this class.
Clients may instantiate this class, but must not extend.
Clients may implement, but must not extend.
Clients may instantiate this class, but must not extend.
Clients may implement this interface, but must not extend.
Do not subclass.
This class is not intended to be called or extended by any external clients.
This class is not intended to be subclassed.
it is not intended to be subclassed.
it is not intended to be subclassed outside the framework.
@noextend This class is not intended to be subclassed by clients.
Note: this class is not intended to be subclassed by clients.
@noextend This class is not intended to be subclassed by clients.
@noextend This class is not intended to be subclassed by clients.
@noextend This class is not intended to be subclassed by clients.
This class is not intended to be subclassed.
It is not intended to be subclassed by clients.
it is not intended to be subclassed.
This class is not intended to be subclassed.
@noextend This class is not intended to be subclassed by clients.
@noextend This class is not intended to be subclassed by clients.
@noextend This class is not intended to be subclassed by clients.
@noextend This class is not intended to be subclassed by clients.
@noextend This class is not intended to be subclassed by clients.
@noextend This class is not intended to be subclassed by clients.
@noextend This class is not intended to be subclassed by clients.
@noextend This class is not intended to be subclassed by clients.
@noextend This class is not intended to be subclassed by clients.
@noextend This class is not intended to be subclassed by clients.
@noextend This class is not intended to be subclassed by clients.
@noextend This class is not intended to be subclassed by clients.
This class is neither intended to be instantiated nor subclassed.
This class is not intended to be subclassed.
This class is not intended to be subclassed.
@noextend This class is not intended to be subclassed by clients.
This class is not intended to be subclassed.
This class is not intended to be subclassed.
Not intended to be implemented by clients.
@noextend This class is not intended to be subclassed by clients.
@noextend This class is not intended to be subclassed by clients.
This class is not intended to be subclassed outside the viewer framework.
Not intended to be subclassed.
it is not intended to be subclassed.
This class is not intended to be subclassed.
@noextend This class is not intended to be subclassed by clients.
@noextend This class is not intended to be subclassed by clients.
This class is not intended to be subclassed.
@noextend This class is not intended to be subclassed by clients.
@noextend This class is not intended to be subclassed by clients.
This class is not intended to be subclassed outside of the JFace viewers framework.
@noextend This class is not intended to be subclassed by clients.
@noextend This class is not intended to be subclassed by clients.
@noextend This class is not intended to be subclassed by clients.
@noextend This class is not intended to be subclassed by clients.
@noextend This class is not intended to be subclassed by clients.
@noextend This class is not intended to be subclassed by clients.
@noextend This class is not intended to be subclassed by clients.
@noextend This class is not intended to be subclassed by clients.
@noextend This class is not intended to be subclassed by clients.
@noextend This class is not intended to be subclassed by clients.
@noextend This class is not intended to be subclassed by clients.
@noextend This class is not intended to be subclassed by clients.
This class is not intended to be extended by clients.
This class is not intended to be extended by clients.
This class is not intended to be extended by clients.
This interface should not be implemented or extended by clients.
This class is not intended to be extended by clients.
@noextend This interface is not intended to be extended by clients.
@noimplement This interface is not intended to be implemented by clients.
@noimplement This interface is not intended to be implemented by clients
@noextend This interface is not intended to be extended by clients.
This interface is internal to the framework; it should not be implemented outside the framework.
This interface is internal to the framework; it should not be implemented outside the framework.
This interface is not intended to be implemented by clients
@noimplement This interface is not intended to be implemented by clients.
This interface should never be directly implemented.
Because reference objects are implemented in close cooperation with the garbage collector, this class may not be subclassed directly.
Clients may extend this class
Clients may extend this class.
Clients may extend this class.
Clients may instantiate or extend this class.
Clients can also extend it in their own subclass.
Implementors can extend
Clients may implement or extend this class.
Clients may instantiate or extend this interface.
Clients may instantiate and extend this class.
Clients may subclass.
Clients should subclass this class instead of implementing IConcurrentModel directly.
Clients may subclass.
Clients may subclass.
It is recommended that implementations of IKeyFormatter subclass from here, rather than implementing IKeyFormatter directly.
It is recommended to subclass this class instead of Dialog in all cases except where the dialog should never show a tray.
For example, dialogs which are very short, simple, and quick to dismiss (e.g. a message dialog with an OK button) should subclass Dialog.
Clients can subclass to provide additional proposals in case they are supported by their own find/replace mechanism.
if the programmer desires thread-local variables to have an initial value other than null, ThreadLocal must be subclassed, and this method overridden.
it may also be subclassed
it may also be subclassed if a more sophisticated layout is required.
it may also be subclassed.
{@link CoolBarManager}, which clients may instantiate or subclass.
it may also be subclassed.
This dialog class may be subclassed.
This concrete dialog class can be further subclassed as required.
This concrete dialog class can be further subclassed as required.
This concrete dialog class can be further subclassed as required.
This class may besubclassed as required.
This class may be subclassed as required
Clients should subclass
Clients may subclass this class but should expect some breakage by future releases.
Clients are encouraged to subclass {@link AbstractInformationControl}, which does this for free.
Clients can implement this interface and its extension interfaces, subclass {@link AbstractInformationControl}, or use the (text-based) default implementation {@link DefaultInformationControl}.
Clients are encouraged to subclass {@link AbstractInformationControl}, which does this for free.
A remote object implementation should implement the Unreferenced interface to receive notification when there are no more clients that reference that remote object.
An implementation of this interface should be serializable and should implement {@link Object#equals} to return true when passed an instance that represents the same (functionally equivalent) client socket factory, and false otherwise (and it should also implement {@link Object#hashCode} consistently with its Object.equals implementation).
Subclasses must implement this IWizard method to perform any special finish processing for their wizard.
For providing the label's styles, create a subclass and overwrite {@link StyledCellLabelProvider#update(ViewerCell)} to return set all information needed to render a element.
This concrete class was designed to be instantiated, but may also be subclassed if required.
This class is intended to be subclassed by implementors.
This class may be used as is, or subclassed to provide richer labels.
This class can be subclassed to configure how the coloring of the selected cell.
This classes is intended to be subclassed
Clients may subclass WizardDialog, although this is rarely required.
This class is intended to be subclassed
Clients may implement this interface.
Clients may implement this interface and its extension interfaces
This class and all of its methods may be overridden or extended.
Clients may implement this interface.
This class provides some overridable methods to allow clients to manually control the popup.
This interface may be implemented by clients.
This interface may be implemented by clients.
Clients are expected to implement this interface in order to create a particular kind of control for decoration.
Clients are expected to implement this interface when defining a {@link ContentProposalAdapter}, in order to specify how to retrieve and set the contents of the control being adapted.
There are two ways to create a new thread of execution. One is to declare a class to be a subclass of Thread. This subclass should override the run method of class Thread.
The other way to create a thread is to declare a class that implements the Runnable interface. That class then implements the run method. An instance of the class can then be allocated, passed as an argument when creating Thread, and started.
The interface can be implemented by clients.
The interface can be implemented by clients.
The interface can be implemented by clients.
The interface can be implemented by clients.
This interface must be implemented by clients.
This interface can be implemented by clients.
Clients may implement this interface.
Clients may implement this interface.
This interface must be implemented by clients. Implementers should be registered with a content formatter in order get involved in the formatting process.
This interface must be implemented by clients. Implementers should be registered with a content formatter in order get involved in the formatting process.
The interface can be implemented by clients.
Clients may implement this interface.
Clients may implement this interface.
Clients may implement this interface.
Clients may implement this interface.
Clients may implement this interface.
Clients may implement this interface.
This interface can be implemented by clients.
This interface can be implemented by clients.
This interface can be implemented by clients.
The interface can be implemented by clients. By default, clients use {@link QuickAssistAssistant} as the standard implementer of this interface.
This interface must be implemented by clients. Implementers should be registered with a reconciler in order get involved in the reconciling process.
The interface can be implemented by clients. By default, clients use {@link org.eclipse.jface.text.reconciler.MonoReconciler} or {@link org.eclipse.jface.text.reconciler.Reconciler} as the standard implementers of this interface.
This interface must be implemented by clients.
This interface must be implemented by clients that want to let one of their model elements be part of a reconcile step result.
This interface must be implemented by clients that want to use one of their models as a reconcile step's input model.
The interface can be implemented by clients. By default, clients use {@link org.eclipse.jface.text.information.InformationPresenter} as the standard implementer of this interface.
This interface may be implemented by clients.
This interface may be implemented by clients.
This interface may be implemented by clients.
This interface may be implemented by clients.
Implement this method to draw a graphical representation of this annotation within the given bounds.
Clients may implement this interface.
Clients usually implement this interface and its extension interfaces.
Clients may implement this interface.
Clients may implement this interface.
Clients may implement this interface.
Clients may implement this interface.
Clients may implement and use this interface.
Clients may implement this interface.
Clients can implement that interface and its extension interfaces.
Clients may implement this interface.
Clients may implement this interface.
Clients can implement that interface and its extension interfaces.
Clients may implement this interface.
The interface can be implemented by clients.
The interface can be implemented by clients.
Clients must implement this interface in order to equip an information control manager accordingly.
Content providers for table tree viewers must implement the ITreeContentProvider interface.
Label providers for table tree viewers must implement either the ITableLabelProvider or the ILabelProvider interface (see TableTreeViewer.setLabelProvider for more details).
This interface should be implemented by classes that wish to act as cell modifiers.
This interface should be implemented by classes that wish to act as cell editor validators.
This interface should be implemented by classes that wish to react to cell editor activity.
An abstract implementation of a linked list which provides numerous points for subclasses to override.Overridable methods are provided to change the storage node and to change how nodes are added to and removed.
Key-value entries are stored in instances of the ReferenceEntry class which can be overridden and replaced.
An abstract implementation of a hash-based map which provides numerous points for subclasses to override.
Key-value entries are stored in instances of the HashEntry class, which can be overridden and replaced. The iterators can similarly be replaced, without the need to replace the KeySet, EntrySet and Values view classes.
Key-value entries are stored in instances of the LinkEntry class which can be overridden and replaced.
Applications implement subclasses of ClassLoader in order to extend the manner in which the Java virtual machine dynamically loads classes.
Such columns must implement the {@link org.eclipse.jface.text.source.IVerticalRulerColumn}. interface.
New DateFormatSymbols subclasses may be added to support SimpleDateFormat for date-time formatting for additional locales.
Subclasses may implement actions on top of BasicPermission, if desired.
A runtime exception for Provider exceptions (such as misconfiguration errors or unrecoverable internal errors), which may be subclassed by Providers to throw specialized, provider-specific runtime errors.
Subclasses may reimplement.
The subclass of ActivationGroup must override this method and unexport the object.
Subclasses may extend or override.
Clients may extend this method.
Subclasses may extend.
Subclasses may extend.
Subclasses may extend.
Subclasses may extend
Subclasses may extend.
Subclasses may extend.
Subclasses may extend.
Subclasses may extend
Subclasses may extend
Subclasses may extend
Subclasses may extend this method.
Subclasses may extend
Subclasses may extend
Subclasses may extend
Subclasses may extend.
Subclasses may extend.
Subclasses may extend.
Subclasses may extend.
Subclasses may extend this method
Subclasses may extend this method
Subclasses may extend this method.
Subclasses may extend
Subclasses may extend or reimplement.
Subclasses may extend
Subclasses may extend or reimplement.
Subclasses may extend.
Subclasses may extend or reimplement.
Subclassers may extend this method if required.
Subclasses may extend
Subclasses may extend
Subclasses may extend or reimplement.
Subclasses may extend or reimplement.
Subclasses may extend or reimplement.
Subclasses may extend or reimplement.
Subclasses may extend or reimplement.
Subclasses may extend it
Subclasses may extend or reimplement.
Subclasses must override this method
Subclasses may override
Subclasses may override to handle other buttons
Subclasses may override this method
Subclasses that require a different dialog area may either override this method
Subclasses should override this method
Subclasses may override
All pages should override this method
Subclasses must override this method
Subclasses may override.
Subclasses may override.
Subclasses may override.
Subclasses may override.
Subclasses may override.
Subclasses may override.
subclasses must override this method
subclasses must override this method
subclasses must override this method
A stream protocol handler for a protocol that has a different syntax must override this routine.
All CertStore implementations must include a class (the SPI class) that extends this class (CertStoreSpi)
Clients may extend this method.
Subclasses may extend.
Subclasses can override or extend.
Subclasses can override or extend.
Subclasses may reimplement or extend.
They should also extend {@link #computeTrim()} if they create a content area with additional trim (e.g. scrollbars)
They should override {@link #getInformationPresenterControlCreator()}.
Subclasses may replace or extend.
Subclasses must implement the createContents framework method to supply the page's main control.
Subclasses should extend the doComputeSize framework method to compute the size of the page's control.
Subclasses may replace or extend.
close- extend to free other SWT resources
configureShell- extend or reimplement to set shell properties before window opens
createContents- extend or reimplement to create controls before window opens
getInitialSize- reimplement to give the initial size for the shell
getInitialLocation- reimplement to give the initial location for the shell
getShellListener- extend or reimplement to receive shell events
handleFontChange- reimplement to respond to font changes
handleShellCloseEvent- extend or reimplement to handle shell closings
Subclasses may also extend or reimplement.
Subclasses may also extend or reimplement.
Subclasses may replace or extend.
Subclasses may replace or extend.
Subclasses may replace or extend.
reimplement createPageControls
reimplement performCancel
extend addPages
reimplement performFinish
extend dispose
Subclasses should extend this method if the wizard instance maintains addition SWT resource that need to be disposed.
Subclasses should extend if extra pages need to be added before the wizard opens.
Subclasses may override (extend or reimplement)
Subclasses may reimplement or extend.
Subclasses may reimplement or extend.
Subclasses can extend this method to add additional trim
Concrete subclasses must implement three methods: 1. format(Object obj, StringBuffer toAppendTo, FieldPosition pos) 2. formatToCharacterIterator(Object obj) 3. parseObject(String source, ParsePosition pos)
Subclasses may override if they need to add other control hooks
Applications use this class by overriding {@link #getPasswordAuthentication()} in a sub-class.
programmers should take note that any class that overrides the Object.equals method must also override the Object.hashCode method in order to satisfy the general contract for the Object.hashCodemethod
Subclasses may reimplement.
Subclasses may reimplement.
Clients may reimplement this method.
Subclasses may reimplement.
Clients may reimplement this method to create a canvas with their desired style bits.
Subclasses may reimplement this method.
Subclasses may implement the isSorterProperty method; they may reimplement the category method to provide categorization; and they may override the compare methods to provide a totally different way of sorting elements.
Subclasses should reimplement.
Subclasses may implement the isSorterProperty method; they may reimplement the category method to provide categorization; and they may override the compare methods to provide a totally different way of sorting elements.
Subclasses may reimplement this method to provide non-trivial categorization.
Subclasses may reimplement.
Subclasses may reimplement this method to provide a more optimized implementation.
Subclasses may reimplement.
Subclasses may reimplement this method to provide a more optimized implementation.
Subclasses may reimplement.
Subclasses may reimplement.
Subclasses may reimplement.
performHelp - may be reimplemented to display help for the page
canFlipToNextPage - may be extended or reimplemented
isPageComplete - may be extended
setDescription - may be extended
setTitle - may be extended
dispose - may be extended to dispose additional allocated SWT resources
Subclasses should reimplement this method if they want to delay creating one or more of the pages lazily.
Subclasses should reimplement this method if they need to perform any special cancel processing for their wizard.
To implement a modifiable map, the programmer must additionally override this class's put method (which otherwise throws an UnsupportedOperationException)
the iterator returned by entrySet().iterator() must additionally implement its remove method.
An applet should override this method to return an array of Strings describing these parameters.
Subclasses must implement createControl rather than overriding this method.
Subclasses must implement createControl rather than overriding this method.
Subclasses should override this method if they need information from the triggering event, or override run() if not.
Subclasses typically need not override this method, but may do so.
This method may be extended (super.close must be called).
Subclasses may override.
if the programmer desires thread-local variables to have an initial value other than null, ThreadLocal must be subclassed, and this method overridden.
Subclasses may override.
The createControl framework method must be implemented by concrete subclasses.
Subclasses may override if required.
This framework method must be implemented by concrete subclasses.
the changes are propagated to the control via the update method, which subclasses must implement.
Subclasses may override.
Subclasses may override.
Subclasses may override.
Subclasses may override.
Subclasses may override.
Subclasses may override.
Subclasses may override.
Subclasses may override.
Subclasses may override.
Subclasses should override to update their state.
Subclasses must implement the IAction.run method to carry out the action's semantics.
. Subclasses should override this method if they do not need information from the triggering event, or override runWithEvent(Event) if they do.
Subclasses may override.
This should be overridden by subclasses that add properties.
Subclasses may override.
Subclasses should override.
Subclasses may override this method to update additional buttons.
Subclasses may override this method.
Subclasses may override.
Subclasses may override.
Subclasses may override if a different control is desired for representing the title text, or if something different than the title should be displayed in location where the title text typically is shown.
Subclasses may override this method.
Subclasses may override this method.
Subclasses may override this method.
Subclasses may override this method.
Subclasses may override this method.
It provides framework hooks that allow subclasses to set the focus and tab order
Subclasses should override this method when they wish to persist the bounds of the dialog.
Subclasses should override this method when an alternate default size is desired, rather than overriding {@link #getInitialSize()}.
Subclasses should override this method when an alternate default location is desired, rather than overriding {@link #getInitialLocation(Point)}
Subclasses should override this method when there are bounds computations that must be checked each time the dialog is opened.
Subclasses may override.
Subclasses may override.
Subclasses may override this method, but typically do not.
Subclasses may override this method, but typically do not.
Subclasses may override.
Subclasses may override.
Subclasses may override.
Subclasses may override.
Subclasses may override.
Subclasses should override to take some action in response to a help request.
Subclasses may override if desired.
Subclasses may override.
Subclasses may override.
Subclasses may override.
Subclasses should override this method.
Subclasses should override this method.
Subclasses should override this method to specific state checks.
Subclasses may override but must call super.doFillIntoGrid.
Subclasses must implement this method to provide a corresponding new string for the text field.
Subclasses may override the performOk, performApply, performDefaults, performCancel, and performHelp framework methods to react to the standard button events.
Subclasses should override this method to contribute buttons to this page's button bar.
This framework method must be implemented by concrete subclasses.
Subclasses may override if they wish to set the font themselves.
This is a framework hook method for subclasses to return a page-specific preference store.
This is a framework hook method for subclasses to do special things when the Cancel button has been pressed.
Subclasses may override.
Subclasses must implement the parseString, createList, and getNewInputObject framework methods.
Subclasses must implement this method.
Subclasses must implement this method.
Subclasses must implement this method.
Subclasses must implement the createFieldEditors method and should override createLayout if a special layout of the field editors is needed.
Subclass must implement this method to create the field editors.
Subclasses must implement this method to adjust the horizontal span of controls so they appear correct in the given number of columns.
Subclasses should override this method if they want to change the font of the SWT control to a value different than the standard dialog font.
Subclasses must implement this method to create the controls for this field editor.
Subclasses must implement this method to properly initialize the field editor.
Subclasses must implement this method to properly initialize the field editor.
Subclasses must implement this method to save the entered value into the preference store.
Subclasses wishing to perform validation should override both this method and refreshValidState.
Subclasses wishing to perform validation should override both this method and isValid.
Subclasses must implement the getSize and fill methods.
Subclasses must implement this framework method
Subclasses must implement this framework method.
Usually, subclasses use this hook to inform all their reconciling strategies about the change.
Hook for subclasses which want to perform some action as soon as reconciliation is needed.
Subclasses should replace - the default implementation returns the empty string.
May be extended by subclasses.
May be extended by subclasses.
May be extended by subclasses.
May be extended by subclasses.
May be extended by subclasses.
May be extended or replaced by subclasses.
May be replaced or extended by subclasses.
May be replaced or extended by subclasses.
May be replaced or extended by subclasses.
May be extended by subclasses.
May be replaced or extended by subclasses.
May be replaced or extended by subclasses.
May be replaced or extended by subclasses.
May be replaced or extended by subclasses.
May be extended by subclasses.
May be extended by subclasses.
Subclasses may override this method.
Subclasses may override this method if they need extra space on the line number ruler.
May be overridden by subclasses.
subclasses may override to specify a number of spaces.
Hook method to formats the given messages.Subclasses can change this to create a different format like HTML.
Hook method to format the given single message.Subclasses can change this to create a different format like HTML.
Subclasses can hook into the paint loop at three levels: * Override {@link #paint(GC, ILineRange)} to control the entire painting of the ruler. * Override {@link #paintLine(GC, int, int, int, int)} to control the painting of a line. * Leave the painting to the default implementation, but override {@link #computeBackground(int)}, {@link #computeForeground(int)} and {@link #computeText(int)} to specify the ruler appearance for a line.
Subclasses need to provide implementations for {@link #getTemplates(String)}, {@link #getContextType(ITextViewer, IRegion)} and {@link #getImage(Template)}.
Subclasses may replace this method to provide their own implementations.
Subclasses may override.
Subclasses may override.
Subclasses must either override {@link IInformationControl#setInformation(String)} or implement {@link IInformationControlExtension2}.
Subclasses should override the default implementation, which returns null.
Subclasses should override this method and return the permission that best represents the permission required to make a a connection to the URL.
This method should be overridden by a subclass.
This interface is implemented by: SocketImpl and DatagramSocketImpl. Subclasses of these should override the methods of this interface in order to support their own options.
An implementation of this interface should implement {@link Object#equals} to return true when passed an instance that represents the same (functionally equivalent) server socket factory, and false otherwise (and it should also implement {@link Object#hashCode} consistently with its Object.equals implementation).
An implementation of this interface should be serializable and should implement {@link Object#equals} to return true when passed an instance that represents the same (functionally equivalent) client socket factory, and false otherwise (and it should also implement {@link Object#hashCode} consistently with its Object.equals implementation).
Subclasses should override this method.
Subclasses that intend to support efficient single-character output should override this method.
Subclasses of FilterWriter should override some of these methods
Subclasses of FilterReader should override some of these methods
Subclasses that intend to support efficient single-character input should override this method.
Subclasses of FilterOutputStream should provide a more efficient implementation of this method.
The corresponding method in ObjectInputStream, readClassDescriptor, should then be overridden to reconstitute the class descriptor from its custom stream representation.
This method should be overridden by subclasses.
Subclasses of Thread should override this method. @see #start() @see #stop() @see #Thread(ThreadGroup, Runnable, String)
Applications that want a stricter policy should override this method.
. This should be overridden by a specific security manager to return the appropriate thread group.
Subclasses may override these methods if required:
Subclasses may override this method to customize the cool bar manager.
Subclasses may override this method to customize the tool bar manager.
Subclasses may override to use a different registry, etc.
Subclasses may override this method to customize the tool bar manager.
Subclasses may override this method to customize the cool bar manager.
Subclasses may override this method to provide an alternative implementation for the cool bar manager.
Subclasses may override this method to customize the cool bar manager.
Subclasses may override this method to provide an alternative implementation for the tool bar manager.
Subclasses may override this method to customize the tool bar manager.
Subclasses may override this method to customize the menu manager.
Subclasses may override this method to customize the status line manager.
To customize the text Subclasses may override the following methods * {@link #getStyle(Event)} * {@link #getBackgroundColor(Event)} * {@link #getForegroundColor(Event)} * {@link #getFont(Event)} * {@link #getImage(Event)} * {@link #getText(Event)} * {@link #getBackgroundImage(Event)}
Subclasses may override to clean up requested system resources
Subclasses should override configureShell if the shell needs to be customized.
Subclasses may override.
Subclasses that change the layout type by overriding this method should also override createContents.
Subclasses may overwrite to implement custom positioning.
This framework method must be implemented by concrete subclasses.
This framework method must be implemented by concrete subclasses.
This framework method must be implemented by concrete subclasses.
This framework method must be implemented by concrete subclasses.
Implementators of {@link ColumnViewer} should overwrite this method if their widget supports reordered columns
Implementators of {@link ColumnViewer} should overwrite this method if their widget supports reordered columns
Implementators of {@link ColumnViewer} should overwrite this method if their widget supports reordered columns
For providing the label's styles, create a subclass and overwrite {@link StyledCellLabelProvider#update(ViewerCell)} to return set all information needed to render a element.
Subclasses should overwrite.
Subclasses may overwrite to implement their custom logic to edit the next cell
Subclasses should overwrite this method, which has a default implementation (returning 0) for API backwards compatility reasons
Subclasses may overwrite this to get custom behavior
The network class loader subclass must define the methods {@link #findClass findClass} and loadClassData to load a class from the network.
All subclasses which maintain state must support and override this method, if necessary.
This must be implemented by subclasses of Permission, as they are the only ones that can impose semantics on a Permission object.
A stateful implementation must override the {@link #clone clone} method if necessary in order to allow a PKIX CertPathBuilder to efficiently backtrack and try other paths.
An important method that must be implemented by each subclass is the implies method to compare Permissions.
When it is desirable to group together a number of Permission objects of the same type, the newPermissionCollection method on that particular type of Permission object should first be called. The default behavior (from the Permission class) is to simply return null. Subclasses of class Permission override the method if they need to store their permissions in a particular PermissionCollection object in order to provide the correct semantics when the PermissionCollection.implies method is called. If a non-null value is returned, that PermissionCollection must be used. If null is returned, then the caller of newPermissionCollection is free to store permissions of the given type in any PermissionCollection they choose (one that uses a Hashtable, one that uses a Vector, etc).
Subclasses which handle different rounding modes should override this method.
Subclasses which handle different rounding modes should override this method.
Subclasses that support fields should override this and create an AttributedCharacterIterator with meaningful attributes.
This method should be overridden if a refresh operation is supported by the policy implementation.
This method should be overridden if a refresh operation is supported by the policy implementation.
This method should be overriden by subclasses to test for equality.
Subclasses that wish to support indirect CRLs should override it.
The management of a signer's private keys is an important and sensitive issue that should be handled by subclasses as appropriate to their intended use.
Knowledgeable providers should override this method.
Subclasses that wish to support indirect CRLs should override this method.
Subclasses should overwrite the default implementation
Subclasses of class Permission should override this if they need to store their permissions in a particular PermissionCollection object in order to provide the correct semantics when the PermissionCollection.implies method is called.
Otherwise, it calls {@link #identityEquals(Identity) identityEquals}, which subclasses should override.
Knowledgeable providers should override this method.
Subclasses should override this method with a correct implementation.
Subclasses should override this method with a correct implementation.
Subclasses should override this method with a correct implementation.
Subclasses may override
Subclasses must implement the select method and may implement the isFilterProperty method.
Subclasses must implement the following methods: * validateDrop - identifies valid drop targets in viewer * performDrop - carries out a drop into a viewer
Subclasses must implement this method to provide drop behavior.
Subclasses must implement this method to define which drops make sense.
Subclasses may override
. Subclasses may override.
Subclasses may override.
Subclasses may override any of the following methods: * isLabelProperty * getImage * getText * dispose
This framework method must be implemented by concrete subclasses.
Subclasses may override the following methods: * createButton: creates the cell editor's button control * createContents: creates the cell editor's 'display value' control * updateContents: updates the cell editor's 'display value' control after its value has changed * openDialogBox: opens the dialog box when the end user presses the button
Subclasses may override it to implement a different strategy for picking a new selection when the old selection becomes invalid.
Subclasses should override to set their selection based on the given list of elements.
Subclasses can overload this method to implement their own tool tip design.
Subclasses may override.
To be implemented by subclasses.
Subclasses should override.
Subclasses may override
Subclasses may override
Subclasses may override
Subclasses may override
Subclasses may override
Subclasses may override
Subclasses may override
Subclasses may override
Subclasses may override
Subclasses may override
Subclasses may override
Subclasses may override
Subclasses may override
Subclasses may override
Subclasses may override
Subclasses may override
Subclasses that hook their own focus listener should override this method and return false.
Subclasses may override.
Subclasses should override.
Overriding this method is generally not required; however, if overriding in a subclass, super.setLabelProvider must be invoked.
Overriding this method is generally not required; however, if overriding in a subclass, super.setContentProvider must be invoked.
Subclasses should override this method to perform any additional cleanup of resources;
Overriding this method is generally not required; however, if overriding in a subclass, super.getLabelProvider must be invoked.
Subclasses may override.
Overriding this method is generally not required; however, if overriding in a subclass, super.updateSelection must be invoked.
Subclasses that hook their own focus listener should override this method and return false.
Subclasses may override.
Subclasses must implement this method.
Subclassers may override this method to do something when a viewer's input is set.
Subclasses may override.
An enum type should override this method when a more programmer-friendly string form exists.
Class loader implementations should override this method to specify where to find resources.
lass loader implementations should override this method to specify where to load resources from.
If you override this method, then you should make a call to super.checkSecurityAccess at the point the overridden method would normally throw an exception.
Applications that want a stricter policy should override this method.
This method merely returns its input argument, and should be overridden if a different behavior is desired.
This method should be overridden by class loader implementations that follow the delegation model for loading classes, and will be invoked by the {@link #loadClass loadClass} method after checking the parent class loader for the requested class.
This framework method may be extended (super.close must be called).
This class and all of its methods may be overridden or extended.
clients should overwrite {@link #apply(ITextViewer, char, int, int)} instead
clients should overwrite {@link #apply(ITextViewer, char, int, int)}
Override this method to provide your own object used to handle progress.
Override if you need a different strategy.
Clients are expected to override the creation of the main dialog area, and may optionally override the creation of the title area and info area in order to add content.
Clients should override to introduce specific tab ordering.
Subclasses typically need not override this method, but may extend it (calling super.saveDialogBounds if additional bounds information should be stored.
Sublcasses may override.
Implementors must either use the dialog font or override {@link #computeSizeConstraints(int, int)}.
Clients can override.
Override if the root element is different from the viewer's input element.
Subclasses should override this method rather than {@link #focusCellChanged(ViewerCell)}
Clients can override.
Clients may override, in particular, clients can return 0 to denote that two subsequent mouse clicks in a cell should not be interpreted as a double click.
Note that the default implementation is not very efficient and should be overridden if this class is implemented.
It may be overridden if necessary.
There are two ways to create a new thread of execution. One is to declare a class to be a subclass of Thread. This subclass should override the run method of class Thread.
To implement a modifiable list, the programmer must additionally override the {@link #set(int, Object) set(int, E)} method (which otherwise throws an { UnsupportedOperationException}).
If the list is variable-size the programmer must additionally override the {@link #add(int, Object) add(int, E)} and {@link #remove(int)} methods.
Subclasses may want to override this behavior to remain consistent with the {@link Comparator#equals(Object)} contract.
Subclasses may want to override this behavior to remain consistent with the {@link Comparator#equals(Object)} contract.
Subclasses may want to override this behavior to remain consistent with the {@link Comparator#equals(Object) equals} contract.
Override to validate the object being added to ensure it matches the predicate.
Override to validate the objects being added to ensure they match the predicate.
Subclasses can override this to match differently.
Subclasses can override this to record the change.
Subclasses can override this to create a different class.
Subclasses can override this to create a different class.
Subclasses can override this to record the change.
Override to transform the value when using setValue.
Subclasses can override this, for example to use the identityHashCode.
Subclasses may override if they have a specific field that must be present on read before this implementation will work.
Subclasses may override if the subclass has a specific field that must be present before put() or calculateThreshold() will work correctly.
Subclasses can override this to perform alternate key conversions.
Subclasses can override this to return alternate hash codes.
Subclasses can override this to match differently. @param key1 the first key to compare passed in from outside
Subclasses can override this to match differently.
Subclasses can override this to return alternate bucketing
Subclasses could override to handle changes to the map.
Subclasses could override to fully control adds to the map.
Subclasses can override this to return a different storage class, or implement caching.
Subclasses could override to handle changes to the map.
Subclasses could override to fully control removals from the map.
Subclasses could override to handle changes to the map.
Subclasses can override this to implement caching (override clear as well).
Subclasses can override this to return iterators with different properties.
Subclasses can override this to return iterators with different properties.
Subclasses can override this to return iterators with different properties.
This method must be overridden if a subclass must be setup before put() is used.
This method must be overridden if a subclass must be setup before put() is used.
Subclasses may override if the subclass has a specific field that must be present before put() or calculateThreshold() will work correctly.
Subclasses may override if they have a specific field that must be present on read before this implementation will work.
Subclasses can override this to return iterators with different properties
Subclasses can override this to return iterators with different properties.
Subclasses can override this to return iterators with different properties.
This method can be overridden to perform your own processing instead of using the factory.
This can be overridden by subclasses to provide a different map implementation.
Override to validate an object set into the map via setValue.
This method exists for subclasses to override. A subclass may wish to provide cleanup of resources when an entry is removed.
however subclasses may override this.
Override to transform the value when using setValue.
Subclasses can override this to return iterators with different properties.
Subclasses can override this to return iterators with different properties.
Subclasses can override this to return iterators with different properties.
Override toList(Enumeration) for StringTokenizer as it implements Enumeration for the sake of backward compatibility.
Your subclasses must override two methods: handleGetObject and getKeys().
Implementors must override the nine abstract service-provider interface (SPI) methods:
Subclasses must override getContents and provide an array, where each item in the array is a pair of objects.
To implement a modifiable collection, the programmer must additionally override this class's add method (which otherwise throws an UnsupportedOperationException),
Subclasses should override this, as this is used by all other methods.
Other subclasses should also provide overrides of this function that do the right thing.
Subclasses should, if possible, override this with a more efficient implementation - in many cases, they can simply return getMinimum().
Subclasses should, if possible, override this with a more efficient implementation.
many implementations will override this method.
May be overidden by handlers for other protocols that have different requirements for equals().
May be overidden by handlers for other protocols that have different requirements for hashCode calculation.
Subclasses must define the protected methods that change this state, and which define what that state means in terms of this object being acquired or released.
A Queue implementation that extends this class must minimally define a method {@link Queue#offer} which does not permit insertion of null elements, along with methods {@link Queue#peek}, {@link Queue#poll}, {@link Collection#size}, and a {@link Collection#iterator} supporting {@link Iterator#remove}.
It is recommended that subclasses override this method.
It is recommended that subclasses override this method.
It is recommended that subclasses override this method.
Most implementations will probably choose to override this method for efficiency.
Classes for that connection type can override this method and short-circuit the parsing.
This can be overriden in a subclass.
This method is meant to be overidden by handlers with default port numbers.
It can be overriden in a subclass.
Subclasses may override this method to invoke completion callbacks or perform bookkeeping.
Subclasses are encouraged to provide a more efficient implementation of this method.
Many implementations will override this method for efficiency.
Subclasses are encouraged to override this method and provide a more efficient implementation.
Subclasses are encouraged to provide a more efficient implementation of this method.
Note: This default is incorrect but cannot be changed in order not to break any existing clients. Subclasses should overwrite this method and use {@link #getIndentPrefixesForTab(int)} if applicable.
Applications can override this method in subclasses of ThreadGroup to provide alternative handling of uncaught exceptions.
The class FilterInputStream itself simply overrides all methods of InputStream with versions that pass all requests to the contained input stream. Subclasses of FilterInputStream may further override some of these methods and may also provide additional methods and fields.
This method may be overridden, though it typically isn't necessary or desirable.
Typically, additional methods will be overridden as well.
The implementor may, at his discretion, override one or more of the concrete methods if the default implementation is unsatisfactory for any reason, such as performance.
Override this method in subclass implementations for faster handling.
Subclasses typically do not override method.
Clients may call this framework method, but should not override it.
Clients may call this framework method, but should not override it.
Clients may call this framework method, but should not override it.
Clients may call this framework method, but should not override it.
This method may only be called after initializeDialogUnits has been called.
Clients may call this framework method, but should not override it.
Clients may call this framework method, but should not override it.
Clients may call this framework method, but should not override it.
This method is not intended to be overridden by subclasses.
This method is not intended to be overridden by subclasses.
Clients should not override it.
Subclasses are not expected to override this method.
Subclasses are not expected to override this method.
Subclasses typically need not override this method,
This method is not intended to be overridden by subclasses.
Subclassers should call setShellStyle to change this value, rather than overriding this method.
Standard customers should not overwrite this method but {@link #getValue(Object)}
Standard customers should not overwrite this method but {@link #setValue(Object, Object)}
This method is not intended to be overridden by subclasses.
This method is not intended to be overridden by subclasses.
This method is not intended to be overridden by subclasses.
This method is not intended to be overridden by subclasses.
@nooverride This method is not intended to be re-implemented or extended by clients.
@nooverride This method is not intended to be re-implemented or extended by clients.
@nooverride This method is not intended to be re-implemented or extended by clients.
Clients should not override it.
Clients should not override it.
Clients should not override it.
Clients should not override it.
This method is not intended to be referenced or overridden by clients.
Do neither call nor override.
Note: This method is not intended to be referenced or overridden by clients.
This method is internal to the framework; it should not be implemented outside the framework.
This method is internal to the framework; it should not be implemented outside the framework.
Note: This method is not intended to be referenced or overridden by clients.
Subclasses may extend this IContributionManager method, but must call super.update
Subclassesmust call super.itemAdded
Subclasses must call super.itemRemoved
Subclasses should call the super implementation
Subclasses should always call super.getForegroundColorExclusions to aggregate the list.
Subclasses should always call super.getBackgroundColorExclusions to aggregate the list.
Subclasses must call the super implementation.
Subclasses must call the super implementationcall
Subclasses must call the super implementation.
Subclasses should call the super implementation (which at this time is empty but may be changed in the future)
Subclasses should call the super implementation
Subclasses should call super.buttonPressed if the default handling of the ok and cancel buttons is desired.
Subclasses should call super.performDefaults.
Subclasses should either call the super implementation or, alternatively, {@link #initialize(ColumnViewer, ViewerColumn, boolean)}
Subclasses should not call the super implementation.
f override this, be sure to call super.
Subclasses which override this method should make sure they call super
Subclasses call super.dispose
If you override this, be sure to call super.
All pages should call super.doComputeSize.
Code overriding this method should call super.removeNotify as the first line of the overriding method.
Any subclass of RequiredModelMBean overloading or overriding this method should call super.postDeregister()
Subclasses may wish to conditionally call super with a different location
Subclasses may wish to conditionally call super with a different location
applications that override this method should either call super.update(g) or incorporate the functionality described above into their own code
Any subclass of RequiredModelMBean overloading or overriding this method should call super.postRegister(registrationDone)
Any subclass of RequiredModelMBean overloading or overriding this method should call super.preDeregister()
Subclasses may call super as in the following example
Subclasses of Component that override this method need not call super.paint(g).
Applications that override this method need not call super.paint(g)
To conditionally drag from certain areas subclass mousePressed and call super when you wish the dragging to begin.
Subclasses of Component that override this method should either call super.update(g), or call paint(g) directly from their update method.
Any subclass of RequiredModelMBean overloading or overriding this method should call super.preRegister(server, name)
Subclasses can override or extend.
Subclasses can override or extend.
They should also extend {@link #computeTrim()} if they create a content area with additional trim (e.g. scrollbars)
Subclasses should extend the doComputeSize framework method to compute the size of the page's control.
close- extend to free other SWT resources
extend addPages
extend dispose
Subclasses should extend this method if the wizard instance maintains addition SWT resource that need to be disposed.
Subclasses should extend if extra pages need to be added before the wizard opens.
Subclasses can extend this method to add additional trim
if overriding in a subclass, super.getContentProvider must be invoked.
however, super.hookControl must be invoked.
super.setContentProvider must be invoked.
super.setLabelProvider must be invoked.
super.updateSelection must be invoked.
super.getLabelProvider must be invoked.
overriding methods must invoke super.handleDispose
isPageComplete - may be extended
setDescription - may be extended
setTitle - may be extended
dispose - may be extended to dispose additional allocated SWT resources
This method may be extended (super.close must be called).
If this method is overridden, then super.checkAccess should be called by the first statement in the overridden method, or the equivalent security check should be placed in the overridden method.
If you override this method, then you should make a call to super.checkSecurityAccess at the point the overridden method would normally throw an exception.
If you override this method, then you should make a call to super.checkCreateClassLoader at the point the overridden method would normally throw an exception.
If this method is overridden, then super.checkAccess should be called by the first statement in the overridden method, or the equivalent security check should be placed in the overridden method.
If you override this method, then you should make a call to super.checkPrintJobAccess at the point the overridden method would normally throw an exception.
If you override this method, then you should make a call to super.checkSystemClipboardAccess at the point the overridden method would normally throw an exception.
If you override this method, then you should make a call to super.checkAwtEventQueueAccess at the point the overridden method would normally throw an exception.
If you override this method, then you should make a call to super.checkTopLevelWindow at the point the overridden method would normally return false, and the value of super.checkTopLevelWindow should be returned.
If you override this method, then you should make a call to super.checkRead at the point the overridden method would normally throw an exception.
If you override this method, then you should make a call to super.checkRead at the point the overridden method would normally throw an exception.
If you override this method, then you should make a call to super.checkWrite at the point the overridden method would normally throw an exception.
If you override this method, then you should make a call to super.checkWrite at the point the overridden method would normally throw an exception.
If you override this method, then you should make a call to super.checkDelete at the point the overridden method would normally throw an exception
If you override this method, then you should make a call to super.checkListen at the point the overridden method would normally throw an exception.
If you override this method, then you should make a call to super.checkMulticast at the point the overridden method would normally throw an exception.
If you override this method, then you should make a call to super.checkPropertiesAccess at the point the overridden method would normally throw an exception.
This framework method may be extended (super.close must be called).
If you override this method, then you should make a call to super.checkExit at the point the overridden method would normally throw an exception. @param status the exit status.
Subclasses typically need not override this method, but may extend it (calling super.saveDialogBounds if additional bounds information should be stored.
If you override this method, then you should make a call to super.checkConnect at the point the overridden method would normally throw an exception.
If you override this method, then you should make a call to super.checkAccept at the point the overridden method would normally throw an exception.
If you override this method, then you should make a call to super.checkMulticast at the point the overridden method would normally throw an exception.
If you override this method, then you should make a call to super.checkPropertyAccess at the point the overridden method would normally throw an exception.
If this method is overridden, then super.checkPackageAccess should be called as the first line in the overridden method. @param pkg the package name.
If this method is overridden, then super.checkPackageDefinition should be called as the first line in the overridden method.
If you override this method, then you should make a call to super.checkSetFactory at the point the overridden method would normally throw an exception.
By convention, the returned object should be obtained by calling super.clone. If a class and all of its superclasses (except Object) obey this convention, it will be the case that x.clone().getClass() == x.getClass().
If you override this method, then you should make a call to super.checkConnect at the point the overridden method would normally throw an exception.
Note: To properly nest multiple overridings, subclasses should generally invoke super.terminated within this method.
To preserve functionality, any further overrides of these methods in subclasses must invoke superclass versions, which effectively disables additional task customization.
Note: To properly nest multiple overridings, subclasses should generally invoke super.beforeExecute at the end of this method.
Note: To properly nest multiple overridings, subclasses should generally invoke super.afterExecute at the beginning of this method.
Subclasses may override but must call super.doFillIntoGrid.
Subclasses may extend but must call the super implementation.
Subclasses may call super as in the following example:
This algorithm is implemented by this method. If it is overridden, the behavior specified here must be maintained.
If this method is overridden, then a call to super.checkMemberAccess cannot be made, as the default implementation of checkMemberAccess relies on the code being checked being at a stack depth of 4.
Subclasses must call this method at the end of their constructor(s)
A concrete subclass of this class must call this constructor when it is activated via the two parameter constructor described above
A concrete subclass of this class must call this constructor when it is activated via the two parameter constructor described above.
The field is initialized to false, but may be set to true by a subclass constructor (and should not be modified thereafter)
Subclasses of Component that override this method should either call super.update(g), or call paint(g) directly from their update method.
New pages should be added by calling addPage.
The message, image and title should be updated by the subclass, if desired
All subclasses must call this method when their control is first established.
Clients are expected to call {@link #createMessageArea(Composite)}, otherwise neither the icon nor the message will appear.
Clients are expected to call this method, otherwise neither the icon nor the message will appear.
Thus this method is really only useful for subclasses to call in their constructor. However, it has public visibility for backward compatibility.
For each button a subclass contributes, it must also increase the parent's grid layout number of columns by one; that is, ((GridLayout) parent.getLayout()).numColumns++);
Subclasses wishing a preference page without these buttons should call this framework method before the page's control has been created.
Subclasses should call getFieldEditorParent to obtain the parent control for each field editor.
Subclasses must implement this framework method to paint images within the given bounds using one or more calls to the drawImage framework method.
Subclasses need to call {@link #clearPositionCache()} after modifying the partitioner's positions.
Subclasses should overwrite this method and use {@link #getIndentPrefixesForTab(int)} if applicable.
When a proxy selector is registered, for instance, a subclass of URLConnection class should call the {@link #select select} method for each URL request so that the proxy selector can decide if a direct, or proxied connection should be used.
If a connection cannot be established to a proxy (PROXY or SOCKS) servers then the caller should call the proxy selector's {@link #connectFailed connectFailed} method to notify the proxy selector that the proxy server is unavailable.
The default implementation of this method should call getContent() and screen the return type for a match of the suggested types.
If this method is overridden, the method that overrides it should additionally check to see if the calling thread has the RuntimePermission(modifyThread) permission, and if so, return silently.
Subclasses may call the following methods to configure the wizard: * addPage * setHelpAvailable * setDefaultPageImageDescriptor * setDialogSettings * setNeedsProgressMonitor * setTitleBarColor * setWindowTitle
Subclasses may call the following methods to configure the wizard page: * setDescription * setErrorMessage * setImageDescriptor * setMessage * setPageComplete * setPreviousPage * setTitle
Subclasses that support fields should override this and create an AttributedCharacterIterator with meaningful attributes.
Subclasses are required to call {@link #create()} at the end of their constructor.
Subclasses are required to call {@link #create()} at the end of their constructor.
Subclasses are required to call {@link #create()} at the end of their constructor.
Subclasses should call this method on construction.
Subclasses MUST use try ...finally as follows to ensure that the busy flag is reset to its original value: boolean oldBusy = isBusy(); setBusy(true); try { 	// do work } finally { 	setBusy(oldBusy); }
It is recommended that this method be used by subclasses to determine whether the viewer is busy to return early from state-changing methods.
May be called from subclasses that override {@link #initialize(ColumnViewer, ViewerColumn)} but want to customize whether owner draw will be enabled.
If this method is overridden to do the actual refresh, then internalRefresh(Object element) should simply call internalRefresh(element, true).
If you override this method, then you should make a call to super.checkExec at the point the overridden method would normally throw an exception.
If you override this method, then you should make a call to super.checkLink at the point the overridden method would normally throw an exception.
If you override this method, then you should make a call to super.checkRead at the point the overridden method would normally throw an exception.
Likewise, {@link IInformationControl#addFocusListener(org.eclipse.swt.events.FocusListener)} should install listeners for {@link SWT#Activate} and {@link SWT#Deactivate} on the shell and forward events to the focus listeners.
Implementors should use the main font of the information control to do the characters-to-pixels conversion. This is typically the {@link JFaceResources#getDialogFont() dialog font}.
This method should be called by implementers of ILazyTreeContentProvider to populate this viewer.
Note that implementers need to ensure that getViewer().update(element, null) or similar methods are called, either directly or through some kind of listener mechanism on the implementer's model, to cause the new value to appear in the viewer.
Subclasses could populate additional entry fields.
This method should normally be invoked within an {@link AccessController#doPrivileged} action to create callables that will, if possible, execute under the selected permission settings holding within that action; or if not possible, throw an associated {@link AccessControlException}.
This method should normally be invoked within an {@link AccessController#doPrivileged} action to create callables that will, if possible, execute under the selected permission settings holding within that action; or if not possible, throw an associated {@link AccessControlException}.
The first serializable subclass must call this method from writeObject.
The first serializable subclass must call this method from readObject.
If this constructor is used by a serializable subclass then the init() method must be called.
In this case it is the responsibility of the subclass to save and restore the state of the non-serializable class.
The implementation of the method must follow this protocol: It must write each of the attributes of the SQL type to the given output stream. This is done by calling a method of the output stream to write each item, in the order that they appear in the SQL definition of the type. Specifically, it must call the appropriate SQLOutput writer method(s) (writeInt, writeString, and so on) to do the following: for a Distinct Type, write its single data element; for a Structured Type, write a value for each attribute of the SQL type.
A newly-loaded driver class should call the method registerDriver to make itself known to the DriverManager.
If the ThreadGroup object has no special requirements for dealing with the exception, it can forward the invocation to the {@linkplain #getDefaultUncaughtExceptionHandler default uncaught exception handler}.
Whenever a permission is added to a heterogeneous PermissionCollection such as Permissions, and the PermissionCollection doesn't yet contain a PermissionCollection of the specified permission's type, the PermissionCollection should call the newPermissionCollection method on the permission's class to see if it requires a special PermissionCollection.
Note that it is the responsibility of the implementor to dispose of SWT menus it creates.
At a minimum, the recovery operation must include closing the current connection and getting a new connection.
Implementors are responsible for ensuring that the created control can be accessed via getControl
When processing logging output, if a Handler encounters problems then rather than throwing an Exception back to the issuer of the logging call (who is unlikely to be interested) the Handler should call its associated ErrorManager.
Calls to the getAttribute and setAttribute methods must map to the get and put methods of the Bindings for the specified scope.
Implementation of this method must finish their computation by setting the computation results using setInformation.
Note: As of 3.4, you should only call this method if you want to override the {@link JFacePreferences#CONTENT_ASSIST_FOREGROUND_COLOR}.
Subclasses may call the noDefaultAndApplyButton framework method before the page's control has been created to suppress the standard Apply and Defaults buttons.
If the scale is reduced by the operation, the unscaled value must be divided (rather than multiplied), and the value may be changed; in this case, the specified rounding mode is applied to the division.
FilePermission objects must be stored in a manner that allows them to be inserted into the collection in any order
This method must not modify the parent's layout.
This method must not modify the parent's layout.
In other words, this method must allocate a new array
In other words, this method must allocate a new array
In other words, this method must allocate a new array
In other words, this method must allocate a new array
In other words, this method must allocate a new array
In other words, this method must allocate a new array
In other words, this method must allocate a new array
The general contract for the Object.equals method states that equals must be symmetric (in other words, a.equals(b) if and only if b.equals(a)).
In either case the implementation must ensure that the signal is redirected to another waiting thread, if there is one.
SocketPermission objects must be stored in a manner that allows them to be inserted into the collection in any orde
They therefore must either be parsed as such or treated as an error.
If the scale is reduced by the operation, the unscaled value must be divided (rather than multiplied), and the value may be changed
BasicPermission objects must be stored in a manner that allows them to be inserted in any order,
This option must be specified in the constructor.
The implementor must also ensure that the relation is transitive
Finally, the implementor must ensure that compare(x, y)==0 implies that sgn(compare(x, z))==sgn(compare(y, z)) for all z.
All execution methods in the Statement interface implicitly close a statment's current ResultSet object if an open one exists.
Instances of classes that implement this interface must implement an equals() method that equates any two instances that share the same generic type declaration and have equal type parameters.
A valid reduction polynomial is either a trinomial (X^m + X^k + 1 with m > k >= 1) or a pentanomial (X^m + X^k3 + X^k2 + X^k1 + 1 with m > k3 > k2 > k1 >= 1), so ks should have length 1 or 3.
Note: By definition, the execution of positioned updates and deletes must be done by a different Statement object than the one that generated the ResultSet object being used for positioning.
Creating a type variable must not cause the creation of its bounds. Repeated creation of a type variable has no effect.
However, all instances representing a type variable must be equal() to each other.
When a subclass is replacing objects it must insure that either a complementary substitution must be made during deserialization or that the substituted object is compatible with every field where the reference will be stored.
When a subclass is replacing objects it must insure that the substituted object is compatible with every field where the reference will be stored.
This map enforces the restriction that there is a 1:1 relation between keys and values, meaning that multiple keys cannot map to the same value. This is required so that inverting the map results in a map without duplicate keys.
The general contract of flush is that calling it is an indication that, if any bytes previously written have been buffered by the implementation of the output stream, such bytes should immediately be written to their intended destination.
The redefinition must not add, remove or rename fields or methods, change the signatures of methods, or change inheritance.
A JDBC driver must apply this limit to the execute, executeQuery and executeUpdate methods.
The additional stipulation on constructors is, not surprisingly, that all constructors must create a set that contains no duplicate elements (as defined above).
Implementations are encouraged to make regular use of Assert.isNotNull to ensure that null parameters are detected as early as possible.
Two hosts are considered equivalent if both host names can be resolved into the same IP addresses; else if either host name can't be resolved, the host names must be equal without regard to case; or both host names equal to null.
For two URIs to be considered equal requires that either both are opaque or both are hierarchical. Their schemes must either both be undefined or else be equal without regard to case. Their fragments must either both be undefined or else be equal. For two opaque URIs to be considered equal, their scheme-specific parts must be equal. For two hierarchical URIs to be considered equal, their paths must be equal and their queries must either both be undefined or else be equal. Their authorities must either both be undefined, or both be registry-based, or both be server-based. If their authorities are defined and are registry-based, then they must be equal. If their authorities are defined and are server-based, then their hosts must be equal without regard to case, their port numbers must be equal, and their user-information components must be equal.
The implementation of the method must follow this protocol: It must write each of the attributes of the SQL type to the given output stream. This is done by calling a method of the output stream to write each item, in the order that they appear in the SQL definition of the type. Specifically, it must call the appropriate SQLOutput writer method(s) (writeInt, writeString, and so on) to do the following: for a Distinct Type, write its single data element; for a Structured Type, write a value for each attribute of the SQL type.
Classes that require special handling during the serialization and deserialization process must implement special methods with these exact signatures
A serializable class can declare its own serialVersionUID explicitly by declaring a field named serialVersionUID that must be static, final, and of type long
The implementor must ensure sgn(x.compareTo(y)) == -sgn(y.compareTo(x)) for all x and y. (This implies that x.compareTo(y) must throw an exception iff y.compareTo(x) throws an exception.) The implementor must also ensure that the relation is transitive: (x.compareTo(y)>0 && y.compareTo(z)>0) implies x.compareTo(z)>0. Finally, the implementor must ensure that x.compareTo(y)==0 implies that sgn(x.compareTo(z)) == sgn(y.compareTo(z)), for all z.
If markpos is not -1, then all bytes from positions buf[markpos] through buf[pos-1] must remain in the buffer array
. Should only succeed once per remote call.
Calling disconnect() should not imply that this HttpURLConnection instance can be reused for other requests.
The implementation of the method must follow this protocol: * It must read each of the attributes or elements of the SQL type from the given input stream. This is done by calling a method of the input stream to read each item, in the order that they appear in the SQL definition of the type. * The method readSQL then assigns the data to appropriate fields or elements (of this or other objects). Specifically, it must call the appropriate reader method (SQLInput.readString, SQLInput.readBigDecimal, and so on) method(s) to do the following: for a distinct type, read its single data element; for a structured type, read a value for each attribute of the SQL type.
A PKIXCertPathChecker must support reverse checking and may support forward checking.
The general contract of hashCode is: * Whenever it is invoked on the same object more than once during an execution of a Java application, the hashCode method must consistently return the same integer, provided no information used in equals comparisons on the object is modified. This integer need not remain consistent from one execution of an application to another execution of the same application. * If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result. * It is not required that if two objects are unequal according to the {@link java.lang.Object#equals(java.lang.Object)} method, then calling the hashCode method on each of the two objects must produce distinct integer results. However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hashtables.
Marking a closed stream should not have any effect on the stream.
# codesource must not be null. # If this object's certificates are not null, then all of this object's certificates must be present in codesource's certificates. # If this object's location (getLocation()) is not null, then the following checks are made against this object's location and codesource's: 1. codesource's location must not be null. 2. If this object's location equals codesource's location, then return true. 3. This object's protocol (getLocation().getProtocol()) must be equal to codesource's protocol. 4. If this object's host (getLocation().getHost()) is not null, then the SocketPermission constructed with this object's host must imply the SocketPermission constructed with codesource's host. 5. If this object's port (getLocation().getPort()) is not equal to -1 (that is, if a port is specified), it must equal codesource's port. 6. If this object's file (getLocation().getFile()) doesn't equal codesource's file, then the following checks are made: If this object's file ends with /-, then codesource's file must start with this object's file (exclusive the trailing -). If this object's file ends with a /*, then codesource's file must start with this object's file and must not have any further / separators. If this object's file doesn't end with a /, then codesource's file must match this object's file with a '/' appended. 7. If this object's reference (getLocation().getRef()) is not null, it must equal codesource's reference.
Format subclasses that are aware of Field should give precedence to attribute and ignore fieldID if attribute is not null.
When a Driver class is loaded, it should create an instance of itself and register it with the DriverManager. This means that a user can load and register a driver by calling Class.forName(foo.bah.Driver)
The reliability of this method is important for the ability to use it to make security decisions, so its implementation should not just test if the class in question extends Proxy.
A Key should use KeyRep as its serialized representation.
@param input the object to be transformed, should be left unchanged
Implementations should seek to avoid creating a new object every time this method is called.
When you are searching or comparing text, you must ensure that these two sequences are treated as equivalent. In addition, you must handle characters with more than one accent.
@param classfileBuffer the input byte buffer in class file format - must not be modified
A PKIXCertPathChecker implementation must support reverse checking (the ability to perform its checks when it is presented with certificates in the reverse direction) and may support forward checking (the ability to perform its checks when it is presented with certificates in the forward direction).
For example, either the positive and negative prefixes or the suffixes must be distinct for DecimalFormat.parse() to be able to distinguish positive from negative values. (If they are identical, then DecimalFormat will behave as if no negative subpattern was specified.) Another example is that the decimal separator and thousands separator should be distinct characters, or parsing will be impossible.
The retransformation must not add, remove or rename fields or methods, change the signatures of methods, or change inheritance.
A certificate/CRL-using system (an application validating a certificate/CRL) must reject the certificate/CRL if it encounters a critical extension it does not recognize. A non-critical extension may be ignored if it is not recognized.
Regardless of whether these additional PKIXCertPathCheckers are set, a PKIX CertPathValidator or CertPathBuilder must perform all of the required PKIX checks on each certificate
According to the {@link Collection#remove(Object)} method, this method should only remove the first occurrence of the given object, not all occurrences.
This differs from {@link List#removeAll(Collection)} in that cardinality is respected; if list1 contains two occurrences of null and list2 only contains one occurrence, then the returned list will still contain one occurrence.
The driver stores the value specified in a suitable location in the database. For example in a special register, session parameter, or system table column. For efficiency the driver may defer setting the value in the database until the next time a statement is executed or prepared. Other than storing the client information in the appropriate place in the database, these methods shall not alter the behavior of the connection in anyway. The values supplied to these methods are used for accounting, diagnostics and debugging purposes only.The driver shall generate a warning if the client info name specified is not recognized by the driver.
Drivers are not required to support these properties however if the driver supports a client info property that can be described by one of the standard properties, the standard property name should be used.
The system class loader supports adding a JAR file to be searched if it implements a method named appendToClassPathForInstrumentation which takes a single parameter of type java.lang.String. The method is not required to have public access.
The agent should take care to ensure that the JAR does not contain any classes or resources other than those to be defined by the system class loader for the purpose of instrumentation. Failure to observe this warning could result in unexpected behaviour that is difficult to diagnose (see {@link #appendToBootstrapClassLoaderSearch appendToBootstrapClassLoaderSearch}.
If the required access and argument checks succeed and the instantiation will proceed, the constructor's declaring class is initialized if it has not already been initialized.
The driver shall submit a query on the connection or use some other mechanism that positively verifies the connection is still valid when this method is called.The query submitted by the driver to validate the connection shall be executed in the context of the current transaction.
The hashCode method of the returned set returns the sum of the identity hashcodes of the elements in the set, rather than the sum of their hashcodes. This is mandated by the change in the semantics of the equals method, in order to enforce the general contract of the Object.hashCode method among sets returned by this method.
It is strongly recommended, but not strictly required that (x.compareTo(y)==0) == (x.equals(y)).
Note that unlike the {@link StrictMath#copySign(float, float) StrictMath.copySign} method, this method does not require NaN sign arguments to be treated as positive values; implementations are permitted to treat some NaN arguments as positive and other NaN arguments as negative to allow greater performance.
Note that unlike the {@link StrictMath#copySign(double, double) StrictMath.copySign} method, this method does not require NaN sign arguments to be treated as positive values; implementations are permitted to treat some NaN arguments as positive and other NaN arguments as negative to allow greater performance.
Unlike some of the numeric methods of class StrictMath, all implementations of the equivalent functions of class Math are not defined to return the bit-for-bit same results. This relaxation permits better-performing implementations where strict reproducibility is not required.
Therefore, most methods with more than 0.5 ulp errors are required to be semi-monotonic: whenever the mathematical function is non-decreasing, so is the floating-point approximation, likewise, whenever the mathematical function is non-increasing, so is the floating-point approximation.
To help ensure portability of Java programs, the definitions of some of the numeric functions in this package require that they produce the same results as certain published algorithms. These algorithms are available from the well-known network library netlib as the package Freely Distributable Math Library
The description and choices are intialized to null and required is initialized to false.
This method simply informs the group's monitor that the object is inactive. It is up to the concrete subclass of ActivationGroup to fulfill the additional requirement of unexporting the object.
The returned parameters may be the same that were used to initialize this signature, or may contain a combination of default and randomly generated parameter values used by the underlying signature implementation if this signature requires algorithm parameters but was not initialized with any.
Two CodeSource objects are considered equal if their locations are of identical value and if their signer certificate chains are of identical value. It is not required that the certificate chains be in the same order.
The byte array will be in big-endian byte-order: the most significant byte is in the zeroth element. The array will contain the minimum number of bytes required to represent this BigInteger, including at least one sign bit, which is { (ceil((this.bitLength() + 1)/8))}.
If the identity has a public key, the public key in the certificate must be the same, and if the identity does not have a public key, the identity's public key is set to be that specified in the certificate.
The initial owner Principal should be specified as an argument to the constructor of the class implementing this interface.
Note that the ordering maintained by a sorted map (whether or not an explicit comparator is provided) must be consistent with equals if the sorted map is to correctly implement the Map interface.
All general-purpose sorted map implementation classes should provide four standard constructors:
The special value 0 instructs the packer to copy through the original JAR file directly, with no compression. The JSR 200 standard requires any unpacker to understand this special case as a pass-through of the entire archive.
Implementations may, but are not required to, throw this exception if fromElement or toElement cannot be compared to elements currently in the set
Implementations may, but are not required to, throw this exception if toElement cannot be compared to elements currently in the set. @throws NullPointerException if toElement is null and this set does not permit null elements
Implementations may, but are not required to, throw this exception if fromElement cannot be compared to elements currently in the set. @throws NullPointerException if fromElement is null and this set does not permit null elements
Implementations may, but are not required to, throw this exception if fromKey or toKey cannot be compared to keys currently in the map.
Implementations may, but are not required to, throw this exception if toKey cannot be compared to keys currently in the map.
Implementations may, but are not required to, throw this exception if fromKey cannot be compared to keys currently in the map
Implementations may, but are not required to, throw this exception if { fromElement} or { toElement} cannot be compared to elements currently in the set.
Implementations may, but are not required to, throw this exception if { toElement} cannot be compared to elements currently in the set.
Implementations may, but are not required to, throw this exception if { fromElement} cannot be compared to elements currently in the set.
Implementations may, but are not required to, throw this exception if { fromKey} or { toKey} cannot be compared to keys currently in the map.
Implementations may, but are not required to, throw this exception if { toKey} cannot be compared to keys currently in the map.
Implementations may, but are not required to, throw this exception if { fromKey} cannot be compared to keys currently in the map.
The hash code of a list is defined to be the result of the following calculation: int hashCode = 1; Iterator<E> i = list.iterator(); while (i.hasNext()) { E obj = i.next(); hashCode = 31*hashCode + (obj==null ? 0 : obj.hashCode()); } This ensures that list1.equals(list2) implies that list1.hashCode()==list2.hashCode() for any two lists, list1 and list2, as required by the general contract of {@link Object#hashCode}.
Subclasses of this class are encouraged, but not required, to attempt to read as many characters as possible in the same fashion.
Subclasses of this class are encouraged, but not required, to attempt to read as many bytes as possible in the same fashion.
If the protocol of this URL is jar, then the permission granted is based on the permission that is required by the URL of the Jar file.
Tray implementions must not set a layout on the parent composite, or assume a particular layout on the parent.
Note that the default uncaught exception handler should not usually defer to the thread's ThreadGroup object, as that could cause infinite recursion.
all of the methods and constructors in subclasses of this class must obey the additional constraints imposed by the Set interface
All general-purpose sorted set implementation classes should provide four standard constructors:
Implementations should use the font of the given drawable to calculate the size of the text to be presented.
The only requirement enforced by this facility is that provider classes must have a zero-argument constructor so that they can be instantiated during loading.
Implementations should seek to avoid creating a new object every time this method is called. See AbstractMap.values() etc. Calling this method on the inverse map should return the original.
The programmer should generally provide a void (no argument) and map constructor, as per the recommendation in the Map interface specification.
The only requirement enforced by this facility is that provider classes must have a zero-argument constructor so that they can be instantiated during loading.
In order to guarantee this property, particular algorithms are specified for the class { Random}. Java implementations must use all the algorithms shown here for the class { Random}, for the sake of absolute portability of Java code.
Further, those subclasses that might likely have a cause associated with them should have two more constructors, one that takes a Throwable (the cause), and one that takes a String (the detail message) and a Throwable (the cause).
Each class name must be for a Handler class which has a default constructor.
The equals method implements an equivalence relation on non-null object references: * It is reflexive: for any non-null reference value x, x.equals(x) should return true. * It is symmetric: for any non-null reference values x and y, x.equals(y) should return true if and only if y.equals(x) returns true. * It is transitive: for any non-null reference values x, y, and z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) should return true. * It is consistent: for any non-null reference values x and y, multiple invocations of x.equals(y) consistently return true or consistently return false, provided no information used in equals comparisons on the objects is modified. * For any non-null reference value x, x.equals(null) should return false.
If no such object exists, the map should be wrapped using the {@link Collections#synchronizedMap Collections.synchronizedMap} method.
All general-purpose Collection implementation classes (which typically implement Collection indirectly through one of its subinterfaces) should provide two standard constructors: a void (no arguments) constructor, which creates an empty collection, and a constructor with a single argument of type Collection, which creates a new collection with the same elements as its argument.
To implement clone(), a subclass must implement the Cloneable interface and make this method public.
All general-purpose map implementation classes should provide two standard constructors: a void (no arguments) constructor which creates an empty map, and a constructor with a single argument of type Map, which creates a new map with the same key-value mappings as its argument.
Implementations should seek to avoid creating a new object every time this method is called. See AbstractMap.values() etc. Calling this method on the inverse map should return the original.
This method must obey the general contract of {@link Object#equals(Object)}.
A single call to { add(int, E)} or { remove(int)} must add no more than one to this field, or the iterators (and list iterators) will throw bogus { ConcurrentModificationExceptions}.
The size of the collection can vary, but it can never exceed a preset maximum number of elements.
In that case the implementation must ensure that the signal is redirected to another waiting thread, if there is one.
If no such object exists, the map should be wrapped using the {@link Collections#synchronizedMap Collections.synchronizedMap} method.
If no such object exists, the map should be wrapped using the {@link Collections#synchronizedMap} method.
This method should query if the state of the object permits it to be acquired in the exclusive mode, and if so to acquire it.
If no such object exists, the list should be wrapped using the {@link Collections#synchronizedList Collections.synchronizedList} method.
This method should query if the state of the object permits it to be acquired in the shared mode, and if so to acquire it.
This method should query if the state of the object permits it to be acquired in the shared mode, and if so to acquire it.
If no such object exists, the map should be wrapped using the {@link Collections#synchronizedMap Collections.synchronizedMap} method.
Remove any members of the bag that are not in the given collection, respecting cardinality. That is, if the given collection coll contains n copies of a given object and the bag has m > n copies, then delete m - n copies from the bag. In addition, if e is an object in the bag but !coll.contains(e), then remove e and any of its copies.
It must also obey the interruption semantics as defined in this interface, to the extent that interruption of lock acquisition is supported: which is either totally, or only on method entry.
All { Lock} implementations must enforce the same memory synchronization semantics as provided by the built-in monitor lock, as described in The Java Language Specification, Third Edition (17.4 Memory Model)
A listener must set event.doit to false if it cannot handle the drag operation.
Two possibly null elements e1 and e2 are deeply equal if any of the following conditions hold: e1 and e2 are both arrays of object reference types, and Arrays.deepEquals(e1, e2) would return true e1 and e2 are arrays of the same primitive type, and the appropriate overloading of Arrays.equals(e1, e2) would return true. e1 == e2 e1.equals(e2) would return true. Note that this definition permits null elements at any depth.
This test must be fast and optimistic i.e. it is OK to return true even though there might be no quick fix.
This test must be fast and optimistic i.e. it is OK to return true even though there might be no quick fix.
While Deque implementations are not strictly required to prohibit the insertion of null elements, they are strongly encouraged to do so.
If the security property is not set, the provider is assumed to have alternative means for obtaining authentication information.
The view's { iterator} is a weakly consistent iterator that will never throw {@link ConcurrentModificationException}, and guarantees to traverse elements as they existed upon construction of the iterator, and may (but is not guaranteed to) reflect any modifications subsequent to construction.
The ACL Entries in each ACL observe the following rules: Each principal can have at most one positive ACL entry and one negative entry; that is, multiple positive or negative ACL entries are not allowed for any principal. Each entry specifies the set of permissions that are to be granted (if positive) or denied (if negative). If there is no entry for a particular principal, then the principal is considered to have a null (empty) permission set. If there is a positive entry that grants a principal a particular permission, and a negative entry that denies the principal the same permission, the result is as though the permission was never granted or denied. Individual permissions always override permissions of the group(s) to which the individual belongs. That is, individual negative permissions (specific denial of permissions) override the groups' positive permissions. And individual positive permissions override the groups' negative permissions.
Normally this means {@link #setQuickFixable(boolean)} has been called at least once but it can also be hard-coded, e.g. always return true.
Generic list algorithms are encouraged to check whether the given list is an instanceof this interface before applying an algorithm that would provide poor performance if it were applied to a sequential access list, and to alter their behavior if necessary to guarantee acceptable performance.
Note: Support for the rowDeleted method is optional with a result set concurrency of CONCUR_READ_ONLY
Assumes that all annotations are represented using the same height.
Every character inside the specified region is supposed to be visible in the viewer's widget after that call.
After this method has been finished, the reconciler is operational. I.e., it works without requesting further client actions until uninstall is called.
This set will not contain the element once the call returns
The readExternal method must read the values in the same sequence and with the same types as were written by writeExternal
Concrete subclasses of {@link ColumnViewer} should implement a matching concrete subclass of {@link ViewerColumn}.
Generally, a format's parseObject method must be able to parse any string formatted by its format method.
If you reimplement this method, you should also reimplement updateContents.
If you reimplement this method, you should also reimplement createContents.
This method must be symmetric with a call to {@link #save(IPreferenceStore, String)}.
This method must be symmetric with a call to {@link #load(IPreferenceStore, String)}.
For a class to be retransformed, {@link #isRetransformClassesSupported} must also be true. But the value of isRetransformClassesSupported() does not influence the value returned by this function. For a class to be redefined, {@link #isRedefineClassesSupported} must also be true. But the value of isRedefineClassesSupported() does not influence the value returned by this function.
For a given subclass of ObjectInputStream that overrides this method, the annotateProxyClass method in the corresponding subclass of ObjectOutputStream must write any data or objects read by this method
Multiple objects or primitives can be written to the stream. The objects must be read back from the corresponding ObjectInputstream with the same types and in the same order as they were written.
Subclasses wishing to perform validation should override both this method and refreshValidState.
Subclasses wishing to perform validation should override both this method and isValid.
An implementation of this interface should implement {@link Object#equals} to return true when passed an instance that represents the same (functionally equivalent) server socket factory, and false otherwise (and it should also implement {@link Object#hashCode} consistently with its Object.equals implementation).
The general contract for write(b) is that it should have exactly the same effect as the call write(b, 0, b.length).
Subclasses that change the layout type by overriding this method should also override createContents.
Note that it is generally necessary to override the hashCode method whenever this method is overridden, so as to maintain the general contract for the hashCode method, which states that equal objects must have equal hash codes.
The setter methods (setShort, setString, and so on) for setting IN parameter values must specify types that are compatible with the defined SQL type of the input parameter. For instance, if the IN parameter has SQL type INTEGER, then the method setInt should be used.
When reading the value of an out parameter, you must use the getter method whose Java type corresponds to the parameter's registered SQL type.
When reading the value of an out parameter, you must use the getXXX method whose Java type XXX corresponds to the parameter's registered SQL type.
However, the driver's behavior must be consistent with a particular DBMS, either always continuing to process commands or never continuing to process commands.
If two Permission objects are equal according to the equals method, then calling the hashCode method on each of the two Permission objects must produce the same integer result.
All CertPathValidator implementations must include a class (the SPI class) that extends this class (CertPathValidatorSpi)
All CertPathBuilder implementations must include a class (the SPI class) that extends this class (CertPathBuilderSpi) and implements all of its methods.
The format should be that returned by getFormat and produced by encode.
If this method returns true then calling unwrap with the same argument should succeed.
Applications that override the clone method can also throw this exception to indicate that an object could not or should not be cloned.
By convention, classes that implement this interface should override Object.clone (which is protected) with a public method.
This strategy is ignored if the implementer does not also specify the dialog settings for storing the bounds in Dialog.getDialogBoundsSettings().
The natural ordering for a class C is said to be consistent with equals if and only if e1.compareTo(e2) == 0 has the same boolean value as e1.equals(e2) for every e1 and e2 of class C.
The formats returned by the {@link Control#getFormats(String) getFormats} method and candidate locales returned by the {@link ResourceBundle.Control#getCandidateLocales(String, Locale) getCandidateLocales} method must be consistent in all ResourceBundle.getBundle invocations for the same base bundle.
All ReadWriteLock implementations must guarantee that the memory synchronization effects of writeLock operations (as specified in the {@link Lock} interface) also hold with respect to the associated readLock
Must have the same effect as getBindings(ScriptContext.ENGINE_SCOPE).get
The Bindings instances that are returned must be identical to those returned by the getBindings method of ScriptContext called with corresponding arguments on the default ScriptContext of the ScriptEngine.
The string must be in the same format as that produced by the {@link #toString} method.
If true is returned, the JDBC driver must support the returning of auto-generated keys for at least SQL INSERT statements
Subclasses may modify the parent's layout if they overload getLayout() to return null.
The visibility of the details button is controlled by {@link #shouldShowDetailsButton()}, which should also be overridden together with this method.
As of 3.4, you should only call this method if you want to override the {@link JFacePreferences#CONTENT_ASSIST_BACKGROUND_COLOR}.
Clients may implement this interface and override TextViewer.createDocumentAdapter if they want to intercept the communication between the viewer's text widget and the viewer's document.
Overriding this method is generally not required if the number of different keys is small. If a more efficient representation of a viewer's properties is required, override both getData and setData.
As specified in {@link Object#equals(Object)} clients will most likely also have to implement {@link Object#hashCode()}.
@link ICompletionProposal#getDisplayString()} still needs to be correctly implemented as this method might be ignored in case of uninstalled owner draw support.
This interface is not intended to be implemented by clients other than {@link org.eclipse.jface.text.ITextViewer} implementers.
Enriching this information control only works properly if {@link IInformationControl#isFocusControl()} is implemented like this (fShell is the control's shell): return fShell.getDisplay().getActiveShell() == fShell
Implementors of {@link ColumnViewer} have to provide a concrete implementation for the underlying widget
Overriding this method is generally not required if the number of different keys is small. If a more efficient representation of a viewer's properties is required, override both getData and setData.
Subclasses can override this to implement caching (override clear as well).
This quick assist assistant will only be able to query the invocation context if sourceViewer also implements {@link ISourceViewerExtension3}.
programmers should take note that any class that overrides the Object.equals method must also override the Object.hashCode method in order to satisfy the general contract for the Object.hashCodemethod
The readExternal method must read the values in the same sequence and with the same types as were written by writeExternal.
@exception SecurityException if there is a security manager and the caller does not have the permission required by {@link javax.management.MBeanServerFactory#createMBeanServer}.
An implementation of this interface must define a compareTo method that provides an ordering consistent with its getDelay method
All ReadWriteLock implementations must guarantee that the memory synchronization effects of writeLock operations (as specified in the {@link Lock} interface) also hold with respect to the associated readLock.
Note that the ordering maintained by a sorted map (whether or not an explicit comparator is provided) must be consistent with equals if this sorted map is to correctly implement the Map interface.
In order for the data structure to serialize successfully, the comparator (if provided) must implement Serializable.
The output should be equivalent the following invocation of {@link String#toUpperCase(java.util.Locale)} out.toUpperCase()
For a modifiable list the programmer should additionally implement the list iterator's set method.
For a variable-size list the programmer should additionally implement the list iterator's remove and add methods.
Implementations should seek to make this method perform equally as well as remove(Object)
Implementations should seek to make this method perform equally as well as get(Object).
The equivalent of a default constructor called by any constructor and by readObject.
Every Preferences implementation must have an associated {@link PreferencesFactory} implementation.
Every Java(TM) SE implementation must provide some means of specifying which PreferencesFactory implementation is used to generate the root preferences nodes.
Note that the ordering maintained by a set (whether or not an explicit comparator is provided) must be consistent with equals if it is to correctly implement the { Set} interface.
Providers of new {@link Preferences} implementations should provide corresponding PreferencesFactory implementations so that the new Preferences implementation can be installed in place of the platform-specific default implementation.
This API is only valid if the information control implements {@link org.eclipse.jface.text.IInformationControlExtension3}. Not following this restriction will later result in an {@link UnsupportedOperationException}
This API is only valid if the information control implements {@link IInformationControlExtension3}. Not following this restriction will later result in an {@link UnsupportedOperationException}.
Returns the column properties of this viewer. The properties must correspond with the columns of the table control.
The reader must present a serialized form as produced by the save method.
Note: This flag is only valid in {@link ICompletionListener#assistSessionStarted(ContentAssistEvent)}.
However, it is crucial that the programmer writing the verifier code be aware what Signature engine is being used, as its own implementation of the verify method is invoked to verify a signature.
If a reconcile strategy consists of several steps between which model transformation is desired the each step should implement {@link org.eclipse.jface.text.reconciler.IReconcileStep}.
Note: This content assist subject control may not support appending a verify listener, in which case false will be returned. If this content assist subject control only supports addVerifyKeyListener then this method can be used but prependVerifyKeyListener must return false.
After a call to this method, the method getWarnings returns null until a new warning is reported for this Connection object.
@exception SQLException if the columnLabel is not valid; if a database access error occurs or this method is called on a closed result set @exception SQLFeatureNotSupportedException if the JDBC driver does not support this method
This method assumes that {@link #isValidFor(IDocument, int)} returns true if called for offset.
Equivalent to insertBefore(id,new ActionContributionItem(action)).
It is strongly recommended (though not required) that natural orderings be consistent with equals.
A character may start a Unicode identifier if and only if one of the following conditions is true: {@link #isLetter(int) isLetter(codePoint)} returns true {@link #getType(int) getType(codePoint)} returns LETTER_NUMBER.
ColumnViewer implementors have to subclass this class and implement the missing methods
Subclasses of Objects that are not serializable can be serializable. In this case the non-serializable class must have a no-arg constructor to allow its fields to be initialized.
If you reimplement this method, you should also reimplement updateContents.
If you reimplement this method, you should also reimplement createContents.
The returned control's layout data must be an instance of GridData.
Subclasses of Number must provide methods to convert the represented numeric value to byte, double, float, int, long, and short.
For a given subclass of ObjectOutputStream that overrides this method, the resolveProxyClass method in the corresponding subclass of ObjectInputStream must read any data or objects written by annotateProxyClass
The resolveClass method in the corresponding subclass of ObjectInputStream must read and use any data or objects written by annotateClass
When a subclass is replacing objects it must insure that either a complementary substitution must be made during deserialization or that the substituted object is compatible with every field where the reference will be stored.
A no-arg constructor must be accessible to the subclass that is serializable.
These methods must explicitly coordinate with the supertype to save its state.
Classes that require special handling during the serialization and deserialization process must implement special methods with these exact signatures:
In this case the non-serializable class must have a no-arg constructor to allow its fields to be initialized.
Using this abstract class involves defining a concrete subclass and providing an implementation for the getImageData method.
It is subclass responsibility to specify how dirty regions are processed.
Subclasses may set a different layout.
Subclasses should initialize this to a calendar appropriate for the locale associated with this DateFormat.
Subclasses should initialize this to a number format appropriate for the locale associated with this DateFormat.
An implementation of this interface should map a MIME type into an instance of ContentHandler.
Subclass implementations of this abstract class must provide a public constructor that takes a Policy.Parameters object as an input parameter.
All CertPathValidator implementations must include a class (the SPI class) that extends this class (CertPathValidatorSpi) and implements all of its methods.
All CertPathBuilder implementations must include a class (the SPI class) that extends this class (CertPathBuilderSpi) and implements all of its methods.
Subclasses should not provide methods that can change the state of a permission once it has been created.
Subclasses who can provide this feature can open this method for the public
Subclasses do not typically override this method, but implement getSelectionFromWidget(List) instead.
Subclasses do not typically override this method, but implement setSelectionToWidget(List, boolean) instead.
Concrete subclasses of {@link ColumnViewer} should implement a matching concrete subclass of {@link ViewerColumn}.
Subclasses that hook their own focus listener should override this method and return false.
If this method is overridden, the method that overrides it should additionally check to see if the calling thread has the RuntimePermission(modifyThreadGroup) permission, and if so, return silently.
The stub class must extend {@link RemoteStub} and must have a public constructor that has one parameter, of type {@link RemoteRef}.
Subclasses must provide the storage and accessor methods for the additional arguments or parameters.
all of the methods and constructors in subclasses of this class must obey the additional constraints imposed by the Set interface
Subclasses must define the protected methods that change this state, and which define what that state means in terms of this object being acquired or released.
Therefore, any subclasses of Logger (unless they are implemented in conjunction with a new LogManager class) should take care to obtain a Logger instance from the LogManager class and should delegate operations such as isLoggable and log(LogRecord) to that instance.
IPv4 address byte array must be 4 bytes long and IPv6 byte array must be 16 bytes long
Implementations are encouraged to make regular use of Assert.isNotNull to ensure that null parameters are detected as early as possible.
Additional input parameters required for executing the check may be specified through constructors of concrete implementations of this class.
Bags or multisets (unordered collections that may contain duplicate elements) should implement this interface directly.
The default implementation provided in the Observable class will notify Observers in the order in which they registered interest, but subclasses may change this order, use no guaranteed order, deliver notifications on separate threads, or may guarantee that their subclass follows this order, as they choose.
ObjectInputStream subclasses which override this method can only be constructed in security contexts possessing the enableSubclassImplementation SerializablePermission; any attempt to instantiate such a subclass without this permission will cause a SecurityException to be thrown.
A subclass overrides the log method and scans each incoming LogRecord and calls push if a record matches some desired criteria.
Most Deque implementations place no fixed limits on the number of elements they may contain, but this interface supports capacity-restricted deques as well as those with no fixed size limit.
Decimal formats are generally not synchronized. It is recommended to create separate format instances for each thread.
Note: Support for the rowUpdated method is optional with a result set concurrency of CONCUR_READ_ONLY
Any implementer of this interface must be capable of operating in a non-UI thread.
It must be {@linkplain java.io.PipedWriter#connect( java.io.PipedReader) connected} to a PipedWriter before being used.
You must add at least one Comparator before calling the compare(Object,Object) method
An activation group must be registered with the ActivationSystem before objects can be registered within that group
The group must inform its ActivationMonitor that the object is active (via the monitor's activeObject method) if the group hasn't already done so.
A remote object implementation must call Activatable's inactive method when that object deactivates (the object deems that it is no longer active)
After removing the object from the RMI runtime, the group must inform its ActivationMonitor (via the monitor's inactiveObject method) that the remote object is not currently active so that the remote object will be re-activated by the activator upon a subsequent activation request.
A group must first be registered with the ActivationSystem before it can be created via this method
The client must also make a dirty call to renew leases on remote references before such leases expire
When the client no longer has any references to a specific remote object, it must schedule a clean call for the object ID associated with the reference
A failed dirty call must schedule a strong clean call so that the call's sequence number can be retained in order to detect future calls received out of order by the distributed garbage collector
The value actually set in the accepted socket must be determined by calling {@link Socket#getReceiveBufferSize()} after the socket is returned by {@link #accept()}.
Should be called whenever needsInput() returns true indicating that more input data is required.
This should be called whenever needsInput() returns true indicating that more input data is required.
A return value of 0 indicates that needsInput() or needsDictionary() should be called
A return value of 0 indicates that needsInput() or needsDictionary() should be called
Should be called whenever needsInput() returns true indicating that more input data is required
Should be called when inflate() returns 0 and needsDictionary() returns true indicating that a preset dictionary is required.
This should be called whenever needsInput() returns true indicating that more input data is required
This method must be called to release any resources associated with the stream.
This method must be called to release any resources associated with the stream.
Must be called to release any resources associated with the stream
Must be called to release any resources associated with the stream.
All the data in the returned stream must be read prior to getting the value of any other column
Attributes.Name.MANIFEST_VERSION must be set in MainAttributes prior to invoking this method.
Note that you must first call one of the getter methods on a column to try to read its value and then call the method wasNull to see if the value read was SQL NULL
must be called during DropTargetListener.drop method invocation.
must be called during DropTargetListener.drop method invocation.
At a minimum, the recovery operation must include closing the current connection and getting a new connection.
Packages must be created before the class is defined
All of the columns in a result set must be given a value each time this method is called before calling insertRow.
An updater method must be called before a getter method can be called on a column value.
you must call getMoreResults to move to any subsequent result(s).
This method will only work when it is invoked after the control of the dialog has been set
f preferenceStore is set to null, getPreferenceStore will invoke doGetPreferenceStore the next time it is called
This method may only be called once; the call must occur before JFaceResources.getFontRegistry is invoked
The option must be enabled prior to entering the blocking operation to have effect.
The option must be enabled prior to entering the blocking operation to have effect.
The option must be enabled prior to entering the blocking operation to have effect.
The option must be set prior to entering a blocking operation to take effect
For sockets accepted from a ServerSocket, this must be done by calling {@link ServerSocket#setReceiveBufferSize(int)} before the ServerSocket is bound to a local address.
For client sockets, setReceiveBufferSize() must be called before connecting the socket to its remote peer.
This method must be called before the URLConnection is connected.
This method must be called before the URLConnection is connected.
To avoid continual thread replacement, the keep-alive time must be greater than zero when setting true.
applet should avoid calling methods in java.applet.Applet in the constructor.
Because isShowing returns false when the applet's start is first called, methods requiring isShowing to return true should be called from a ComponentListener.
This method should be called before requesting the order of the contribution items to ensure that the order is accurate.
Only listeners registered at the time this method is called are notified.
Only listeners registered at the time this method is called are notified.
This method should be called after the dialog has been opened as it updates the message label immediately
If fork is set to false, the runnable will run in the UI thread and it is the runnable's responsibility to call Display.readAndDispatch() to ensure UI responsiveness.
Calls to setText(String text) and setImage(Image image) are required in order to fill the message area.
This method may only be called after initializeDialogUnits has been called.
This method may only be called after initializeDialogUnits has been called.
This method may only be called after initializeDialogUnits has been called.
This method may only be called after initializeDialogUnits has been called.
This method may only be called after the page's control has been created.
This method must be called before any of the dialog unit based conversion methods are called.
The method initializeDialogUnits must be called once before calling this method for the first time.
This method may only be called after initializeDialogUnits has been called.
This method may only be called after initializeDialogUnits has been called.
This method may only be called after initializeDialogUnits has been called.
This method may only be called after initializeDialogUnits has been called.
The caller must validate it using {@link #isSurrogatePair(char, char) isSurrogatePair} if necessary.
This thread group must be empty, indicating that all threads that had been in this thread group have since stopped.
This method must be called before the thread is started.
The caller must validate the character value using {@link #isValidCodePoint(int) isValidCodePoint} if necessary.
The context must be a security context returned by a previous call to getSecurityContext.
It must be connected to a piped reader, either by the receiver or the sender, before being used.
It must be {@linkplain java.io.PipedWriter#connect( java.io.PipedReader) connected} to a PipedWriter before being used
It must be connected to a piped input stream, either by the receiver or the sender, before being used.
It must be {@linkplain java.io.PipedOutputStream#connect( java.io.PipedInputStream) connected} to a PipedOutputStream before being used.
Subclasses should check this method before loading or saving.
Formatters should set this before returning an error code from their parseObject method.
The instance specific setRequestProperty method should be used after an appropriate instance of URLConnection is obtained.
The instance specific getRequestProperty method should be used after an appropriate instance of URLConnection is obtained.
In the first case, the permission should be obtained after the object has been obtained.
In the second case, the permission should be obtained and tested before connecting.
HTTP protocol implementers should make sure that this method is called after all request headers related to choosing cookies are added, and before the request is sent.
Applications should not assume that they can change the TOS field after the connection.
Done should only be called if the invoke returns successfully (non-exceptionally) to the stub.
It must be {@linkplain java.io.PipedOutputStream#connect( java.io.PipedInputStream) connected} to a PipedOutputStream before being used.
This should be invoked after defining a class.
All OUT parameters must be registered before a stored procedure is executed.
All OUT parameters must be registered before a stored procedure is executed.
The type of all OUT parameters must be registered prior to executing the stored procedure; their values are retrieved after execution via the get methods provided here.
All OUT parameters must be registered before a stored procedure is executed.
All OUT parameters must be registered before a stored procedure is executed.
The execute method executes an SQL statement and indicates the form of the first result. You must then use the methods getResultSet or getUpdateCount to retrieve the result, and getMoreResults to move to any subsequent result(s)
The attributes must be read from an SQLInput input stream and written to an SQLOutput output stream in the same order in which they were listed in the SQL definition of the user-defined type.
All OUT parameters must be registered before a stored procedure is executed.
All OUT parameters must be registered before a stored procedure is executed.
And as described in SQLData, calls to reader methods must be made in the order that their corresponding attributes appear in the SQL definition of the type.
All the data in the returned stream must be read prior to getting the value of any other column.
All the data in the returned stream must be read prior to getting the value of any other column
All the data in the returned stream must be read prior to getting the value of any other column.
All the data in the returned stream must be read prior to getting the value of any other column.
All the data in the returned stream must be read prior to getting the value of any other column.
You must then use the methods getResultSet or getUpdateCount to retrieve the result, and getMoreResults to move to any subsequent result(s).
The execute method executes an SQL statement and indicates the form of the first result. You must then use the methods getResultSet or getUpdateCount to retrieve the result, and getMoreResults to move to any subsequent result(s).
The execute method executes an SQL statement and indicates the form of the first result. You must then use the methods getResultSet or getUpdateCount to retrieve the result, and getMoreResults to move to any subsequent result(s).
All streams must be closed before execute() occurs or an SQLException will be thrown.
The getKeyStore method must be invoked before this method may be called.
To instantiate a PKIXParameters object, an application must specify one or more most-trusted CAs as defined by the PKIX certification path validation algorithm.
Before a keystore can be accessed, it must be {@link #load(java.io.InputStream, char[]) loaded}.
Once engineDigest has been called, the engine should be reset (see {@link #engineReset() engineReset}).
Once engineDigest has been called, the engine should be reset (see {@link #engineReset() engineReset}).
A MessageDigest object starts out initialized. The data is processed through it using the {@link #update(byte) update} methods. At any point {@link #reset() reset} can be called to reset the digest. Once all the data to be updated has been updated, one of the {@link #digest() digest} methods should be called to complete the hash computation.
The last used Iterator is the Iterator upon which next() or hasNext() was most recently called used for the remove() operation only
This method can only be called after at least one {@link #next} method call.
This method can only be called after at least one {@link #next} or {@link #previous} method call.
This method may only be called once, otherwise an IllegalStateException will occur.
This method can only be called if next() was called, but not after hasNext(), because the hasNext() call changes the base iterator.
Applications that need to process policy qualifiers should explicitly set the policyQualifiersRejected flag to false (by calling the {@link PKIXParameters#setPolicyQualifiersRejected PKIXParameters.setPolicyQualifiersRejected} method) before validating a certification path.
Note: {@link ListIterator} implementations that support add() and remove() only allow set() to be called once per call to next() or previous (see the {@link ListIterator} javadoc for more details).
Retrieves the current result as a ResultSet object. This method should be called only once per result.
@throws IllegalStateException if next() has not yet been called.
This method should be called only once per result.
Note that this method should be called only after calling a getter method; otherwise, there is no value to use in determining whether it is null or not.
For maximum portability, a call's ResultSet objects and update counts should be processed prior to getting the values of output parameters.
this method must allocate a new array even if this set is backed by an array
In other words, this method must allocate a new array even if this set is backed by an array
In other words, this method must allocate a new array even if this collection is backed by an array
Once it has downloaded the bytes that make up the class, it should use the method {@link #defineClass defineClass} to create a class instance.
Clients of a IFindReplaceTarget that also implements the IFindReplaceTargetExtension have to indicate the start of a find/replace session before using the target and to indicate the end of the session when the target is no longer used.
This method must be called before any of the dialog unit based conversion methods are called.
This is the ResourceBundle that should be used to localize the message string before formatting it.
This is the name for the ResourceBundle that should be used to localize the message string before formatting it.
This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method.
This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method.
This method should in general be called before the pool is actively used.
Should be called when inflate() returns 0 and needsDictionary() returns true indicating that a preset dictionary is required.
Before obtaining an item each thread must acquire a permit from the semaphore, guaranteeing that an item is available for use.
The { park} method may also return at any other time, for no reason, so in general must be invoked within a loop that rechecks conditions upon return.
Use {@link #hasNext} to avoid this error.
As of JDK 1.1, the Calendar class should be used to convert between dates and time fields and the DateFormat class should be used to format and parse date strings.
This method can be called once per call to next().
@throws IllegalStateException if next() has not yet been called
This method can be called once per call to next().
@throws IllegalStateException if next() has not yet been called
@throws IllegalStateException if remove() has already been called since the last call to next()
However, you can't call this method on the same iterator more than once without calling next() or previous().
Note: {@link ListIterator} implementations that support add() and remove() only allow set() to be called once per call to next() or previous (see the {@link ListIterator} javadoc for more details).
This means that you don't have to wrap instances of this class with {@link java.util.Collections#synchronizedMap(Map)}; instances are already thread-safe.
Trusted system code should typically invoke the methods in this class, and the methods of the iterators which they return, from within a privileged security context.
Thus level settings for child nodes in the tree should come after settings for their parents.
Purges stale mappings from this map before read operations.
Purges stale mappings from this map before write operations.
An unused ExecutorService should be shut down to allow reclamation of its resources.
@throws IllegalStateException if hasNext() has already been called.
You will normally use {@link #addIterator(Iterator)} to add some iterators after using this constructor.
You will normally use {@link #addIterator(Iterator)} to add some more iterators after using this constructor.
@throws IllegalStateException if the next or previous method has not yet been called, or the remove method has already been called after the last call to next or previous.
@throws IllegalStateException if the next method has not yet been called, or the remove method has already been called after the last call to the next method.
@throws IllegalStateException if the next method has not yet been called, or the remove method has already been called after the last call to the next method.
@throws IllegalStateException if the next method has not yet been called, or the remove method has already been called after the last call to the next method.

package names must be unique within a class loader and cannot be redefined or changed once created.
The context must be a security context returned by a previous call to getSecurityContext and the access control decision is based upon the configured security policy for that security context.
The context must be a security context returned by a previous call to getSecurityContext.
The keys should be immutable If they are not then they must not be changed after adding to the MultiKey.
The encoding should be set before any LogRecords are written to the Handler.
When a call to the next method returns false, the cursor is positioned after the last row. Any invocation of a ResultSet method which requires a current row will result in a SQLException being thrown.
When a call to the previous method returns false, the cursor is positioned before the first row. Any invocation of a ResultSet method which requires a current row will result in a SQLException being thrown.
If an activatable object requires restart services, use one of the ActivationDesc constructors that takes a boolean parameter, restart.
If an activatable object requires restart services, use one of the ActivationDesc constructors that takes a boolean parameter, restart.
The encoding should be set before any LogRecords are written to the Handler.
If the same listener instance has been added to the listener table through multiple invocations of addPropertyChangeListener, then an equivalent number of removePropertyChangeListener invocations are required to remove all instances of that listener from the listener table.
When the data is later uncompressed with Inflater.inflate(), Inflater.getAdler() can be called in order to get the Adler-32 value of the dictionary required for decompression.
This is set to -1 if neither method has yet been invoked.
Constructs a new FilterIterator that will not function until {@link #setPredicate(Predicate) setPredicate} is invoked.
Constructs a new FilterListIterator that will not function until {@link #setListIterator(ListIterator) setListIterator} and {@link #setPredicate(Predicate) setPredicate} are invoked.
Constructs a new FilterListIterator that will not function until {@link #setPredicate(Predicate) setPredicate} is invoked.
Constructs a new FilterListIterator that will not function until {@link #setListIterator(ListIterator) setListIterator} is invoked.
Constructs a new TransformIterator that will not function until the {@link #setIterator(Iterator) setIterator} and {@link #setTransformer(Transformer)} methods are invoked.
Holds the index of the last item returned by a call to next() or previous(). This is set to -1 if neither method has yet been invoked.
Constructs a new IteratorEnumeration that will not function until {@link #setIterator(Iterator) setIterator} is invoked.
Constructs a new FilterIterator that will not function until {@link #setIterator(Iterator) setIterator} is invoked.
@throws IllegalStateException If {@link #next()} or {@link #previous()} haven't been called, or if the node has been removed with {@link #remove()} or a new node added with {@link #add(Object)}.
Gets the index of the item to be retrieved if {@link #previous()} is called.
Using this constructor, the iterator is equivalent to an empty iterator until {@link #setArray} is called to establish the array to iterate over.
Returns the index of the element that would be returned by a subsequent call to previous.
Returns the index of the element that would be returned by a subsequent call to {@link #next}.
Returns the index of the element that would be returned by a subsequent call to {@link #previous}.
Constructs a new EnumerationIterator that will not function until {@link #setEnumeration(Enumeration)} is called.
Events are not generated when preferences are modified in descendants of this node; a caller desiring such events must register with each descendant.
If the matcher is to be used in further matching operations then it should first be reset.
When waiting upon a { Condition}, a spurious wakeup is permitted to occur, in general, as a concession to the underlying platform semantics. This has little practical impact on most application programs as a { Condition} should always be waited upon in a loop, testing the state predicate that is being waited for.
If the matcher is to be used in further matching operations then it should first be reset.
This must be called AFTER all of the child controls have been created and their layouts attached. This method will attach a layout to the given composite. If any new children are created after calling this method, their GridData must be created manually. The algorithm does not recurse into child composites. To generate all the layouts in a widget hierarchy, the method must be called bottom-up for each Composite.
This method may be called repeatedly to iterate through the list backwards, or intermixed with calls to next to go back and forth. (Note that alternating calls to next and previous will return the same element repeatedly.)
As of 3.2, AbstractTreeViewer supports multiple equal elements (each with a different parent chain) in the tree. This support requires that clients enable the element map by calling setUseHashLookup(true).
As the ILazyContentProvider does not have API for determining the total item count any changes to the number of items for this object while require a call to #setItemCount on the viewer that uses it.
The recommended usage is to use {@link java.net.URI} to identify resources, then convert it into a {@link java.net.URL} when it is time to access the resource. From that URL, you can either get the {@link java.net.URLConnection} for fine control, or get directly the InputStream.Here is an example:URI uri = new URI(http://java.sun.com/);URL url = uri.toURL();InputStream in = url.openStream();
Since the time when GC would invoke this method is undetermined, it is strongly recommended that applications invoke the close method as soon they have finished accessing this ZipFile.
It is strongly recommended that an application explicitly commits or rolls back an active transaction prior to calling the close method.
Note that the default implementation of this method does not call setRedraw.
Note that the dialog will have no visual representation (no widgets) until it is told to open.
Note: the node is not visually expanded! You may have to call parent.setExpanded(true).
Note that the window will have no visual representation (no widgets) until it is told to open.
Note that the dialog will have no visual representation (no widgets) until it is told to open.
Prior to 3.0 this method can only be called once. Since 3.0 this method can be called again after a call to {@link ISourceViewerExtension2#unconfigure()}.
This can be used prior to a sequence of additions to avoid memory reallocation.
Prior to disposing, a painter should be deactivated.
Assumes that the element has been expanded before.
The output stream can be used again, reusing the already allocated buffer space.
This signature object is reset to its initial state (the state it was in after a call to one of the initSign methods) and can be reused to generate further signatures with the same private key.
Returns the SWT menu, created as a pop up menu parented by the given control. In most cases, this menu can be created once, cached and reused when the pop-up/drop-down action occurs. If the menu must be dynamically created (i.e., each time it is popped up or dropped down), the old menu should be disposed of before replacing it with the new menu.
If the font of the specified control is changed after this PixelConverter is created, then the conversions from this instance will not produce the desired effect.
This method takes the Device that created the Image as an argument, allowing the original Image to be reused if the descriptor is asked for another Image on the same device.
Returns an SWT menu created as a drop down menu parented by the given menu. In most cases, this menu can be created once, cached and reused when the pop-up/drop-down action occurs.
Note that all preference nodes must be dispose their resources. The node must dispose the page managed by this node, and any SWT resources allocated by this node (Images, Fonts, etc). However the node itself may be reused.
Previous values of other fields are retained. If this is not desired, call {@link #clear()} first.
When the caller is done with an image obtained from createResource, they must call destroyResource() rather than disposing the Image directly. The result of createResource() can be safely cast to an Image.
Note that depending on the values the human has supplied so far, additional values may become necessary, so it may be necessary to iterate though several calls to the getPropertyInfo method.
There are two cases to be aware of: For sockets accepted from a ServerSocket, this must be done by calling {@link ServerSocket#setReceiveBufferSize(int)} before the ServerSocket is bound to a local address. For client sockets, setReceiveBufferSize() must be called before connecting the socket to its remote peer.
This method should only be called from the UI thread. If you are not on the UI thread then wrap the call with a PlatformUI.getWorkbench().getDisplay().synchExec() in order to guarantee the correct result.
Painters are informed about changes to the viewer content and state and can take the necessary action in responds to the notification.
If the resource is intended to live for entire lifetime of the resource manager, a subsequent call to {@link #destroy(DeviceResourceDescriptor)} may be omitted and the resource will be cleaned up when the resource manager is disposed. This pattern is useful for short-lived {@link LocalResourceManager}s, but should never be used with the global resource manager since doing so effectively leaks the resource.
Once this method returns successfully, it is safe to assume that all changes made in the subtree rooted at this node prior to the method invocation have become permanent.
Adjust the bounds of the popup as necessary prior to opening the dialog.
If fork is set to false, the runnable will run in the UI thread and it is the runnable's responsibility to call Display.readAndDispatch() to ensure UI responsiveness.
Usually, clients instantiate this class and configure it before using it. The configuration must be consistent: This means the used {@link org.eclipse.jface.text.IInformationControlCreator} must create an information control expecting information in the same format the configured {@link org.eclipse.jface.text.information.IInformationProvider}s use to encode the information they provide.
The preference node assumes (sole) responsibility for disposing of the image; this will happen when the node is disposed.
There must be an SWT Display created in the current thread before calling this method.
This method will be called before any other method and can be called multiple times.
This method will be called before any other method and can be called multiple times.
Must be called before paint is called the first time.
This method must be called before this window's shell is created.
In other words, if this method were to be called twice in succession, the second call would return false (unless the current thread were interrupted again, after the first call had cleared its interrupted status and before the second call had examined it).
If this rules relies on a text pattern comprising a opening and a closing character sequence this method can also be called when the scanner is positioned already between the opening and the closing sequence. In this case, resume must be set to true.
The object is invalid once the free method is called.
Once the stream has been closed, further read(), ready(), mark(), or reset() invocations will throw an IOException
This method can only be called once the connection has been completely verified by reading from the input stream until the end of the stream has been reached.
Once a socket has been closed, it is not available for further networking use (i.e. can't be reconnected or rebound). A new socket needs to be created.
Once the stream has been closed, further write() or flush() invocations will cause an IOException to be thrown.
Once this method is called, the behavior of the Deflater object is undefined.
lients should typically call this method once, create a color from the RGB provided, and dispose of the color when finished using it.
Clients who created this column are responsible to call this method once the column is no longer used.
Note: This method must be called at most once per reconcile step.
Once the client is done with a wizard node, its disposemethod must be called to free up the wizard; once disposes, the node should no longer be used.
Unlike {@link ISourceViewer#configure(SourceViewerConfiguration)} this method can be called more than once without interleaving calls to {@link ISourceViewer#configure(SourceViewerConfiguration)}.
It should be set when the action is created. It should not be modified once the action is part of an action contribution item.
Once established, a page's wizard cannot be changed to a different wizard.
Note: It is the callers responsibility to prevent an endless loop i.e. to test whether a given anchor has already been used once.
@throws IllegalStateException if this method is called more than once
If no TableColumns were created by the programmer, this method will throw ERROR_INVALID_RANGE despite the fact that a single column of data may be visible in the table.
There must be an SWT Display created in the current thread before calling this method.
May only be called from a UI thread.
It is important not to use the original set after invoking this method, as it is a backdoor for adding untransformed objects.
It is important not to use the original set after invoking this method, as it is a backdoor for adding untransformed objects.
It is important not to use the original list after invoking this method, as it is a backdoor for adding invalid objects.
It is important not to use the original set after invoking this method, as it is a backdoor for adding invalid objects
It is important not to use the original bag after invoking this method, as it is a backdoor for adding invalid objects.
It is important not to use the original list after invoking this method, as it is a backdoor for adding untransformed objects.
It is important not to use the original bag after invoking this method, as it is a backdoor for adding untransformed objects.
Once the shell is created, it must be disposed (i.e., closed) before this method can be called.
Must be called before start. May again be called between start and stop.
Invoking the method before the content area has been set or after the dialog has been disposed will have no effect.
Usually, clients instantiate this class and configure it before using it.
There must be an SWT Display created in the current thread before calling this method.
This method must be called before this window's shell is created.
Note that multiple calls to formatterStarts can be issued to a strategy before launching the formatting process with format.
Must be called before start. May again be called between start and stop.
TableViewer#replace(Object, int) is not called before returning from this method selections may have missing or stale elements. In this situation it is suggested that the selection is asked for again after he update.
Calling this method has no effect after createPartControl is called.
It is allowed to call this method after this hyperlink manger has been installed.
Closing a ByteArrayInputStream has no effect. The methods in this class can be called after the stream has been closed without generating an IOException.
Invoking this method after this socket has been bound will have no effect.
After free has been called, any attempt to invoke a method other than free will result in a SQLException being thrown.
. After free has been called, any attempt to invoke a method other than free will result in a SQLException being thrown.
Register an object to be validated before the graph is returned. While similar to resolveObject these validations are called after the entire graph has been reconstituted.
In this case, these tasks will only terminate upon shutdownNow, or after setting the policy to false when already shutdown.
@param value if true, execute after shutdown, else don't. @see #getExecuteExistingDelayedTasksAfterShutdownPolicy
this means that the flush method is automatically invoked after a byte array is written, one of the println methods is invoked, or a newline character or byte ('') is written.
After the group is created, the ActivationSystem is informed that the group is active by calling the activeGroup method which returns the ActivationMonitor for the group.
The methods in this class can be called after the stream has been closed without generating an IOException.
Invoking this method will result in the creation of the returned node and its ancestors if they do not already exist. If the returned node did not exist prior to this call, this node and any ancestors that were created by this call are not guaranteed to become permanent until the flush method is called on the returned node (or one of its ancestors or descendants).
If the returned node did not exist prior to this call, this node and any ancestors that were created by this call are not guaranteed to become permanent until the flush method is called on the returned node (or one of its ancestors or descendants).
It can be called at most once by an application.
Reading and writing XML values to or from an SQLXML object can happen at most once. The conceptual states of readable and not readable determine if one of the reading APIs will return a value or throw an exception. The conceptual states of writable and not writable determine if one of the writing APIs will set a value or throw an exception.The state moves from readable to not readable once free() or any of the reading APIs are called: getBinaryStream(), getCharacterStream(), getSource(), and getString(). Implementations may also change the state to not writable when this occurs.The state moves from writable to not writeable once free() or any of the writing APIs are called: setBinaryStream(), setCharacterStream(), setResult(), and setString(). Implementations may also change the state to not readable when this occurs.
Once the shutdown sequence has begun it can be stopped only by invoking the {@link #halt halt} method, which forcibly terminates the virtual machine.Once the shutdown sequence has begun it is impossible to register a new shutdown hook or de-register a previously-registered hook. Attempting either of these operations will cause an {@link IllegalStateException} to be thrown.
Once a node has been removed, attempting any method other than {@link #name()}, {@link #absolutePath()}, {@link #isUserNode()}, {@link #flush()} or {@link #node(String) nodeExists()} on the corresponding Preferences instance will fail with an IllegalStateException
@throws FormatterClosedException If this formatter has been closed by invoking its {@link #close()} method
The required field is true if a value must be supplied for this property during Driver.connect and false otherwise.
This thread group must be empty, indicating that all threads that had been in this thread group have since stopped.
If this pathname denotes a directory, then the directory must be empty in order to be deleted.
Write the data and fields to the specified ObjectOutput stream, which must be the same stream that produced this PutField object.
The keys should be immutable If they are not then they must not be changed
The first class defined in a package determines the exact set of certificates that all subsequent classes defined in that package must contain. The set of certificates for a class is obtained from the {@link java.security.CodeSource CodeSource} within the ProtectionDomain of the class. Any classes added to that package must contain the same set of certificates or a SecurityException will be thrown.
The current thread must own this object's monitor.
The current thread must own this object's monitor.
The current thread must own this object's monitor.
The cursor must be on the insert row when this method is called.
The caller principal must be an owner of the ACL in order to invoke this method.
The caller principal must be an owner of the ACL in order to invoke this method.
@param caller the principal invoking this method. It must be an owner of this ACL.
@param caller the principal invoking this method. It must be an owner of this ACL.
@param caller the principal invoking this method. It must be an owner of this ACL.
For each certificate cert in a certification path certPath, cert.getType().equals(certPath.getType()) must be true.
If the identity has a public key, the public key in the certificate must be the same, and if the identity does not have a public key, the identity's public key is set to be that specified in the certificate.
This feature is only supported if the underlying collection's {@link Collection#iterator iterator} method returns an implementation that supports it.
This feature is only supported if the underlying list's {@link List#iterator iterator} method returns an implementation that supports it.
This feature is only supported if the underlying list's {@link List#listIterator} method returns an implementation that supports it.
In general, only immutable objects should use the constant factory.
The keys should be immutable If they are not then they must not be changed after adding to the MultiKey. @
This feature is only supported if the underlying list's {@link List#listIterator} method returns an implementation that supports it
@throws UnsupportedOperationException if the add method is not supported by the iterator implementation of the underlying list
The setValue() method on iterators will succeed only if the new value being set is not already in the bidimap.
This method should be used only when auto-commit mode has been disabled.
This method should be used only when auto-commit mode has been disabled.
This method should be used only when auto-commit has been disabled.
This version of registerOutParameter should be used when the parameter is of JDBC type NUMERIC or DECIMAL.
This version of registerOutParameter should be used when the parameter is of JDBC type NUMERIC or DECIMAL.
This method should only be called by a thread that is the owner of this object's monitor.
This method should only be called by a thread that is the owner of this object's monitor.
@return the dialog, after being closed by the user, which the client can only call getReturnCode() or getToggleState()
@return the dialog, after being closed by the user, which the client can only call getReturnCode() or getToggleState()
@return the dialog, after being closed by the user, which the client can only call getReturnCode() or getToggleState()
If there is a security manager, then the calling context must have permission to connect to all of the URLs in the codebase URL path; otherwise, the current thread's context class loader will be used instead of the codebase loader.
This method should only be called by a thread that is the owner of this object's monitor.
This method should only be called by a thread that is the owner of this object's monitor.
This method should only be called by a thread that is the owner of this object's monitor.
Note that a DefaultKeyValue instance may not contain itself as a key or value.
This value is computed once and then cached, so elements should not change their hash codes once created
Note that IndexOutOfBoundsException IS returned for invalid negative indices.
Take care when using this list with null values, as null is the value added when growing the list.
ComparatorChains cannot be modified once they have performed a comparison.
FixedOrderComparators cannot be modified once they have performed a comparison.
IteratorChains cannot be modified once they have executed a method from the Iterator interface.
@throws IllegalStateException if remove() has already been called since the last call to next()
Once compare has been called, the FixedOrderComparator is locked and attempts to modify it yield an UnsupportedOperationException.
The hashcode is calculated once here in this method. Therefore, changing the array passed in would not change the hashcode but would change the equals method, which is a bug.
the composited map does not not permit null keys (optional).
@throws UnsupportedOperationException if the comparator is locked
This operation assumes that the inverse mapping is well defined.
@param object the object to evaluate, should not be changed
@throws UnsupportedOperationException if no MapMutator has been specified
@throws UnsupportedOperationException if a comparison has already been made
The index must be a value greater than or equal to { 0} and less than or equal to the current size of the vector.
The origin component must be contained within the component hierarchy of the popup menu's parent.
maximumFractionDigits must be >= minimumFractionDigits.
The index must be a value greater than or equal to { 0} and less than the current size of the vector.
minimumFractionDigits must be <= maximumFractionDigits.
With strict parsing, inputs must match this object's format.
The index must be a value greater than or equal to { 0} and less than the current size of the vector.
@throws IllegalStateException if the array was set in the constructor
@throws IndexOutOfBoundsException if the index is out of range (index < 0 || index > size()).
Therefore, if the reading of one ResultSet object is interleaved with the reading of another, each must have been generated by different Statement objects.
For each certificate cert in a certification path certPath, cert.getType().equals(certPath.getType()) must be true.
The certificate representing the {@link TrustAnchor TrustAnchor} should not be included in the certification path.
@param key the key to set, must be the key of the map
The provider must be accessible from the same class loader that was initially queried to locate the configuration file; this is not necessarily the class loader that loaded the file.
This field should be true if this node did not exist in the backing store prior to the creation of this object.
You must use a different iterator for each unit boundary analysis you wish to perform.
A PKIX CertPathBuilder instance must not build paths longer than the length specified.
@throws ArithmeticException if the rounding mode is { UNNECESSARY} and the { BigDecimal} operation would require rounding.
@throws ArithmeticException if { roundingMode==UNNECESSARY} and the specified scaling operation would require rounding.
@throws ArithmeticException if { roundingMode==ROUND_UNNECESSARY} and the specified scaling operation would require rounding.
@throws ArithmeticException if the specified scaling operation would require rounding.
This requires LoggingPermission(control).
The application should retain its own reference to the Logger object to avoid it being garbage collec
The provider must be accessible from the same class loader that was initially queried to locate the configuration file; note that this is not necessarily the class loader from which the file was actually loaded.
This target must be editable.
Note that an image registry owns all of the image objects registered with it, and automatically disposes of them when the SWT Display is disposed. Because of this, clients must not register an image object that is managed by another object.
Merges the given range into this presentation. The range must be a subrange of the presentation's default range.
Replaces the given ranges in this presentation. Each range must be a subrange of the presentation's default range. The ranges must be ordered by increasing offset and must not overlap (but may be adjacent).
The hover information control which is used to display the information must be able process the given object.
Replaces the given range in this presentation. The range must be a subrange of the presentation's default range.
@param originalDevice must be the same Device that was passed into the font's constructor when it was first created.
Removes the given TransferDropTargetListener. Listeners should not be removed while a drag and drop operation is in progress.
Requires {@link StyledCellLabelProvider} with owner draw enabled.
Set the style ranges to be applied on the text label at the column index Note: Requires {@link StyledCellLabelProvider} with owner draw enabled.
ObjectOutputStream subclasses which override this method can only be constructed in security contexts possessing the enableSubclassImplementation SerializablePermission; any attempt to instantiate such a subclass without this permission will cause a SecurityException to be thrown.
NOTE: Do not reuse StatusLineLayoutData objects. Every control in the status line must have a unique StatusLineLayoutData instance or null.
@exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(control).
@exception SecurityException if a security manager exists and its checkMulticast method doesn't allow the join.
@exception SecurityException if a security manager exists and if the caller does not have LoggingPermission(control).
If the current thread is the holder of this lock then the hold count is decremented. If the hold count is now zero then the lock is released. If the current thread is not the holder of this lock then {@link IllegalMonitorStateException} is thrown. @throws IllegalMonitorStateException if the current thread does not hold this lock.
This method should only be called from the UI thread. If you are not on the UI thread then wrap the call with a PlatformUI.getWorkbench().getDisplay().synchExec() in order to guarantee the correct result.
@throws IllegalArgumentException if this map itself has a restricted range, and fromKey lies outside the bounds of the range
However, a call to set(Calendar.DAY_OF_MONTH, 30) before the call to getTime() sets the date to September 30, 1999, since no recomputation occurs after set() itself.
After invoking this method the file or directory is guaranteed not to change until it is either deleted or marked to allow write access.
After this method returns, the next character to be read will have the value cbuf[off], the character after that will have the value cbuf[off+1], and so forth.
After this method returns, the next character to be read will have the value cbuf[0], the character after that will have the value cbuf[1], and so forth.
The map will be empty after this call returns.
The list will be empty after this call returns.
However, the bulk Collection operations addAll, containsAll, retainAll and removeAll are not necessarily performed atomically unless specified otherwise in an implementation. So it is possible, for example, for addAll(c) to fail (throwing an exception) after adding only some of the elements in c.
Thus, repeated calls are guaranteed never to reduce randomness.
Resets the stream to the most recent mark, or to the beginning of the string if it has never been marked.
If the object does not call Activatable.inactive when it deactivates, the object will never be garbage collected since the group keeps strong references to the objects it creates.
The table does not maintain strong references to its contained loaders, in order to allow them and their defined classes to be garbage collected when not otherwise reachable.
The current thread is assumed to hold the lock associated with this { Condition} when this method is called.
The current thread is assumed to hold the lock associated with this { Condition} when this method is called.
Subclassers are advised to override inputChanged rather than this method
Subclasses should either call the super implementation or, alternatively, {@link #initialize(ColumnViewer, ViewerColumn, boolean)}.
Subclasses that require a different dialog area may either override this method, or call the super implementation and add controls to the created composite.
applications that override this method should either call super.update(g) or incorporate the functionality described
Subclasses of Component that override this method should either call super.update(g), or call paint(g) directly from their update method.
This interface is used only for computations that do not throw checked exceptions; computations that throw checked exceptions must use PrivilegedExceptionAction instead.
You must call either the method getResultSet or getUpdateCount to retrieve the result
Client implementations of dispatchEvent and client-defined KeyEventDispatchers must call redispatchEvent(target, e) instead of target.dispatchEvent(e) to dispatch an event.
The new {@link #divide(BigDecimal, int, RoundingMode)} method should be used in preference to this legacy method.
The new {@link #divide(BigDecimal, RoundingMode)} method should be used in preference to this legacy method.
Using the integer fields in this class (such as {@link #ROUND_HALF_UP}) to represent rounding mode is largely obsolete; the enumeration values of the { RoundingMode} { enum}, (such as {@link RoundingMode#HALF_UP}) should be used instead.
The new {@link #setScale(int, RoundingMode)} method should be used in preference to this legacy method.
When a { double} must be used as a source for a { BigDecimal}, note that this constructor provides an exact conversion; it does not give the same result as converting the { double} to a { String} using the {@link Double#toString(double)} method and then using the {@link #BigDecimal(String)} constructor. To get that result, use the { static} {@link #valueOf(double)} method.
It is recommended that implementations of IKeyFormatter subclass from here, rather than implementing IKeyFormatter directly.
It is recommended to subclass this class instead of Dialog in all cases except where the dialog should never show a tray.
An application does not generally call the getContent method in this class directly. Instead, an application calls the getContent method in class URL or in URLConnection.
It is recommended to use ViewerComparator instead.
Update(SIZE) should be called to adjust the widget.
Update(SIZE) should be called to adjust the widget.
Subclasses must implement createControl rather than overriding this method.
Subclasses must implement createControl rather than overriding this method.
This method clears the existing bindings, but does not trigger a recomputation (other method calls are required to do that).
Subclasses should override createCustomArea to add contents below the message.
Overriding createDialogArea and createButtonBar are recommended rather than overriding this method.
Clients should subclass the abstract base class Action to define concrete actions rather than implementing IAction from scratch.
Subclasses should override this method if they do not need information from the triggering event, or override runWithEvent(Event) if they do.
Subclasses typically need not override this method, but instead should use the constructor parameters showDialogMenu and showPersistAction to indicate whether a menu should be shown, and createTitleControl to to customize the presentation of the title.
Subclasses should override this method when an alternate default size is desired, rather than overriding {@link #getInitialSize()}.
Subclasses should override this method when an alternate default location is desired, rather than overriding {@link #getInitialLocation(Point)}
Clients can implement this interface and its extension interfaces, subclass {@link AbstractInformationControl}, or use the (text-based) default implementation {@link DefaultInformationControl}.
@deprecated since 3.1 use {@link org.eclipse.jface.text.DefaultIndentLineAutoEditStrategy} instead
Subclasses must either override this method or implement {@link IInformationControlExtension2}.
Because SO_RCVBUF is a hint, applications that want to verify what size the buffers were set to should call {@link #getReceiveBufferSize()}.
As SO_SNDBUF is a hint, applications that want to verify what size the buffer is should call {@link #getSendBufferSize()}.
Because SO_RCVBUF is a hint, applications that want to verify what size the buffers were set to should call {@link #getReceiveBufferSize()}.
Therefore an RMI application should use the SecurityManager class or another application-specific SecurityManager implementation instead of this class.
Instead, an application should register an activation descriptor and export a remote object separately, so that exceptions can be handled properly.
Instead, an application should register an activation descriptor and export a remote object separately, so that exceptions can be handled properly.
Instead, an application should register an activation descriptor and export a remote object separately, so that exceptions can be handled properly.
Instead, an application should register an activation descriptor and export a remote object separately, so that exceptions can be handled properly.
Note: this method should not be used for file-locking, as the resulting protocol cannot be made to work reliably. The {@link java.nio.channels.FileLock FileLock} facility should be used instead.
A subclass should therefore use the object in this field rather than this or a synchronized method.
A subclass should therefore use the object in this field rather than this or a synchronized method.
Note: this method should not be used for file-locking, as the resulting protocol cannot be made to work reliably. The {@link java.nio.channels.FileLock FileLock} facility should be used instead.
The {@linkplain java.nio.charset.CharsetDecoder} class should be used when more control over the decoding process is required.
The {@link PrintWriter} class should be used in situations that require writing characters rather than bytes.
The {@link java.nio.charset.CharsetDecoder} class should be used when more control over the decoding process is required.
. The {@linkplain java.nio.charset.CharsetEncoder} class should be used when more control over the encoding process is required.
Security note: If an application needs to read a password or other secure data, it should use {@link #readPassword()} or {@link #readPassword(String, Object...)} and manually zero the returned character array after processing to minimize the lifetime of sensitive data in memory.
Subclassers should call setShellStyle to change this value, rather than overriding this method.
Standard customers should not overwrite this method but {@link #getValue(Object)}
Standard customers should not overwrite this method but {@link #setValue(Object, Object)}
Instead of overwriting this method subclasses should overwrite {@link #createViewerToolTipContentArea(Event, ViewerCell, Composite)}
Inheritable thread-local variables are used in preference to ordinary thread-local variables when the per-thread-attribute being maintained in the variable (e.g., User ID, Transaction ID) must be automatically transmitted to any child threads that are created.
Applications should solely rely on the implies method to perform policy checks.
If an application absolutely must call a getPermissions method, it should call getPermissions(ProtectionDomain).
An application can call {@link #PKIXParameters(Set) PKIXParameters(Set)}, specifying a Set of TrustAnchor objects, each of which identify a most-trusted CA. Alternatively, an application can call {@link #PKIXParameters(KeyStore) PKIXParameters(KeyStore)}, specifying a KeyStore instance containing trusted certificate entries, each of which will be considered as a most-trusted CA.
Use of this method is discouraged; use {@link java.util.TimeZone#getDisplayName() TimeZone.getDisplayName()} instead
This constructor is protected because most users should use a CertificateFactory to create CertPaths.
Denigrated, use {@linkplain #setSubject(X500Principal)} or {@linkplain #setSubject(byte[])} instead. This method should not be relied on as it can fail to match some certificates because of a loss of encoding information in the RFC 2253 String form of some distinguished names.
This interface is used only for computations that throw checked exceptions; computations that do not throw checked exceptions should use PrivilegedAction instead.
Denigrated, replaced by {@linkplain #getSubjectX500Principal()}. This method returns the subject as an implementation specific Principal object, which should not be relied upon by portable code.
Denigrated, use {@linkplain #getIssuer()} or {@linkplain #getIssuerAsBytes()} instead. This method should not be relied on as it can fail to match some certificates because of a loss of encoding information in the RFC 2253 String form of some distinguished names.
Denigrated, use {@linkplain #getSubject()} or {@linkplain #getSubjectAsBytes()} instead. This method should not be relied on as it can fail to match some certificates because of a loss of encoding information in the RFC 2253 String form of some distinguished names.
No standard string format is defined for otherNames, X.400 names, EDI party names, IPv6 address names, or any other type of names. They should be specified using the {@link #addSubjectAlternativeName(int type, byte [] name) addSubjectAlternativeName(int type, byte [] name)} method.
No standard string format is defined for otherNames, X.400 names, EDI party names, IPv6 address names, or any other type of names. They should be specified using the {@link #addPathToName(int type, byte [] name) addPathToName(int type, byte [] name)} method.
for distinguished names, use {@linkplain #addPathToName(int, byte[])} instead. This method should not be relied on as it can fail to match some certificates because of a loss of encoding information in the RFC 2253 String form of some distinguished names.
Denigrated, replaced by {@linkplain #getIssuerX500Principal()}. This method returns the issuer as an implementation specific Principal object, which should not be relied upon by portable code.
Denigrated, use {@linkplain #addIssuer(X500Principal)} or {@linkplain #addIssuerName(byte[])} instead. This method should not be relied on as it can fail to match some CRLs because of a loss of encoding information in the RFC 2253 String form of some distinguished names.
Denigrated, replaced by {@linkplain #getIssuerX500Principal()}. This method returns the issuer as an implementation specific Principal object, which should not be relied upon by portable code.
In general, instances of this class should only be accessed through the CertStore class.
The getLogWriter and setLogWriter methods should be used instead of the get/setlogStream methods, which are deprecated.
This constant remains only for compatibility reasons. Developers should use the constant sqlStateSQL instead.
If arbitrary parameter type conversions are required, the method setObject should be used with a target SQL type.
Not all databases allow for a non-typed Null to be sent to the backend. For maximum portability, the setNull or the setObject(int parameterIndex, Object x, int sqlType) method should be used instead of setObject(int parameterIndex, Object x).
Not all databases allow for a non-typed Null to be sent to the backend. For maximum portability, the setNull or the setObject(String parameterName, Object x, int sqlType) method should be used instead of setObject(String parameterName, Object x).
When configuring a Connection, JDBC applications should use the appropritate Connection method such as setAutoCommit or setTransactionIsolation. Applications should not invoke SQL commands directly to change the connection's configuration when there is a JDBC method available.
Clients should subclass AbstractConcurrentModel instead.
Subclasses do not typically override this method, but implement getSelectionFromWidget(List) instead.
Viewers who are not subclasses of {@link ColumnViewer} should consider using a widget relative implementation like {@link ColumnViewer#getItemAt(org.eclipse.swt.graphics.Point)}.
Subclasses do not typically override this method, but implement setSelectionToWidget(List, boolean) instead.
The {@link java.nio.charset.CharsetEncoder} class should be used when more control over the encoding process is required.
If a new Short instance is not required, this method should generally be used in preference to the constructor {@link #Short(short)}, as this method is likely to yield significantly better space and time performance by caching frequently requested values.
If a new Long instance is not required, this method should generally be used in preference to the constructor {@link #Long(long)}, as this method is likely to yield significantly better space and time performance by caching frequently requested values.
If a new Integer instance is not required, this method should generally be used in preference to the constructor {@link #Integer(int)}, as this method is likely to yield significantly better space and time performance by caching frequently requested values.
If a new Float instance is not required, this method should generally be used in preference to the constructor {@link #Float(float)}, as this method is likely to yield significantly better space and time performance by caching frequently requested values.
Most programmers should use the {@link #toString} method in preference to this one, as the toString method may return a more user-friendly name.
If a new Double instance is not required, this method should generally be used in preference to the constructor {@link #Double(double)}, as this method is likely to yield significantly better space and time performance by caching frequently requested values.
If a new Character instance is not required, this method should generally be used in preference to the constructor {@link #Character(char)}, as this method is likely to yield significantly better space and time performance by caching frequently requested values.
If a new Byte instance is not required, this method should generally be used in preference to the constructor {@link #Byte(byte)}, as this method is likely to yield significantly better space and time performance by caching frequently requested values.
In most cases, the Runnable interface should be used if you are only planning to override the run() method and no other Thread methods.
The {@link java.nio.charset.CharsetEncoder} class should be used when more control over the encoding process is required.
The {@link java.nio.charset.CharsetEncoder} class should be used when more control over the encoding process is required.
The {@link java.nio.charset.CharsetDecoder} class should be used when more control over the decoding process is required.
The {@link java.nio.charset.CharsetDecoder} class should be used when more control over the decoding process is required.
If a new Boolean instance is not required, this method should generally be used in preference to the constructor {@link #Boolean(boolean)}, as this method is likely to yield significantly better space and time performance.
An application might use the activeCount method to get an estimate of how big the array should be,
An application might use the activeCount method to get an estimate of how big the array should be
In order to provide backward compatibility for clients of ITextViewer, extension interfaces are used as a means of evolution. The following extension interfaces exist: * {@link org.eclipse.jface.text.ITextViewerExtension} since version 2.0 replacing the event consumer mechanism and introducing the concept of rewrite targets and means to manage the viewer's redraw behavior * {@link org.eclipse.jface.text.ITextViewerExtension2}since version 2.1 adding a way to invalidate a viewer's presentation and setters for hovers. * {@link org.eclipse.jface.text.ITextViewerExtension3} since version 2.1 which itself was replaced by {@link org.eclipse.jface.text.ITextViewerExtension5} in version 3.0 * {@link org.eclipse.jface.text.ITextViewerExtension4} since version 3.0 introducing focus handling for widget token keepers and the concept of text presentation listeners. * {@link org.eclipse.jface.text.ITextViewerExtension5} since version 3.0 extending the visible region concept with explicit handling and conversion of widget and model coordinates. * {@link org.eclipse.jface.text.ITextViewerExtension6} since version 3.1 extending the text viewer with the ability to detect hyperlinks and access the undo manager. * {@link org.eclipse.jface.text.ITextViewerExtension7} since version 3.3 extending the text viewer with the ability to install tabs to spaces conversion. * {@link org.eclipse.jface.text.ITextViewerExtension8} since version 3.4 extending the text viewer with the ability to print and rich hover support.
Clients may use the standard implementation {@link org.eclipse.jface.text.TextViewer}.
An application might use the activeGroupCount method to get an estimate of how big the array should be, however if the array is too short to hold all the thread groups, the extra thread groups are silently ignored.
An application might use the activeGroupCount method to get an estimate of how big the array should be, however if the array is too short to hold all the thread groups, the extra thread groups are silently ignored.
The {@link java.nio.charset.CharsetDecoder} class should be used when more control over the decoding process is required.
The {@link java.nio.charset.CharsetDecoder} class should be used when more control over the decoding process is required.
The {@link java.nio.charset.CharsetDecoder} class should be used when more control over the decoding process is required.
The {@link java.nio.charset.CharsetDecoder} class should be used when more control over the decoding process is required.
@deprecated use StyledText.invokeAction instead
This method is no longer called by the framework and clients should overwrite {@link #apply(ITextViewer, char, int, int)} instead
This method is no longer called by the framework and clients should overwrite {@link #apply(ITextViewer, char, int, int)} instead
Overriding createDialogArea and (optionally) createTitleMenuArea and createTitleMenuArea are recommended rather than overriding this method.
Implementors must either use the dialog font or override {@link #computeSizeConstraints(int, int)}.
Subclasses should override this method rather than {@link #focusCellChanged(ViewerCell)}
. The modifiers consist of the Java Virtual Machine's constants for public, protected, private, final, static, abstract and interface; they should be decoded using the methods of class Modifier.
In general, {@link java.lang.String#toLowerCase()} should be used to map characters to lowercase.
In general, {@link java.lang.String#toLowerCase()} should be used to map characters to lowercase.
In general, {@link java.lang.String#toUpperCase()} should be used to map characters to uppercase.

To find deadlocks involving both object monitors and ownable synchronizers, the {@link #findDeadlockedThreads findDeadlockedThreads} method should be used.
User code should use the methods of class Array to manipulate arrays.
In general, {@link java.lang.String#toUpperCase()} should be used to map characters to uppercase.
Where the existing class file bytes are to be transformed (for example in bytecode instrumentation) {@link #retransformClasses retransformClasses} should be used.
. The StringBuilder class should generally be used in preference to this one, as it supports all of the same operations but it is faster, as it performs no synchronization.
Sometimes a security check that should be made within a given context will actually need to be done from within a different context (for example, from within a worker thread). The {@link SecurityManager#getSecurityContext getSecurityContext} method and the {@link SecurityManager#checkPermission(java.security.Permission, java.lang.Object) checkPermission} method that includes a context argument are provided for this situation.
Completion proposals can implement {@link ICompletionProposalExtension6} to provide colored proposal labels.
Completion proposals can implement {@link ICompletionProposalExtension6} to provide colored proposal labels.
By default, clients use ContentFormatter or MultiPassContentFormatter as the standard implementers of this interface.
Please use {@link org.eclipse.core.runtime.ListenerList} instead.
Also note that the equivalent of {@link #ListenerList()} is actually {@link org.eclipse.core.runtime.ListenerList#ListenerList(int)} with {@link org.eclipse.core.runtime.ListenerList#IDENTITY} as the argument.
Content providers for tree viewers must implement either the {@link ITreeContentProvider} interface, (as of 3.2) the {@link ILazyTreeContentProvider} interface, or (as of 3.3) the {@link ILazyTreePathContentProvider}.
Label providers for table viewers must implement either the ITableLabelProvider or the ILabelProvider interface (see TableViewer.setLabelProvider for more details).
Label providers for table tree viewers must implement either the ITableLabelProvider or the ILabelProvider interface (see TableTreeViewer.setLabelProvider for more details).
Since this implementation does not support add() or remove(), set() may be called as often as desired.
Since this implementation does not support add() or remove(), set() may be called as often as desired.
The {@link org.apache.commons.collections.set.ListOrderedSet ListOrderedSet} class provides an alternative approach, by wrapping an existing Set and retaining insertion order in the iterator.
An alternative to this method is to use the better named {@link #keyList()} or {@link #keySet()}.
A Map implementation that is a general purpose alternative to HashMap.This implementation improves on the JDK1.4 HashMap by adding the {@link org.apache.commons.collections.MapIterator MapIterator} functionality and many methods for subclassing.
An alternative to this method is to use {@link #keySet()}.
This method is an alternative to the {@link java.util.Map#putAll(java.util.Map)} method and constructors. It allows you to build a map from an object array of various possible styles.
This map is designed for performance and can outstrip HashMap. It also has good garbage collection characteristics. * Optimised for operation at size 3 or less. * Still works well once size 3 exceeded. * Gets at size 3 or less are about 0-10% faster than HashMap, * Puts at size 3 or less are over 4 times faster than HashMap. * Performance 5% slower than HashMap once size 3 exceeded once.
The simplest approach is to wrap this map using {@link java.util.Collections#synchronizedMap(Map)}.
Note that PredicatedSortedMap is not synchronized and is not thread-safe. If you wish to use this map from multiple threads concurrently, you must use appropriate synchronization. The simplest approach is to wrap this map using {@link java.util.Collections#synchronizedSortedMap}.
Note that TransformedMap is not synchronized and is not thread-safe. If you wish to use this map from multiple threads concurrently, you must use appropriate synchronization. The simplest approach is to wrap this map using {@link java.util.Collections#synchronizedMap(Map)}.
Note that LazyMap is not synchronized and is not thread-safe. If you wish to use this map from multiple threads concurrently, you must use appropriate synchronization. The simplest approach is to wrap this map using {@link java.util.Collections#synchronizedMap(Map)}.
Note that FixedSizeSortedMap is not synchronized and is not thread-safe. If you wish to use this map from multiple threads concurrently, you must use appropriate synchronization. The simplest approach is to wrap this map using {@link java.util.Collections#synchronizedSortedMap}.
Note that ReferenceIdentityMap is not synchronized and is not thread-safe. If you wish to use this map from multiple threads concurrently, you must use appropriate synchronization. The simplest approach is to wrap this map using {@link java.util.Collections#synchronizedMap}.
Note that TransformedSortedMap is not synchronized and is not thread-safe. If you wish to use this map from multiple threads concurrently, you must use appropriate synchronization. The simplest approach is to wrap this map using {@link java.util.Collections#synchronizedSortedMap}.
Note that LazySortedMap is not synchronized and is not thread-safe. If you wish to use this map from multiple threads concurrently, you must use appropriate synchronization. The simplest approach is to wrap this map using {@link java.util.Collections#synchronizedSortedMap}.
Note that ReferenceMap is not synchronized and is not thread-safe. If you wish to use this map from multiple threads concurrently, you must use appropriate synchronization. The simplest approach is to wrap this map using {@link java.util.Collections#synchronizedMap}.
Note that HashedMap is not synchronized and is not thread-safe. If you wish to use this map from multiple threads concurrently, you must use appropriate synchronization. The simplest approach is to wrap this map using {@link java.util.Collections#synchronizedMap(Map)}.
Note that CaseInsensitiveMap is not synchronized and is not thread-safe. If you wish to use this map from multiple threads concurrently, you must use appropriate synchronization. The simplest approach is to wrap this map using {@link java.util.Collections#synchronizedMap(Map)}.
Note that IdentityMap is not synchronized and is not thread-safe. If you wish to use this map from multiple threads concurrently, you must use appropriate synchronization. The simplest approach is to wrap this map using {@link java.util.Collections#synchronizedMap(Map)}.
Note that ListOrderedMap is not synchronized and is not thread-safe. If you wish to use this map from multiple threads concurrently, you must use appropriate synchronization. The simplest approach is to wrap this map using {@link java.util.Collections#synchronizedMap(Map)}.
Note that Flat3Map is not synchronized and is not thread-safe. If you wish to use this map from multiple threads concurrently, you must use appropriate synchronization. The simplest approach is to wrap this map using {@link java.util.Collections#synchronizedMap(Map)}.
Note that LinkedMap is not synchronized and is not thread-safe. If you wish to use this map from multiple threads concurrently, you must use appropriate synchronization. The simplest approach is to wrap this map using {@link java.util.Collections#synchronizedMap(Map)}.
Note that PredicatedMap is not synchronized and is not thread-safe. If you wish to use this map from multiple threads concurrently, you must use appropriate synchronization. The simplest approach is to wrap this map using {@link java.util.Collections#synchronizedMap(Map)}.
Note that CompositeMap is not synchronized and is not thread-safe. If you wish to use this map from multiple threads concurrently, you must use appropriate synchronization. The simplest approach is to wrap this map using {@link java.util.Collections#synchronizedMap(Map)}.
Note that LRUMap is not synchronized and is not thread-safe. If you wish to use this map from multiple threads concurrently, you must use appropriate synchronization. The simplest approach is to wrap this map using {@link java.util.Collections#synchronizedMap(Map)}.
Note that TransformedMap is not synchronized and is not thread-safe. If you wish to use this map from multiple threads concurrently, you must use appropriate synchronization. The simplest approach is to wrap this map using {@link java.util.Collections#synchronizedMap(Map)}.
slow
This list implementation utilises a tree structure internally to ensure that all insertions and removals are O(log n). This provides much faster performance than both an ArrayList and a LinkedList where elements are inserted and removed repeatedly from anywhere in the list.
ArrayList is a good general purpose list implementation. It is faster than TreeList for most operations except inserting and removing in the middle of the list. ArrayList also uses less memory as TreeList uses one object per entry.
If you know that you have an object array, the {@link org.apache.commons.collections.iterators.ObjectArrayIterator ObjectArrayIterator} class is a better choice, as it will perform better.
If you know that you have an object array, the {@link ObjectArrayListIterator} class is a better choice, as it will perform better.
Under many circumstances, linking Iterators together in this manner is more efficient (and convenient) than reading out the contents of each Iterator into a List and creating a new Iterator.
Under many circumstances, linking Iterators together in this manner is more efficient (and convenient) than using nested for loops to extract a list.
This iterator is a special version designed for maps. It can be more efficient to use this rather than an entry set iterator where the option is available, and it is certainly more convenient.
A map iterator is an efficient way of iterating over maps. There is no need to access the entry set or use Map Entry objects.
A map iterator is an efficient way of iterating over maps. There is no need to access the entry set or use Map Entry objects.
Under many circumstances, linking Iterators together in this manner is more efficient (and convenient) than using nested for loops to extract a list.
Because a Locale object is just an identifier for a region, no validity check is performed when you construct a Locale. If you want to see whether particular resources are available for the Locale you construct, you must query those resources.
The following can be used to provide synchronized access to your BoundedFifoBuffer: Buffer fifo = BufferUtils.synchronizedBuffer(new BoundedFifoBuffer());
The following can be used to provide synchronized access to your CircularFifoBuffer: Buffer fifo = BufferUtils.synchronizedBuffer(new CircularFifoBuffer());
Note that this method can be used to circumvent the map's value type at runtime.
Note that IdentityMap and ReferenceIdentityMap are unsuitable for use as the key comparison would work on the whole MultiKey, not the elements within.
Use {@link org.apache.commons.collections.BufferUtils#synchronizedBuffer(Buffer)} or {@link org.apache.commons.collections.buffer.SynchronizedBuffer#decorate(Buffer)} to provide synchronized access to a PriorityBuffer:
. You can use {@link java.util.Collections#synchronizedMap} to provide synchronized access to a ReferenceIdentityMap.
WARNING: This method is binary incompatible with Commons Collections 2.1 and 2.1.1. Use EmptyIterator.INSTANCE for compatability with Commons Collections 2.1.1.
WARNING: This method is binary incompatible with Commons Collections 2.1 and 2.1.1. Use EmptyListIterator.INSTANCE for compatability with Commons Collections 2.1.1.
WARNING: This method is binary incompatible with Commons Collections 2.1 and 2.1.1. Use new SingletonIterator(object) for compatability.
WARNING: This method is binary incompatible with Commons Collections 2.1 and 2.1.1. Use new ArrayIterator(array) for compatability.
WARNING: This method is binary incompatible with Commons Collections 2.1 and 2.1.1. Use new ArrayIterator(array,start) for compatability.
WARNING: This method is binary incompatible with Commons Collections 2.1 and 2.1.1. Use new ArrayIterator(array,start,end) for compatability.
WARNING: This constant is binary incompatible with Commons Collections 2.1 and 2.1.1. Use EmptyIterator.INSTANCE for compatability with Commons Collections 2.1.1.
WARNING: This constant is binary incompatible with Commons Collections 2.1 and 2.1.1. Use EmptyListIterator.INSTANCE for compatability with Commons Collections 2.1.1.
In previous versions of this class, it was mandatory to close all cursor objects to avoid memory leaks. It is no longer necessary to call this close method; an instance of this class can now be treated exactly like a normal iterator.
If you subclass AbstractLinkedMap but not LinkEntry then you will not be able to access the protected fields. The entryXxx() methods on AbstractLinkedMap exist to provide the necessary access.
If you subclass AbstractHashedMap but not HashEntry then you will not be able to access the protected fields. The entryXxx() methods on AbstractHashedMap exist to provide the necessary access.
In addition, this implementation allows the type of collection used for the values to be controlled. By default, an ArrayList is used, however a Class to instantiate may be specified, or a factory that returns a Collection instance.
Although this can be used to reset iteration, the {@link #reset()} method is a more effective choice.
If the last value for a key is removed, implementations typically return null from a subsequant get(Object), however they may choose to return an empty collection.
Implementations typically return null if no values have been mapped to the key, however the implementation may choose to return an empty collection.
@return the Collection of values, implementations should return null for no mapping, but may return an empty collection
Implementations typically return null from a subsequant get(Object), however they may choose to return an empty collection.
@return the Collection of values removed, implementations should return null for no mapping found, but may return an empty collection
For random access data (such as an array), AbstractList should be used in preference to this class.
Like most collection implementations, EnumSet is not synchronized. If multiple threads access an enum set concurrently, and at least one of the threads modifies the set, it should be synchronized externally. This is typically accomplished by synchronizing on some object that naturally encapsulates the enum set. If no such object exists, the set should be wrapped using the {@link Collections#synchronizedSet} method.
If multiple threads access a tree set concurrently, and at least one of the threads modifies the set, it must be synchronized externally. This is typically accomplished by synchronizing on some object that naturally encapsulates the set. If no such object exists, the set should be wrapped using the {@link Collections#synchronizedSortedSet Collections.synchronizedSortedSet} method.
Note: This class should only be used if you need to add bounded behaviour to another buffer. If you just want a bounded buffer then you should use {@link BoundedFifoBuffer} or {@link CircularFifoBuffer}
The following extension interface exists: {@link org.eclipse.jface.text.presentation.IPresentationReconcilerExtension} since version 3.0 adding support for documents with multiple partitionings.
The following extension interfaces exist: {@link org.eclipse.jface.text.source.IVerticalRulerInfoExtension} since version 3.0 allowing custom annotation hovers and specific annotation models.
The following extension interfaces exist: {@link org.eclipse.jface.text.IUndoManagerExtension} since version 3.1 introducing access to the undo context.
The following extension interfaces exist: {@link IRevisionRulerColumnExtension} since version 3.3 allowing to register a selection listener on revisions and a configurable rendering mode.
The following extension interfaces exist: {@link org.eclipse.jface.text.source.IVerticalRulerExtension} since version 2.0 introducing setters for font and mouse button activity location.
The following extension interfaces exist: {@link org.eclipse.jface.text.source.ISourceViewerExtension} since version 2.1 introducing the concept of an annotation overview. {@link org.eclipse.jface.text.source.ISourceViewerExtension2} since version 3.0 allowing source viewers to roll back a previously performed configuration and allows access to the viewer's visual annotation model. {@link org.eclipse.jface.text.source.ISourceViewerExtension3} since version 3.2 introducing the concept of a quick assist assistant and providing access to the quick assist invocation context as well as the current annotation hover. {@link org.eclipse.jface.text.source.ISourceViewerExtension4} since version 3.4 introducing API to access a minimal set of content assistant APIs.
The following extension interfaces exist: {@link org.eclipse.jface.text.IWidgetTokenKeeperExtension} since version 3.0 introducing priorities when requesting a widget token and thus replacing the non-prioritized scheme. It also allows a client to force a widget token keeper to accept focus.
The following extension interfaces exist: {@link org.eclipse.jface.text.ITextOperationTargetExtension} since version 2.0 introducing text operation enabling/disabling.
This method has been replaced by {@link ITextViewerExtension2#prependAutoEditStrategy(IAutoEditStrategy, String)} and {@link ITextViewerExtension2#removeAutoEditStrategy(IAutoEditStrategy, String)}.
This method has been replaced by {@link ITextViewerExtension2#setTextHover(ITextHover, String, int)}.
In order to load templates contributed using the org.eclipse.ui.editors.templates extension point, use a ContributionTemplateStore.
The following extension interfaces exist: {@link org.eclipse.jface.text.IWidgetTokenOwnerExtension} since version 3.0 introducing priorities when requesting a widget token and thus replacing the non-prioritized scheme.
The following extension interfaces exist: {@link org.eclipse.jface.text.IInformationControlCreatorExtension} since version 3.0 introducing checks of whether existing information control can be reused and whether information control creators can replace each other.
. New users of this class should use isEmpty instead.
Should be accessed through {@link #getLastNodeReturned()} to enforce this behaviour.
Programmers do not normally create ManagementPermission objects directly. Instead they are created by the security policy code based on reading the security policy file.
Use {@link #allPredicateinstead
Instances of StringBuilder are not safe for use by multiple threads. If such synchronization is required then it is recommended that {@link java.lang.StringBuffer} be used.
Unless a new instance is required, the static factory {@link #valueOf(boolean)} is generally a better choice.
If the object has a custom mapping (is of a class implementing the interface SQLData), the JDBC driver should call the method SQLData.writeSQL to write it to the SQL data stream. If, on the other hand, the object is of a class implementing Ref, Blob, Clob, NClob, Struct, java.net.URL, or Array, the driver should pass it to the database as a value of the corresponding SQL type.
If the object has a custom mapping (is of a class implementing the interface SQLData), the JDBC driver should call the method SQLData.writeSQL to write it to the SQL data stream. If, on the other hand, the object is of a class implementing Ref, Blob, Clob, NClob, Struct, java.net.URL, or Array, the driver should pass it to the database as a value of the corresponding SQL type.
If the object is of a class implementing the interface SQLData, the JDBC driver should call the method SQLData.writeSQL to write it to the SQL data stream. If, on the other hand, the object is of a class implementing Ref, Blob, Clob, NClob, Struct, java.net.URL, or Array, the driver should pass it to the database as a value of the corresponding SQL type.
Note that the current contents of the MemoryHandler buffer are not written out. That requires a push.
Like the {@link #matches matches} method, this method always starts at the beginning of the region; unlike that method, it does not require that the entire region be matched.
Unless prompt output is required, it is advisable to wrap a BufferedWriter around any Writer whose write() operations may be costly, such as FileWriters and OutputStreamWriters.
If a lookup of the name service is required, call {@link #getCanonicalHostName() getCanonicalHostName}.
Standard implementations of common closures are provided by {@link ClosureUtils}. These include method invokation and for/while loops.
Standard implementations of common predicates are provided by {@link PredicateUtils}. These include true, false, instanceof, equals, and, or, not, method invokation and null testing.
If no such object exists, the map should be wrapped using the {@link Collections#synchronizedSortedMap Collections.synchronizedSortedMap} method.
If no such object exists, the list should be wrapped using the {@link Collections#synchronizedList Collections.synchronizedList} method.
When threads must repeatedly count down in this way, instead use a {@link CyclicBarrier}.
Events are not generated when indirect descendants of this node are added or removed; a caller desiring such events must register with each descendant.
If these requirements cannot be met, consider instead subclassing {@link AbstractCollection}.
If you would like to ensure that unreferenced pools are reclaimed even if users forget to call {@link ThreadPoolExecutor#shutdown}, then you must arrange that unused threads eventually die, by setting appropriate keep-alive times, using a lower bound of zero core threads and/or setting {@link ThreadPoolExecutor#allowCoreThreadTimeOut(boolean)}.
If {@link ICompletionProposalExtension5} is implemented, this method should not be called any longer.
In case the client does not explicitly initialize the AlgorithmParameterGenerator (via a call to an engineInit method), each provider must supply (and document) a default initialization.
In case the client does not explicitly initialize the AlgorithmParameterGenerator (via a call to an init method), each provider must supply (and document) a default initialization.
In case the client does not explicitly initialize the KeyPairGenerator (via a call to an initialize method), each provider must supply (and document) a default initialization.
Images allocated in this manner must be disposed by {@link #destroyImage(ImageDescriptor)}, and never by calling {@link Image#dispose()}.
Any color allocated in this manner must be disposed by calling {@link #destroyColor(RGB)}, or by an eventual call to {@link #dispose()}. {@link Color#dispose()} must never been called directly on the returned color.
When a very large ASCII value is input to a LONGVARCHAR parameter, it may be more practical to send it via a java.io.InputStream.
This selection should be used instead of null.
Clients should handle labelProviderChangedEvents for the given element to get the complete decoration.
Add operations require the use of a pluggable strategy. If no strategy is provided then add is unsupported.
Add and remove operations require the use of a pluggable strategy. If no strategy is provided then add and remove are unsupported.
These formatting strategies are required to handle the position updating of the document. To facilitate the work with these text edit based formatting strategies, a default implementation called ContextBasedFormattingStrategy is provided.
This method should no longer be used for actions in the Eclipse workbench. IWorkbenchCommandSupport and IWorkbenchContextSupport provide all the functionality required for key bindings.
The required FontMetrics parameter may be created in the following way: GC gc = new GC(control); gc.setFont(control.getFont()); fontMetrics = gc.getFontMetrics(); gc.dispose();
The required FontMetrics parameter may be created in the following way: GC gc = new GC(control); gc.setFont(control.getFont()); fontMetrics = gc.getFontMetrics(); gc.dispose();
The required FontMetrics parameter may be created in the following way: GC gc = new GC(control); gc.setFont(control.getFont()); fontMetrics = gc.getFontMetrics(); gc.dispose();
The required FontMetrics parameter may be created in the following way: GC gc = new GC(control); gc.setFont(control.getFont()); fontMetrics = gc.getFontMetrics(); gc.dispose();
Specifying which properties are affected may allow the viewer to optimize the update. For example, if the label provider is not affected by changes to any of these properties, an update may not actually be required.
It is recommended that clients do not implement this interface but instead use the standard implementation of this interface, {@link TreeSelection}.
The default is false for backwards compatibility, but the recommended practice is to specify true, and specify the desired width for the content of the column, rather than adding a fudge factor to the specified width.
It is recommended to use setComparator() instead.
It is recommended to use getComparator() instead.
It is recommended that getFontDataArray is used instead.
This is not recommended and is included for backwards compatability. It is recommended to use the default font provided by SWT (that is, do not set the font).
@deprecated as this method only checks or unchecks visible items is is recommended that {@link #setSubtreeChecked(Object, boolean)} is used instead.
If the caller adds its own columns, uses Table.setHeadersVisible(true), or needs to handle dynamic resizing of the table, it is recommended to create the Table itself, specifying the SWT.CHECK style bit (along with any other style bits needed), and use new CheckboxTableViewer(Table) rather than this constructor.
This method is provided for backwards compatibility. It is recommended that getDefaultFontDataArray is used instead.
@deprecated This type of security checking is not recommended. It is recommended that the checkPermission call be used instead.
The results of this constructor can be somewhat unpredictable and its use is generally not recommended; see the notes under the {@link #BigDecimal(double)} constructor.
This type of security checking is not recommended. It is recommended that the checkPermission call be used instead.
It is recommended that the {@link #probablePrime probablePrime} method be used in preference to this constructor unless there is a compelling need to specify a certainty.
@deprecated This type of security checking is not recommended. It is recommended that the checkPermission call be used instead.
@deprecated This type of security checking is not recommended. It is recommended that the checkPermission call be used instead.
@deprecated This type of security checking is not recommended. It is recommended that the checkPermission call be used instead.
@deprecated This type of security checking is not recommended. It is recommended that the checkPermission call be used instead.
@deprecated This type of security checking is not recommended. It is recommended that the checkPermission call be used instead.
@deprecated This method does not automatically escape characters that are illegal in URLs. It is recommended that new code convert an abstract pathname into a URL by first converting it into a URI, via the {@link #toURI() toURI} method, and then converting the URI into a URL via the {@link java.net.URI#toURL() URI.toURL} method.
StringTokenizer is a legacy class that is retained for compatibility reasons although its use is discouraged in new code. It is recommended that anyone seeking this functionality use the split method of String or the java.util.regex package instead.
Overloadings of this method exist to initialize an enum set with one through five elements. A sixth overloading is provided that uses the varargs feature. This overloading may be used to create an enum set initially containing an arbitrary number of elements, but is likely to run slower than the overloadings that do not use varargs.
Overloadings of this method exist to initialize an enum set with one through five elements. A sixth overloading is provided that uses the varargs feature. This overloading may be used to create an enum set initially containing an arbitrary number of elements, but is likely to run slower than the overloadings that do not use varargs.
The hash code of an array member-value is computed by calling the appropriate overloading of {@link java.util.Arrays#hashCode(long[]) Arrays.hashCode} on the value. (There is one overloading for each primitive type, and one for object reference types.)
Overloadings of this method exist to initialize an enum set with one through five elements. A sixth overloading is provided that uses the varargs feature. This overloading may be used to create an enum set initially containing an arbitrary number of elements, but is likely to run slower than the overloadings that do not use varargs.
Overloadings of this method exist to initialize an enum set with one through five elements. A sixth overloading is provided that uses the varargs feature. This overloading may be used to create an enum set initially containing an arbitrary number of elements, but is likely to run slower than the overloadings that do not use varargs.
This factory, whose parameter list uses the varargs feature, may be used to create an enum set initially containing an arbitrary number of elements, but it is likely to run slower than the overloadings that do not use varargs.
Overloadings of this method exist to initialize an enum set with one through five elements. A sixth overloading is provided that uses the varargs feature. This overloading may be used to create an enum set initially containing an arbitrary number of elements, but is likely to run slower than the overloadings that do not use varargs.
Consult your JDBC driver documentation to determine if it might be more efficient to use a version of updateNCharacterStream which takes a length parameter.
Consult your JDBC driver documentation to determine if it might be more efficient to use a version of updateAsciiStream which takes a length parameter.
Consult your JDBC driver documentation to determine if it might be more efficient to use a version of setBinaryStream which takes a length parameter.
Consult your JDBC driver documentation to determine if it might be more efficient to use a version of setNCharacterStream which takes a length parameter.
Consult your JDBC driver documentation to determine if it might be more efficient to use a version of updateCharacterStream which takes a length parameter.
If a pattern is to be used multiple times, compiling it once and reusing it will be more efficient than invoking this method each time.
Consult your JDBC driver documentation to determine if it might be more efficient to use a version of updateBinaryStream which takes a length parameter.
Consult your JDBC driver documentation to determine if it might be more efficient to use a version of updateAsciiStream which takes a length parameter.
Consult your JDBC driver documentation to determine if it might be more efficient to use a version of updateBlob which takes a length parameter.
It may be more efficient to read the Pack200 archive to a file and pass the File object, using the alternate method described below.
Consult your JDBC driver documentation to determine if it might be more efficient to use a version of updateBinaryStream which takes a length parameter.
Consult your JDBC driver documentation to determine if it might be more efficient to use a version of updateClob which takes a length parameter.
Consult your JDBC driver documentation to determine if it might be more efficient to use a version of setCharacterStream which takes a length parameter.
Consult your JDBC driver documentation to determine if it might be more efficient to use a version of setAsciiStream which takes a length parameter.
Consult your JDBC driver documentation to determine if it might be more efficient to use a version of updateBlob which takes a length parameter.
Consult your JDBC driver documentation to determine if it might be more efficient to use a version of updateNClob which takes a length parameter.
Note that there is another method for efficiently processing the simultaneous addition of multiple elements.
Note that the preferred way of re-initializing a preference to its default value is to call setToDefault.
Note that there is another method for efficiently processing the simultaneous removal of multiple elements.
Note that this method is not used when drawing annotations on the editor's text widget. This is handled trough a {@link org.eclipse.jface.text.source.AnnotationPainter.IDrawingStrategy}.
@deprecated Use {@link #allPredicate(Predicate<? super T>...)} instead
This method is only included for backwards compatibility. The caller is encouraged to use one of the alternative getInstance methods to obtain a SecureRandom object, and then call the generateSeed method to obtain seed bytes from that object.
Subclasses of ClassLoader are encouraged to override {@link #findClass(String)}, rather than this method.
Typically you shouldn't use DateFormatSymbols directly. Rather, you are encouraged to create a date-time formatter with the DateFormat class's factory methods: getTimeInstance, getDateInstance, or getDateTimeInstance.
Clients are encouraged to supply their own disabled/grayed/etc. images rather than using a default image and transforming it.
Clients are encouraged to use create/destroyResource and downcast the result to Image rather than using createImage.
Developers are encouraged to use the comparator returned from this method instead of constructing a new instance to reduce allocation and GC overhead when multiple comparable comparators may be used in the same VM.
Clients are encouraged to use the value returned from this method instead of constructing a new instance to reduce allocation and garbage collection overhead when multiple BooleanComparators may be used in the same virtual machine.
Clients are encouraged to use the value returned from this method instead of constructing a new instance to reduce allocation and garbage collection overhead when multiple BooleanComparators may be used in the same virtual machine.
Clients are encouraged to use the value returned from this method instead of constructing a new instance to reduce allocation and garbage collection overhead when multiple BooleanComparators may be used in the same virtual machine.
NOTE #updateElement(int index) can be used to determine selection values.
Note that there is another method for efficiently processing the simultaneous removal of multiple elements.
Note that there is another method for efficiently processing the simultaneous addition of multiple elements.
This {@literal static factory method} is provided in preference to a ({ long}, { int}) constructor because it allows for reuse of frequently used { BigDecimal} values.
The three forms of { park} each also support a { blocker} object parameter. This object is recorded while the thread is blocked to permit monitoring and diagnostic tools to identify the reasons that threads are blocked. (Such tools may access blockers using method {@link #getBlocker}.) The use of these forms rather than the original forms without this parameter is strongly encouraged. The normal argument to supply as a { blocker} within a lock implementation is { this}.
SimpleDateFormat allows you to start by choosing any user-defined patterns for date-time formatting. However, you are encouraged to create a date-time formatter with either getTimeInstance, getDateInstance, or getDateTimeInstance in DateFormat.
If only the given element needs updating, it is more efficient to use the update methods.
. Note that there is another method for efficiently processing the simultaneous removal of multiple elements.
The statement boolean b = Pattern.matches(a*b, aaaaab);is equivalent to the three statements above, though for repeated matches it is less efficient since it does not allow the compiled pattern to be reused.
The default Policy implementation can be changed by setting the value of the policy.provider security property (in the Java security properties file) to the fully qualified name of the desired Policy subclass implementation.
The style bit SWT.WRAP should be used if a larger message area is desired.
May fail spuriously and does not provide ordering guarantees, so is only rarely an appropriate alternative to { compareAndSet}.
May fail spuriously and does not provide ordering guarantees, so is only rarely an appropriate alternative to { compareAndSet}.
May fail spuriously and does not provide ordering guarantees, so is only rarely an appropriate alternative to { compareAndSet}.
May fail spuriously and does not provide ordering guarantees, so is only rarely an appropriate alternative to { compareAndSet}.
However, this class provides alternative protected extension method decorateTask (one version each for Runnable and Callable) that can be used to customize the concrete task types used to execute commands entered via execute, submit, schedule, scheduleAtFixedRate, and scheduleWithFixedDelay.
Since 3.3, an alternative API is available, see {@link ViewerColumn#setEditingSupport(EditingSupport)} for a more flexible way of editing values in a column viewer.
Since 3.3, an alternative API is available, see {@link ViewerColumn#setEditingSupport(EditingSupport)} for a more flexible way of editing values in a column viewer.
Since 3.3, an alternative API is available, see {@link ViewerColumn#setEditingSupport(EditingSupport)} for a more flexible way of editing values in a column viewer.
There are two ways to get an Image from an ImageDescriptor. The method createImage will always return a new Image which must be disposed by the caller. Alternatively, createResource() returns a shared Image.
This interface may be implemented by clients. Alternatively, clients may use the rule-based default implementation {@link org.eclipse.jface.text.rules.DefaultDamagerRepairer}.
Since 3.3, an alternative API is available, see {@link ViewerColumn#setEditingSupport(EditingSupport)} for a more flexible way of editing values in a column viewer.
Logger names can be arbitrary strings, but they should normally be based on the package name or class name of the logged component, such as java.net or javax.swing. In addition it is possible to create anonymous Loggers that are not stored in the Logger namespace.
Unicode-aware case-insensitive matching can be enabled by specifying the {@link #UNICODE_CASE} flag in conjunction with this flag.
{@link org.eclipse.jface.text.reconciler.IReconcilerExtension} since version 3.0 introducing the ability to be aware of documents with multiple partitionings.
Since 3.3, an alternative API is available, see {@link ViewerColumn#setEditingSupport(EditingSupport)} for a more flexible way of editing values in a column viewer.
Dialog does not use the following images in the registry DLG_IMG_ERROR DLG_IMG_INFO DLG_IMG_QUESTION DLG_IMG_WARNING They are now coming directly from SWT, see ImageRegistry. For backwards compatibility they are still supported, however new code should use SWT for these.
The following extension interfaces exist: {@link org.eclipse.jface.text.source.IAnnotationAccessExtension} since version 3.0 replacing all methods in that interface {@link IAnnotationAccessExtension2} since version 3.2 allowing to set a quick assist assistant to an annotation access.
You do not have to restrict yourself to using a single family of ResourceBundles. For example, you could have a set of bundles for exception messages, ExceptionResources (ExceptionResources_fr, ExceptionResources_de, ...), and one for widgets, WidgetResource (WidgetResources_fr, WidgetResources_de, ...); breaking up the resources however you like.
When possible, this method checks for write permissions and other operating system restrictions and will therefore usually provide a more accurate estimate of how much new data can actually be written than {@link #getFreeSpace}.
The following extension interfaces exist: {@link org.eclipse.jface.text.source.IAnnotationHoverExtension} since version 3.0 allowing a text hover to provide a creator for the hover control. This allows for sophisticated hovers in a way that information computed by the hover can be displayed in the best possible form.
The following extension interfaces exist: {@link org.eclipse.jface.text.ITextHoverExtension} since version 3.0 allowing a text hover to provide a creator for the hover control. This allows for sophisticated hovers in a way that information computed by the hover can be displayed in the best possible form. {@link org.eclipse.jface.text.ITextHoverExtension2} since version 3.4 allowing a text hover to return hover-specific information objects.
It replaces {@link org.eclipse.jface.text.ITextViewer#setTextHover(ITextHover, String)} with a new method that allows to specify state masks for a better control of the hover behavior.
CollationKeys provide better performance than Collator.compare when Strings are involved in multiple comparisons.
Since the order of format elements in a pattern string often changes during localization, it is generally better to use the {@link #setFormatByArgumentIndex setFormatByArgumentIndex} method, which accesses format elements based on the argument index they specify.
For comparing Strings exactly once, the compare method provides the best performance. When sorting a list of Strings however, it is generally necessary to compare each String multiple times. In this case, CollationKeys provide better performance.
Since the order of format elements in a pattern string often changes during localization, it is generally better to use the {@link #setFormatsByArgumentIndex setFormatsByArgumentIndex} method, which assumes an order of formats corresponding to the order of elements in the arguments array passed to the format methods or the result array returned by the parse methods.
Since the order of format elements in a pattern string often changes during localization, it's generally better to use the {@link #getFormatsByArgumentIndex getFormatsByArgumentIndex} method, which assumes an order of formats corresponding to the order of elements in the arguments array passed to the format methods or the result array returned by the parse methods.
@deprecated Since 3.4, the default implementation of {@link CellLabelProvider#initialize(ColumnViewer, ViewerColumn)} in this class will set up the necessary owner draw callbacks automatically. Calls to this method can be removed.
Note that this method does not clean up references between this tool bar manager and its associated contribution items. Use removeAll for that purpose.
Note that this method does not clean up references between this cool bar manager and its associated contribution items. Use removeAll for that purpose.
Note that this method does not clean up references between this menu manager and its associated contribution items. Use removeAll for that purpose.
It should be set once either in the constructor or using this method.
If multiple threads access a hash set concurrently, and at least one of the threads modifies the set, it must be synchronized externally. This is typically accomplished by synchronizing on some object that naturally encapsulates the set. If no such object exists, the set should be wrapped using the {@link Collections#synchronizedSet Collections.synchronizedSet} method. This is best done at creation time, to prevent accidental unsynchronized access to the set: Set s = Collections.synchronizedSet(new HashSet(...));
If multiple threads access a linked hash set concurrently, and at least one of the threads modifies the set, it must be synchronized externally. This is typically accomplished by synchronizing on some object that naturally encapsulates the set. If no such object exists, the set should be wrapped using the {@link Collections#synchronizedSet Collections.synchronizedSet} method. This is best done at creation time, to prevent accidental unsynchronized access to the set: Set s = Collections.synchronizedSet(new LinkedHashSet(...));
If multiple threads access an identity hash map concurrently, and at least one of the threads modifies the map structurally, it must be synchronized externally. (A structural modification is any operation that adds or deletes one or more mappings; merely changing the value associated with a key that an instance already contains is not a structural modification.) This is typically accomplished by synchronizing on some object that naturally encapsulates the map. If no such object exists, the map should be wrapped using the {@link Collections#synchronizedMap Collections.synchronizedMap} method. This is best done at creation time, to prevent accidental unsynchronized access to the map: Map m = Collections.synchronizedMap(new IdentityHashMap(...));
If multiple threads access a map concurrently, and at least one of the threads modifies the map structurally, it must be synchronized externally. (A structural modification is any operation that adds or deletes one or more mappings; merely changing the value associated with an existing key is not a structural modification.) This is typically accomplished by synchronizing on some object that naturally encapsulates the map. If no such object exists, the map should be wrapped using the {@link Collections#synchronizedSortedMap Collections.synchronizedSortedMap} method. This is best done at creation time, to prevent accidental unsynchronized access to the map: SortedMap m = Collections.synchronizedSortedMap(new TreeMap(...));
For these reasons, environment variables are more likely to have unintended side effects. It is best to use system properties where possible.
If the backing store naturally flushes an entire subtree at once, the implementer is encouraged to override flush(), rather than merely overriding this method.
If the backing store naturally syncs an entire subtree at once, the implementer is encouraged to override sync(), rather than merely overriding this method.
Consult your JDBC driver documentation to determine if it might be more efficient to use a version of updateNCharacterStream which takes a length parameter.
Consult your JDBC driver documentation to determine if it might be more efficient to use a version of setNCharacterStream which takes a length parameter.
Consult your JDBC driver documentation to determine if it might be more efficient to use a version of setClob which takes a length parameter.
For efficiency, a character-stream object may use an object other than itself to protect critical sections.
For efficiency, a character-stream object may use an object other than itself to protect critical sections.
Note that this method does not clean up references between this status line manager and its associated contribution items. Use removeAll for that purpose.
Note that the preferred way of re-initializing a preference to its default value is to call setToDefault.
Note that the static convenience method getImage is also provided on this class.
Note that there is another method for efficiently processing the simultaneous addition of multiple elements.
If only the given element needs updating, it is more efficient to use the update methods.
If the old behavior is desired by subclasses, get the returned composite's layout data and set grabExcessVerticalSpace to true.
The default CertPathBuilder type can be changed by setting the value of the certpathbuilder.type security property (in the Java security properties file) to the desired type.
Once a remote object is registered (bound) with the RMI registry on the local host, callers on a remote (or local) host can lookup the remote object by name, obtain its reference, and then invoke remote methods on the object. A registry may be shared by all servers running on a host or an individual server process may create and use its own registry if desired (see java.rmi.registry.LocateRegistry.createRegistry method for details).
The default CertPathValidator type can be changed by setting the value of the certpathvalidator.type security property (in the Java security properties file) to the desired type.
Since 3.3, an alternative API is available, see {@link ViewerColumn#setEditingSupport(EditingSupport)} for a more flexible way of editing values in a column viewer.
This class is intended as an alternative to the JFace ListViewer, which displays its content in a combo box rather than a list.
May fail spuriously and does not provide ordering guarantees, so is only rarely an appropriate alternative to { compareAndSet}.
May fail spuriously and does not provide ordering guarantees, so is only rarely an appropriate alternative to { compareAndSet}.
May fail spuriously and does not provide ordering guarantees, so is only rarely an appropriate alternative to { compareAndSet}.
By default it looks in sun.net.www.content, but users can define a vertical-bar delimited set of class prefixes to search through in addition by defining the java.content.handler.pkgs property.
If the default behavior is not desired, then a Java security property can be set to a different Time-to-live (TTL) value for positive caching.
This does not handle structural changes (e.g. addition or removal of elements), and does not update any other related elements (e.g. child elements). To handle structural changes, use the refresh methods instead.
These methods are designed to be used as tools for creating higher-level synchronization utilities, and are not in themselves useful for most concurrency control applications.
This method should only be called from the UI thread. If you are not on the UI thread then wrap the call with a PlatformUI.getWorkbench().getDisplay().synchExec() in order to guarantee the correct result.
Because databases may use an optimized representation for the XML, accessing the value through getSource() and setResult() can lead to improved processing performance without serializing to a stream representation and parsing the XML.
When using a capacity-restricted queue, this method is generally preferable to method {@link BlockingQueue#add add}, which can fail to insert an element only by throwing an exception.
When using a capacity-restricted deque, it is generally preferable to use method {@link #offerLast}.
When using a capacity-restricted queue, this method is generally preferable to {@link #add}, which can fail to insert an element only by throwing an exception.
When using a capacity-restricted deque, it is generally preferable to use {@link #offerFirst(Object) offerFirst}.
When using a capacity-restricted queue, this method is generally preferable to {@link #add}, which can fail to insert an element only by throwing an exception.
When using a capacity-restricted deque, it is generally preferable to use {@link #offerLast(Object) offerLast}.
When using a capacity-restricted queue, it is generally preferable to use {@link #offer(Object) offer}.
This is best done at creation time, to prevent accidental unsynchronized access: Set<MyEnum> s = Collections.synchronizedSet(EnumSet.noneOf(MyEnum.class));
For a one time comparison, this method has the best performance. If a given String will be involved in multiple comparisons, CollationKey.compareTo has the best performance.
Note that if both the integer quotient and remainder are needed, this method is faster than using the { divideToIntegralValue} and { remainder} methods separately because the division need only be carried out once.
Note that there is a significant difference between writing a String into the stream as primitive data or as an Object.
implementations must synchronized on the hierarchy lock
implementations must synchronized on the hierarchy lock
implementations must synchronized on the hierarchy lock and children protected field
implementations must synchronized on the hierarchy lock
thread must then re-acquire the lock before returning from { await}.
Each thread must re-acquire the lock before it can return from { await}.
In all cases, before this method can return the current thread must re-acquire the lock associated with this condition.
In all cases, before this method can return the current thread must re-acquire the lock associated with this condition.
In all cases, before this method can return the current thread must re-acquire the lock associated with this condition.
If multiple threads access a format concurrently, it must be synchronized externally.
If multiple threads access a format concurrently, it must be synchronized externally.
f multiple threads access a format concurrently, it must be synchronized externally.
If multiple threads access a format concurrently, it must be synchronized externally.
This method is NOT thread-safe in any special way. You must manually synchronize on either this class or the stream as required.
This method is NOT thread-safe in any special way. You must manually synchronize on either this class or the stream as required.
A subclass should therefore use the object in this field rather than this or a synchronized method.
A subclass should therefore use the object in this field rather than this or a synchronized method.
In all cases, before this method can return the current thread must re-acquire the lock associated with this condition.
Note that this method is not synchronized!
Note that this implementation is not synchronized.
Note that this implementation is not synchronized.
Note that this implementation is not synchronized.
Note that this implementation is not synchronized.
Note that this implementation is not synchronized.
Instances of ComparatorChain are not synchronized. The class is not thread-safe at construction time, but it is thread-safe to perform multiple comparisons after all the setup operations are complete.
Instances of FixedOrderComparator are not synchronized. The class is not thread-safe at construction time, but it is thread-safe to perform multiple comparisons after all the setup operations are complete.
The cursor enables iteration and list changes to occur in any order without invalidating the iterator (from one thread).
The cursor enables iteration and list changes to occur in any order without invalidating the iterator (from one thread).
The cursor enables iteration and list changes to occur in any order without invalidating the iterator (from one thread).
Each bucket in the hash table has its own monitor, so two threads can safely operate on the map at the same time, often without incurring any monitor contention.
Methods are synchronized, then forwarded to the decorated bag. Iterators must be separately synchronized around the loop.
Iterators must be separately synchronized around the loop.
Iterators must be manually synchronized: synchronized (coll) { Iterator it = coll.iterator(); // do stuff with iterator }
Iterators must be manually synchronized. synchronized (coll) { Iterator it = coll.iterator(); // do stuff with iterator } @return an iterator that must be manually synchronized on the collection
Iterators must be manually synchronized. synchronized (coll) { ListIterator it = coll.listIterator(); // do stuff with iterator } @return an iterator that must be manually synchronized on the collection
Iterators must be manually synchronized. synchronized (coll) { ListIterator it = coll.listIterator(3); // do stuff with iterator } @return an iterator that must be manually synchronized on the collection
This implementation is not synchronized. You can use {@link java.util.Collections#synchronizedMap} to provide synchronized access to a ReferenceMap.
This implementation is not synchronized. You can use {@link java.util.Collections#synchronizedMap} to provide synchronized access to a ReferenceIdentityMap. Remember that synchronization will not stop the garbage collecter removing entries.
This implementation is not synchronized. You can use {@link java.util.Collections#synchronizedMap} to provide synchronized access to a ReferenceMap. Remember that synchronization will not stop the garbage collecter removing entries.
You must manually synchronize on the returned buffer's iterator to avoid non-deterministic behavior: Map m = MapUtils.synchronizedMap(myMap); Set s = m.keySet(); // outside synchronized block synchronized (m) { // synchronized on MAP! Iterator i = s.iterator(); while (i.hasNext()) { process (i.next()); } }
You must manually synchronize on the returned buffer's iterator to avoid non-deterministic behavior: Map m = MapUtils.synchronizedSortedMap(myMap); Set s = m.keySet(); // outside synchronized block synchronized (m) { // synchronized on MAP! Iterator i = s.iterator(); while (i.hasNext()) { process (i.next()); } }
You must manually synchronize on the returned buffer's iterator to avoid non-deterministic behavior: List list = ListUtils.synchronizedList(myList); synchronized (list) { Iterator i = list.iterator(); while (i.hasNext()) { process (i.next()); } }
Much like the synchronized collections returned by {@link java.util.Collections}, you must manually synchronize on the returned buffer's iterator to avoid non-deterministic behavior: Buffer b = BufferUtils.synchronizedBuffer(myBuffer); synchronized (b) { Iterator i = b.iterator(); while (i.hasNext()) { process (i.next()); } }
You must manually synchronize on the returned buffer's iterator to avoid non-deterministic behavior: Collection c = CollectionUtils.synchronizedCollection(myCollection); synchronized (c) { Iterator i = c.iterator(); while (i.hasNext()) { process (i.next()); } }
It is imperative that the user manually synchronize on the returned bag when iterating over it: Bag bag = BagUtils.synchronizedBag(new HashBag()); ... synchronized(bag) { Iterator i = bag.iterator(); // Must be in synchronized block while (i.hasNext()) foo(i.next()); } }
You must manually synchronize on the returned buffer's iterator to avoid non-deterministic behavior: Set s = SetUtils.synchronizedSet(mySet); synchronized (s) { Iterator i = s.iterator(); while (i.hasNext()) { process (i.next()); } }
It is recommended that to avoid confusion you never use { Lock} instances in this way, except within their own implementation.
@return a negative value on failure; zero if acquisition in shared mode succeeded but no subsequent shared-mode acquire can succeed; and a positive value if acquisition in shared mode succeeded and subsequent shared-mode acquires might also succeed, in which case a subsequent waiting thread must check availability.
@return a negative value on failure; zero if acquisition in shared mode succeeded but no subsequent shared-mode acquire can succeed; and a positive value if acquisition in shared mode succeeded and subsequent shared-mode acquires might also succeed, in which case a subsequent waiting thread must check availability.
If multiple threads access a format concurrently, it must be synchronized externally.
In either case the implementation must ensure that the signal is redirected to another waiting thread, if there is one.
Before waiting on the condition the lock must be held by the current thread.
DEADLOCK WARNING: Calling this method may call undoableEditHappened in all listeners. It is unwise to call this method from one of its listeners.
It is imperative that the user manually synchronize on the returned collection when iterating over it: Collection c = Collections.synchronizedCollection(myCollection); ... synchronized(c) { Iterator i = c.iterator(); // Must be in the synchronized block while (i.hasNext()) foo(i.next()); }
It is imperative that the user manually synchronize on the returned set when iterating over it: Set s = Collections.synchronizedSet(new HashSet()); ... synchronized(s) { Iterator i = s.iterator(); // Must be in the synchronized block while (i.hasNext()) foo(i.next()); }
It is imperative that the user manually synchronize on the returned sorted set when iterating over it or any of its subSet, headSet, or tailSet views. SortedSet s = Collections.synchronizedSortedSet(new TreeSet()); ... synchronized(s) { Iterator i = s.iterator(); // Must be in the synchronized block while (i.hasNext()) foo(i.next()); }
It is imperative that the user manually synchronize on the returned list when iterating over it: List list = Collections.synchronizedList(new ArrayList()); ... synchronized(list) { Iterator i = list.iterator(); // Must be in synchronized block while (i.hasNext()) foo(i.next()); }
It is imperative that the user manually synchronize on the returned map when iterating over any of its collection views: Map m = Collections.synchronizedMap(new HashMap()); ... Set s = m.keySet(); // Needn't be in synchronized block ... synchronized(m) { // Synchronizing on m, not s! Iterator i = s.iterator(); // Must be in synchronized block while (i.hasNext()) foo(i.next()); }
It is imperative that the user manually synchronize on the returned sorted map when iterating over any of its collection views, or the collections views of any of its subMap, headMap or tailMap views. SortedMap m = Collections.synchronizedSortedMap(new TreeMap()); ... Set s = m.keySet(); // Needn't be in synchronized block ... synchronized(m) { // Synchronizing on m, not s! Iterator i = s.iterator(); // Must be in synchronized block while (i.hasNext()) foo(i.next()); }
Note that this class is not synchronized. If multiple threads access a ProcessBuilder instance concurrently, and at least one of the threads modifies one of the attributes structurally, it must be synchronized externally.
The public methods of all CertStoreSpi objects must be thread-safe.
All PolicyQualifierInfo objects must be immutable and thread-safe.
If the Collection will be modified by one thread while another thread is calling a method of a Collection CertStore that has been initialized with this Collection, the Collection must have fail-fast iterators.
All CertPath objects must be thread-safe. That is, multiple threads may concurrently invoke the methods defined in this class on a single CertPath object (or more than one) with no ill effects.
All PolicyNode objects must be immutable and thread-safe.
All public methods of CertStore objects must be thread-safe.
Unless otherwise specified, the methods defined in this interface are not thread-safe. Multiple threads that need to access a single object concurrently should synchronize amongst themselves and provide the necessary locking.
Unless otherwise specified, the methods defined in this interface are not thread-safe. Multiple threads that need to access a single object concurrently should synchronize amongst themselves and provide the necessary locking.
Threads that need to access a single CertPathValidatorSpi instance concurrently should synchronize amongst themselves and provide the necessary locking before calling the wrapping CertPathValidator object.
Instances of this class need not be protected against concurrent access from multiple threads. Threads that need to access a single CertPathBuilderSpi instance concurrently should synchronize amongst themselves and provide the necessary locking before calling the wrapping CertPathBuilder object.
Unless otherwise specified, the methods defined in this class are not thread-safe. Multiple threads that need to access a single object concurrently should synchronize amongst themselves and provide the necessary locking.
Subclass implementations of PermissionCollection should assume that they may be called simultaneously from multiple threads, and therefore should be synchronized properly.
Unless otherwise specified, the methods defined in this class are not thread-safe. Multiple threads that need to access a single object concurrently should synchronize amongst themselves and provide the necessary locking. Multiple threads each manipulating separate objects need not synchronize.
Unless otherwise specified, the methods defined in this class are not thread-safe. Multiple threads that need to access a single object concurrently should synchronize amongst themselves and provide the necessary locking. Multiple threads each manipulating separate objects need not synchronize.
Unless otherwise specified, the methods defined in this class are not thread-safe. Multiple threads that need to access a single object concurrently should synchronize amongst themselves and provide the necessary locking. Multiple threads each manipulating separate objects need not synchronize.
Unless otherwise specified, the methods defined in this class are not thread-safe. Multiple threads that need to access a single object concurrently should synchronize amongst themselves and provide the necessary locking. Multiple threads each manipulating separate objects need not synchronize.
Unless otherwise specified, the methods defined in this class are not thread-safe. Multiple threads that need to access a single object concurrently should synchronize amongst themselves and provide the necessary locking. Multiple threads each manipulating separate objects need not synchronize.
Unless otherwise specified, the methods defined in this class are not thread-safe. Multiple threads that need to access a single object concurrently should synchronize amongst themselves and provide the necessary locking. Multiple threads each manipulating separate objects need not synchronize.
Unless otherwise specified, the methods defined in this class are not thread-safe. Multiple threads that need to access a single object concurrently should synchronize amongst themselves and provide the necessary locking. Multiple threads each manipulating separate objects need not synchronize.
Unless otherwise specified, the methods defined in this interface are not thread-safe. Multiple threads that need to access a single object concurrently should synchronize amongst themselves and provide the necessary locking. Multiple threads each manipulating separate objects need not synchronize.
Unless otherwise specified, the methods defined in this class are not thread-safe. Multiple threads that need to access a single object concurrently should synchronize amongst themselves and provide the necessary locking. Multiple threads each manipulating separate objects need not synchronize
Unless otherwise specified, the methods defined in this class are not thread-safe. Multiple threads that need to access a single object concurrently should synchronize amongst themselves and provide the necessary locking. Multiple threads each manipulating separate objects need not synchronize.
Unless otherwise documented by a specific provider, threads that need to access a single CertPathValidator instance concurrently should synchronize amongst themselves and provide the necessary locking. Multiple threads each manipulating a different CertPathValidator instance need not synchronize.
The static methods of this class are guaranteed to be thread-safe. Multiple threads may concurrently invoke the static methods defined in this class with no ill effects.
The static methods of this class are guaranteed to be thread-safe. Multiple threads may concurrently invoke the static methods defined in this class with no ill effects.
Unless otherwise documented by a specific provider, threads that need to access a single CertPathBuilder instance concurrently should synchronize amongst themselves and provide the necessary locking. Multiple threads each manipulating a different CertPathBuilder instance need not synchronize.
Unless otherwise specified, the methods defined in this class are not thread-safe. Multiple threads that need to access a single object concurrently should synchronize amongst themselves and provide the necessary locking. Multiple threads each manipulating separate objects need not synchronize.
Unless otherwise specified, the methods defined in this class are not thread-safe. Multiple threads that need to access a single object concurrently should synchronize amongst themselves and provide the necessary locking. Multiple threads each manipulating separate objects need not synchronize.
Returns an iterator that does not support concurrent modification.If the underlying list is modified while iterating using this iterator a ConcurrentModificationException will occur.
An extended ListIterator that allows concurrent changes to the underlying list.
Concurrent modifications are not directly supported, and for most collection implementations will throw a ConcurrentModificationException.
Concurrent modifications are not directly supported, and for most collection implementations will throw a ConcurrentModificationException.
Note that DefaultedMap is not synchronized and is not thread-safe. If you wish to use this map from multiple threads concurrently, you must use appropriate synchronization.
Note that FixedSizeMap is not synchronized and is not thread-safe. If you wish to use this map from multiple threads concurrently, you must use appropriate synchronization.
The iterators returned by the collection views of this class are not fail-fast. They will never raise a {@link java.util.ConcurrentModificationException}.
Note that PredicatedSortedMap is not synchronized and is not thread-safe. If you wish to use this map from multiple threads concurrently, you must use appropriate synchronization.
Note that TransformedMap is not synchronized and is not thread-safe. If you wish to use this map from multiple threads concurrently, you must use appropriate synchronization.
Note that LazyMap is not synchronized and is not thread-safe. If you wish to use this map from multiple threads concurrently, you must use appropriate synchronization.
Note that FixedSizeSortedMap is not synchronized and is not thread-safe. If you wish to use this map from multiple threads concurrently, you must use appropriate synchronization.
Note that ReferenceIdentityMap is not synchronized and is not thread-safe. If you wish to use this map from multiple threads concurrently, you must use appropriate synchronization.
Note that TransformedSortedMap is not synchronized and is not thread-safe. If you wish to use this map from multiple threads concurrently, you must use appropriate synchronization.
Note that MultiKeyMap is not synchronized and is not thread-safe. If you wish to use this map from multiple threads concurrently, you must use appropriate synchronization. This class may throw exceptions when accessed by concurrent threads without synchronization.
Note that LazySortedMap is not synchronized and is not thread-safe. If you wish to use this map from multiple threads concurrently, you must use appropriate synchronization. T
Note that ReferenceMap is not synchronized and is not thread-safe. If you wish to use this map from multiple threads concurrently, you must use appropriate synchronization.
Note that HashedMap is not synchronized and is not thread-safe. If you wish to use this map from multiple threads concurrently, you must use appropriate synchronization.
Note that CaseInsensitiveMap is not synchronized and is not thread-safe. If you wish to use this map from multiple threads concurrently, you must use appropriate synchronization.
Note that IdentityMap is not synchronized and is not thread-safe. If you wish to use this map from multiple threads concurrently, you must use appropriate synchronization.
Note that MultiValueMap is not synchronized and is not thread-safe. If you wish to use this map from multiple threads concurrently, you must use appropriate synchronization. This class may throw exceptions when accessed by concurrent threads without synchronization.
Note that ListOrderedMap is not synchronized and is not thread-safe. If you wish to use this map from multiple threads concurrently, you must use appropriate synchronization
Note that Flat3Map is not synchronized and is not thread-safe. If you wish to use this map from multiple threads concurrently, you must use appropriate synchronization.
Note that LinkedMap is not synchronized and is not thread-safe. If you wish to use this map from multiple threads concurrently, you must use appropriate synchronization.
Note that PredicatedMap is not synchronized and is not thread-safe. If you wish to use this map from multiple threads concurrently, you must use appropriate synchronization. T
Note that CompositeMap is not synchronized and is not thread-safe. If you wish to use this map from multiple threads concurrently, you must use appropriate synchronization.
Note that LRUMap is not synchronized and is not thread-safe. If you wish to use this map from multiple threads concurrently, you must use appropriate synchronization.
Note that TransformedMap is not synchronized and is not thread-safe. If you wish to use this map from multiple threads concurrently, you must use appropriate synchronization.
If multiple threads access a hash map concurrently, and at least one of the threads modifies the map structurally, it must be synchronized externally.
If multiple threads access a linked hash map concurrently, and at least one of the threads modifies the map structurally, it must be synchronized externally.
If multiple threads access a linked hash set concurrently, and at least one of the threads modifies the set, it must be synchronized externally.
If multiple threads access an ArrayList instance concurrently, and at least one of the threads modifies the list structurally, it must be synchronized externally.
If multiple threads access a linked list concurrently, and at least one of the threads modifies the list structurally, it must be synchronized externally.
If multiple threads access a hash set concurrently, and at least one of the threads modifies the set, it must be synchronized externally.
If multiple threads access an identity hash map concurrently, and at least one of the threads modifies the map structurally, it must be synchronized externally.
If multiple threads access a map concurrently, and at least one of the threads modifies the map structurally, it must be synchronized externally.
If multiple threads access a tree set concurrently, and at least one of the threads modifies the set, it must be synchronized externally.
Note that this method should not synchronize the preferences in any subnodes of this node.
Note that this implementation is not synchronized.
This operation is not atomic and may have undesired effects.
If multiple threads access an enum set concurrently, and at least one of the threads modifies the set, it should be synchronized externally.
If multiple threads access an enum map concurrently, and at least one of the threads modifies the map, it should be synchronized externally.
A multi-threaded application should either allocate multiple packer engines, or else serialize use of one engine with a lock.
A multi-threaded application should either allocate multiple unpacker engines, or else serialize use of one engine with a lock.
Note that this implementation is not synchronized. Multiple threads should not access a { PriorityQueue} instance concurrently if any of the threads modifies the queue.
You must manually synchronize on the returned buffer's iterator to avoid non-deterministic behavior:
Generally, semaphores used to control resource access should be initialized as fair, to ensure that no thread is starved out from accessing a resource.
Appendables are not necessarily safe for multithreaded access. Thread safety is the responsibility of classes that extend and implement this interface.
Note that passing in an invalid id results in unspecified behavior.
An implementation is required to clearly document the semantics and guarantees provided by each of the waiting methods, and when an implementation does support interruption of thread suspension then it must obey the interruption semantics as defined in this interface.
In either case the implementation must ensure that the signal is redirected to another waiting thread, if there is one.
Shutdown hooks run at a delicate time in the life cycle of a virtual machine and should therefore be coded defensively. They should, in particular, be written to be thread-safe and to avoid deadlocks insofar as possible. They should also not rely blindly upon services that may have registered their own shutdown hooks and therefore may themselves in the process of shutting down. Attempts to use other thread-based services such as the AWT event-dispatch thread, for example, may lead to deadlocks.
The public methods of all CertStoreSpi objects must be thread-safe.
All PolicyQualifierInfo objects must be immutable and thread-safe.
All TrustAnchor objects must be immutable and thread-safe.
The thread stack size necessary to perform a given computation will likely vary from one JRE implementation to another. In light of this variation, careful tuning of the stack size parameter may be required, and the tuning may need to be repeated for each JRE implementation on which an application is to run.
@param map the map to transform, must not be null, typically empty
Implementations of these methods must be internally thread-safe, and should in general be short and not block.
When locking and unlocking occur in different scopes, care must be taken to ensure that all code that is executed while the lock is held is protected by try-finally or try-catch to ensure that the lock is released when necessary.
Due to the multi-threaded nature of class loading, it is possible for a transformer to receive calls after it has been removed. Transformers should be written defensively to expect this situation.
When threads must repeatedly count down in this way, instead use a {@link CyclicBarrier}.
A ResourceBundle.Control instance must be thread-safe if it's simultaneously used by multiple threads.
This method should query if the state of the object permits it to be acquired in the exclusive mode, and if so to acquire it.
The absence of block-structured locking removes the automatic release of locks that occurs with { synchronized} methods and statements. In most cases, the following idiom should be used:
All { Lock} implementations must enforce the same memory synchronization semantics as provided by the built-in monitor lock, as described in The Java Language Specification, Third Edition (17.4 Memory Model)
@param sortOrder new sort order. The comparator must be able to support being used in a background thread.
This method should only be called from the UI thread. If you are not on the UI thread then wrap the call with a PlatformUI.getWorkbench().getDisplay().synchExec() in order to guarantee the correct result. Failure to do this may result in an {@link SWTException} being thrown.
Likewise any application that updates an IPreferenceStore from a Thread other than the UI Thread should be aware of any listeners that require an update in the UI Thread.
It is recommended practice to always immediately follow a call to { lock} with a { try} block, most typically in a before/after construction
ttempting to use both objects from a single thread is not recommended as it may deadlock the thread.
Note that in context based mode the content formatter is fully reentrant, but not thread-safe.
This method may be called on a non-UI thread.
The ability to interrupt a lock acquisition in some implementations may not be possible, and if possible may be an expensive operation. The programmer should be aware that this may be the case.
This may be executed on any thread.
Thread-safe implementation. Can be called from any thread.
This method should only be called from the UI thread. If you are not on the UI thread then wrap the call with a PlatformUI.getWorkbench().getDisplay().synchExec() in order to guarantee the correct result.
It is recommended that to avoid confusion you never use { Condition} instances in this way, except perhaps within their own implementation.
Formats are generally not synchronized. It is recommended to create separate format instances for each thread.
Attempting to use both objects from a single thread is not recommended, as it may deadlock the thread.
Additionally, it is possible for the size to change during execution of this method, in which case the returned result will be inaccurate.
If this write lock is not held when any {@link Condition} method is called then an {@link IllegalMonitorStateException} is thrown. (Read locks are held independently of write locks, so are not checked or affected. However it is essentially always an error to invoke a condition waiting method when the current thread has also acquired read locks, since other threads that could unblock it will not be able to acquire the write lock.)
Memory consistency effects: As with other concurrent collections, actions in a thread prior to placing an object into a { ConcurrentMap} as a key or value happen-before actions subsequent to the access or removal of that object from the { ConcurrentMap} in another thread.
Furthermore, Enumerations returned via the elements method are not fail-fast. Modifications to a collection should not be performed while enumerating over that collection.
Throughput and scalability are generally highest for the default barging (also known as greedy, renouncement, and convoy-avoidance) strategy. While this is not guaranteed to be fair or starvation-free, earlier queued threads are allowed to recontend before later queued threads, and each recontention has an unbiased chance to succeed against incoming threads. Also, while acquires do not spin in the usual sense, they may perform multiple invocations of tryAcquire interspersed with other computations before blocking. This gives most of the benefits of spins when exclusive synchronization is only briefly held, without most of the liabilities when it isn't. If so desired, you can augment this by preceding calls to acquire methods with fast-path checks, possibly prechecking {@link #hasContended} and/or {@link #hasQueuedThreads} to only do so if the synchronizer is likely not to be contended.
This method is fully reentrant, but not thread-safe.
If the preferences or nodes in the subtree rooted at this node are modified concurrently with an invocation of this method, the exported preferences comprise a fuzzy snapshot of the subtree; some of the concurrent modifications may be reflected in the exported data while others may not.
. If the preferences at this node are modified concurrently with an invocation of this method, the exported preferences comprise a fuzzy snapshot of the preferences contained in the node; some of the concurrent modifications may be reflected in the exported data while others may not.
The model is allowed to send back notifications to its listeners in any thread, and the listeners must not assume that the notifications will arrive in the UI thread.
DataInputStream is not necessarily safe for multithreaded access.
Note that if your application creates its own custom activation group, a security manager must be set for that group
If your application needs to set a different security manager, you must ensure that the policy file specified by the group's ActivationGroupDesc grants the group the necessary permissions to set a new security manager
The associated method must be public and its parameters return value, and exceptions must follow the rules defined in JAX-RPC 1.1, section
The JSR-181 tool must provide feedback if the service implementation bean is inconsistent with the portType and bindings declared in this WSDL.
Mailcap files must conform to the mailcap file specification
The circumstances and the exception type must be documented by that { Lock} implementation.
Typically, an exception will be thrown (such as {@link IllegalMonitorStateException}) and the implementation must document that fact.
An implementation is required to clearly document the semantics and guarantees provided by each of the waiting methods
If an implementation provides such specialized semantics then the implementation must document those semantics.
The exact operation of the {@link Condition} instance depends on the { Lock} implementation and must be documented by that implementation.
Typically, an exception will be thrown (such as {@link IllegalMonitorStateException}) and the implementation must document that fact.
Typically, an exception will be thrown (such as {@link IllegalMonitorStateException}) and the implementation must document that fact.
Clients may call this method in order to trigger the menu via keystrokes or other gestures
For indeterminate progress, we don't have to know the total amount of work in advance and no worked method needs to be called.
Clients may also call this method to persist the bounds at times other than closing the dialog.
This can be called even after the dialog is closed.
An application should catch instances of this class only if it must clean up after being terminated asynchronously.
The instanceof operator should be used to determine the specific kind of object returned.
Users should cast the generic URLConnection to a JarURLConnection when they know that the URL they created is a JAR URL, and they need JAR-specific functionality. For example: URL url = new URL(jar:file:/home/duke/duke.jar!/); JarURLConnection jarConnection = (JarURLConnection)url.openConnection(); Manifest manifest = jarConnection.getManifest();
@return the object fetched. The instanceof operator should be used to determine the specific kind of object returned.
If your application requires specific properties to be set when objects are activated in the group, the application should create a special Properties object containing these properties, then create an ActivationGroupDesc with the Properties object, and use ActivationGroup.createGroup before creating any ActivationDescs (before the default ActivationGroupDesc is created).
This field should be documented with a serialField tag.
@serialData Overriding methods should use this tag to describe the data layout of this Externalizable object.
A piped input stream should be connected to a piped output stream; the piped input stream then provides whatever data bytes are written to the piped output stream.
Security note: If an application needs to read a password or other secure data, it should use {@link #readPassword()} or {@link #readPassword(String, Object...)} and manually zero the returned character array after processing to minimize the lifetime of sensitive data in memory.
Classes that need to designate a replacement when an instance of it is read from the stream should implement this special method with the exact signature. ANY-ACCESS-MODIFIER Object readResolve() throws ObjectStreamException;
Serializable classes that need to designate an alternative object to be used when writing an object to the stream should implement this special method with the exact signature: ANY-ACCESS-MODIFIER Object writeReplace() throws ObjectStreamException;
An Error is a subclass of Throwable that indicates serious problems that a reasonable application should not try to catch.
As a matter of style, programmers should always use this annotation on the most deeply nested element where it is effective.
The Appendable interface must be implemented by any class whose instances are intended to receive formatted output from a {@link java.util.Formatter}.
An application should not normally try to catch ThreadDeath unless it must do some extraordinary cleanup operation (note that the throwing of ThreadDeath causes finally clauses of try statements to be executed before the thread officially dies). If a catch clause catches a ThreadDeath object, it is important to rethrow the object so that the thread actually dies.
To create a custom mapping, a programmer must do two things: * create a class that implements the {@link SQLData} interface for the UDT to be custom mapped. * make an entry in a type map that contains o the fully-qualified SQL type name of the UDT o the Class object for the class implementing SQLData
Additional columns beyond the columns defined to be returned by the ResultSet object for a given method can be defined by the JDBC driver vendor and must be accessed by their column label.
If auto-commit mode has been disabled, the method commit must be called explicitly in order to commit changes; otherwise, database changes will not be saved.
First, if the strings to be collated contain combining sequences that may not be in canonical order, you should set the collator to CANONICAL_DECOMPOSITION or FULL_DECOMPOSITION to enable sorting of combining sequences.
This constructor should only be used for serialization.
This constructor is used for serialization only and should not be used by subclasses.
Each class that implements PrivilegedExceptionAction should document what (if anything) this value represents.
Each class that implements PrivilegedAction should document what (if anything) this value represents.
Each subclass should state the precise behavior of this method so that users and developers know what to expect.
Note that digest objects can compute only one digest (see {@link MessageDigest}), so that in order to compute intermediate digests, a caller should retain a handle onto the digest object, and clone it for each digest to be computed, leaving the orginal digest untouched.
No check is made that the object is immutable. In general, only immutable objects should use the constant factory.
No check is made that the object is immutable. In general, only immutable objects should use the constant factory.
Enumerations returned via the elements method are not fail-fast. Modifications to a collection should not be performed while enumerating over that collection.
A provider should document all the key specifications supported by its key factory
Not all databases allow for a non-typed Null to be sent to the backend. For maximum portability, the setNull or the setObject(int parameterIndex, Object x, int sqlType) method should be used instead of setObject(int parameterIndex, Object x).
Not all databases allow for a non-typed Null to be sent to the backend. For maximum portability, the setNull or the setObject(String parameterName, Object x, int sqlType) method should be used instead of setObject(String parameterName, Object x).
To be portable, however, applications should always provide these values for user-named and REF parameters.
In this case, the caller can still decide to show the window, but the window should include some sort of visual warning.
This is important because classes should not be subclassed unless the programmer intends on modifying or enhancing the fundamental behavior of the class.
Compiler vendors should document the warning names they support in conjunction with this annotation type.
If it is critical to obtain every active thread in this thread group, the caller should verify that the returned int value is strictly less than the length of list.
f it is critical to obtain every active subgroup in this thread group, the caller should verify that the returned int value is strictly less than the length of list.
If it is critical to obtain every active subgroup in this thread group, the caller should verify that the returned int value is strictly less than the length of list.
As in the one argument version, interrupts and spurious wakeups are possible, and this method should always be used in a loop: synchronized (obj) { while (<condition does not hold>) obj.wait(); ... // Perform action appropriate to condition }
An implementation should document when this is the case.
Any restrictions and the exception type must be documented by that { Lock} implementation.
The circumstances and the exception type must be documented by that { Lock} implementation
The circumstances and the exception type must be documented by that { Lock} implementation.
If a new Boolean instance is not required, this method should generally be used in preference to the constructor {@link #Boolean(boolean)}, as this method is likely to yield significantly better space and time performance.
Note that the default implementation is not very efficient and should be overridden if this class is implemented.
While this will rarely occur in practice, applications must guard against it by testing for the condition that should have caused the thread to be awakened, and continuing to wait if the condition is not satisfied. In other words, waits should always occur in loops, like this one: synchronized (obj) { while (<condition does not hold>) obj.wait(timeout); ... // Perform action appropriate to condition }
As in the one argument version, interrupts and spurious wakeups are possible, and this method should always be used in a loop: synchronized (obj) { while (<condition does not hold>) obj.wait(timeout, nanos); ... // Perform action appropriate to condition }
For some memory pools, for example, when objects are not packed contiguously, this method may be an expensive operation that requires some computation to determine the current memory usage. An implementation should document when this is the case.
Environment variables should be used when a global effect is desired, or when an external system interface requires an environment variable (such as PATH).
Generally speaking, any class that implements the Comparable interface and violates this condition should clearly indicate this fact.
An application remotely accesses the platform MXBeans using proxy should prepare to catch IOException as if accessing with the MBeanServerConnector interface.
When a client application is designed to remotely access MXBeans for a running virtual machine whose version is different than the version on which the application is running, it should prepare to catch {@link java.io.InvalidObjectException InvalidObjectException} which is thrown when an MXBean proxy receives a name of an enum constant which is missing in the enum class loaded in the client application.
The specification for the persistent collection should indicate that it is capable of throwing such exceptions.
The StringBuilder class should generally be used in preference to this one, as it supports all of the same operations but it is faster, as it performs no synchronization.
Implementers should document whether the runnable is run synchronously (blocking) or asynchronously (non-blocking), or if no assumption can be made about the blocking behaviour.
Implementers should ignore the text returned by {@link IInformationProvider#getInformation(ITextViewer, IRegion)}.
This method may be called frequently, so implementors should ensure it returns quickly, e.g. by caching the returned creator.
This map is designed for performance and can outstrip HashMap. It also has good garbage collection characteristics. * Optimised for operation at size 3 or less. * Still works well once size 3 exceeded. * Gets at size 3 or less are about 0-10% faster than HashMap, * Puts at size 3 or less are over 4 times faster than HashMap. * Performance 5% slower than HashMap once size 3 exceeded once.
This list implementation utilises a tree structure internally to ensure that all insertions and removals are O(log n). This provides much faster performance than both an ArrayList and a LinkedList where elements are inserted and removed repeatedly from anywhere in the list.
ArrayList is a good general purpose list implementation. It is faster than TreeList for most operations except inserting and removing in the middle of the list. ArrayList also uses less memory as TreeList uses one object per entry.
Under many circumstances, linking Iterators together in this manner is more efficient (and convenient) than reading out the contents of each Iterator into a List and creating a new Iterator.
Under many circumstances, linking Iterators together in this manner is more efficient (and convenient) than using nested for loops to extract a list.
Under many circumstances, linking Iterators together in this manner is more efficient (and convenient) than using nested for loops to extract a list.
If an implementation provides such specialized semantics then the implementation must document those semantics.
Typically, an exception will be thrown (such as {@link IllegalMonitorStateException}) and the implementation must document that fact.
List classes should clearly specify in their documentation any restrictions on what elements may be added.
An implementation should document when this is the case.
In order both to sign and to pack a JAR, you must first pack and unpack the JAR to normalize it, then compute signatures on the unpacked JAR elements, and finally repack the signed JAR.
In general SEVERE messages should describe events that are of considerable importance and which will prevent normal program execution. They should be reasonably intelligible to end users and to system administrators.
he class remained source and test compatible, so if you can recompile all your classes and dependencies everything is OK.
Note that in this case, traversal to find that element takes linear time.
If they are not then they must not be changed after adding to the MultiKey.
If they are not then they must not be changed after adding to the MultiKey.
Implementation note: This method requires a lot of time and a ton of stack space. Essentially a recursive algorithm is used to enter each bucket's monitor. If you have twenty thousand buckets in your map, then the recursive method will be invoked twenty thousand times. You have been warned.
Although this can be used to reset iteration, the {@link #reset()} method is a more effective choice.
Callers should re-check the conditions which caused the thread to park in the first place.
An implementation should document when this is the case.
Callers should re-check the conditions which caused the thread to park in the first place.
Callers should re-check the conditions which caused the thread to park in the first place.
Callers should re-check the conditions which caused the thread to park in the first place.
Callers should re-check the conditions which caused the thread to park in the first place.
Callers should re-check the conditions which caused the thread to park in the first place
Individual set implementations should clearly document any restrictions on the elements that they may contain.
Collection classes should clearly specify in their documentation any restrictions on what elements may be added.
List classes should clearly specify in their documentation any restrictions on what elements may be added.
Generally speaking, any comparator that violates this condition should clearly indicate this fact.
Implementations should allow a value to be looked up from a key and a key to be looked up from a value with equal performance.
Implementations should allow a value to be looked up from a key and a key to be looked up from a value with equal performance.
Implementations should allow a value to be looked up from a key and a key to be looked up from a value with equal performance.
Finally, unlike {@link java.util.HashMap}-style implementations, this class never rehashes the map. The number of buckets is fixed at construction time and never altered. Performance may degrade if you do not allocate enough buckets upfront.
he number of buckets is inversely proportional to the chances for thread contention. The fewer buckets, the more chances for thread contention. The more buckets the fewer chances for thread contention.
The {@link #atomic(Runnable)} method is provided to allow atomic iterations and bulk operations; however, overuse of {@link #atomic(Runnable) atomic} will basically result in a map that's slower than an ordinary synchronized {@link java.util.HashMap}.
In general WARNING messages should describe events that will be of interest to end users or system managers, or which indicate potential problems.
So the INFO level should only be used for reasonably significant messages that will make sense to end users and system admins.
In general the FINE level should be used for information that will be broadly interesting to developers who do not have a specialized interest in the specific subsystem.
Both packing steps should use precisely the same options, and the segment limit may also need to be set to -1, to prevent accidental variation of segment boundaries as class file sizes change slightly.
Valuable data should not be stored at this node as it is shared by all programs that use it.
The add methods are affected by this class. Thus objects must be removed or searched for using their transformed form. For example, if the transformation converts Strings to Integers, you must use the Integer form to remove objects.
The add methods are affected by this class. Thus objects must be removed or searched for using their transformed form. For example, if the transformation converts Strings to Integers, you must use the Integer form to remove objects.
From a performance standpoint, these methods should be used with caution. In many implementations they will perform costly linear searches.
The add methods are affected by this class. Thus objects must be removed or searched for using their transformed form. For example, if the transformation converts Strings to Integers, you must use the Integer form to remove objects.
The add methods are affected by this class. Thus objects must be removed or searched for using their transformed form. For example, if the transformation converts Strings to Integers, you must use the Integer form to remove objects.
The add and set methods are affected by this class. Thus objects must be removed or searched for using their transformed form. For example, if the transformation converts Strings to Integers, you must use the Integer form to remove objects.
The add methods are affected by this class. Thus objects must be removed or searched for using their transformed form. For example, if the transformation converts Strings to Integers, you must use the Integer form to remove objects.
The add methods are affected by this class. Thus objects must be removed or searched for using their transformed form. For example, if the transformation converts Strings to Integers, you must use the Integer form to remove objects.
Valuable data should not be stored at this node as it is shared by all programs that use it.
Therefore, if a logging Handler wants to pass off a LogRecord to another thread, or to transmit it over RMI, and if it wishes to subsequently obtain method name or class name information it should call one of getSourceClassName or getSourceMethodName to force the values to be filled in.
Every Queue implementation must specify its ordering properties.
To be portable, however, applications should always provide these values for user-defined and REF parameters.
Compilers must ignore any warning names they do not recognize.
JDBC 4.0 Drivers must include the file META-INF/services/java.sql.Driver.
It is strongly recommended that each Driver class should be small and standalone so that the Driver class can be loaded and queried without bringing in vast quantities of supporting code.
For some memory pools, this method may be an expensive operation that requires some computation to determine the estimate.
If a method is annotated with this annotation type but does not override a superclass method, compilers are required to generate an error message.
There is no requirement that a process represented by a Process object execute asynchronously or concurrently with respect to the Java process that owns the Process object.
Note that the amount of memory required to hold an object of any given type may be implementation-dependent.
A method is not required to declare in its throws clause any subclasses of RuntimeException that might be thrown during the execution of the method but not caught.
A driver may only report true here if it passes the JDBC compliance tests; otherwise it is required to return false.JDBC compliance requires full support for the JDBC API and full support for SQL 92 Entry Level. It is expected that JDBC compliant drivers will be available for all the major commercial databases.
Beware that, unlike in most collections, the size method is not a constant-time operation. Because of the asynchronous nature of these sets, determining the current number of elements requires a traversal of the elements.
Beware that, unlike in most collections, this method is NOT a constant-time operation. Because of the asynchronous nature of these sets, determining the current number of elements requires traversing them all to count the
Beware that, unlike in most collections, the size method is not a constant-time operation. Because of the asynchronous nature of these maps, determining the current number of elements requires a traversal of the element
Beware that, unlike in most collections, this method is NOT a constant-time operation. Because of the asynchronous nature of these maps, determining the current number of elements requires traversing them all to count them.
Beware that, unlike in most collections, this method is NOT a constant-time operation. Because of the asynchronous nature of these queues, determining the current number of elements requires an O(n) traversal.
Note: This method requires a full internal traversal of the hash table, and so is much slower than method containsKey.
This operation will probably require time linear in the map size for most implementations.
Note: if { ListIterator.remove} requires linear time, this implementation requires quadratic time.
This operation will probably require time linear in the map size for most implementations of the Map interface.
Note that this implementation requires linear time in the size of the map.
Note that this implementation requires linear time in the size of the map;
Note that this implementation requires linear time in the size of the map;
Note that this implementation requires linear time in the size of the map;
When a TCP connection is closed the connection may remain in a timeout state for a period of time after the connection is closed (typically known as the TIME_WAIT state or 2MSL wait state). For applications using a well known socket address or port it may not be possible to bind a socket to the required SocketAddress if there is a connection in the timeout state involving the socket address or
When a TCP connection is closed the connection may remain in a timeout state for a period of time after the connection is closed (typically known as the TIME_WAIT state or 2MSL wait state). For applications using a well known socket address or port it may not be possible to bind a socket to the required SocketAddress if there is a connection in the timeout state involving the socket address or port.
For example, some List implementations provide asymptotically linear access times if they get huge, but constant access times in practice. Such a List implementation should generally implement this interface.
As a rule, the equals method should be used by implementations of this class to decide if two keys are the same.
Beware that, unlike in most collections, the { size} method is NOT a constant-time operation. Because of the asynchronous nature of these queues, determining the current number of elements requires a traversal of the elements.
Sets a new selection for this viewer and optionally makes it visible. The TableViewer implementation of this method is inefficient for the ILazyContentProvider as lookup is done by indices rather than elements and may require population of the entire table in worse case.Use Table#setSelection(int[] indices) and Table#showSelection() if you wish to set selection more efficiently when using a ILazyContentProvider.
It is strongly recommended that a cancel option be provided, so that the user has the option of making the decision at a later point in time.
IDialogConstants is the interface for common dialog strings and ids used throughout JFace. It is recommended that you use these labels and ids whereever for consistency with the JFace dialogs.
It is recommended that this platform MBeanServer also be used to register other application managed beans besides the platform MXBeans.
Due to the inherently imprecise nature of the result, it is recommended that this method only be used for informational purposes.
Due to the inherently imprecise nature of the result, it is recommended that this method only be used for informational purposes.
Implementation note: Java platform implementers are encouraged to document their implementation's behavior with respect to the stackSize parameter.
Code generators are encouraged to use platform-specific native libraries or microprocessor instructions, where available, to provide higher-performance implementations of Math methods. Such higher-performance implementations still must conform to the specification for Math.
It is a compile-time error for a single ElementType constant to appear more than once in a Target annotation.
Caching the state is important to improve overall performance as calling {@link org.eclipse.jface.text.quickassist.IQuickAssistAssistant#canFix(Annotation)} can be expensive.
Disables randomization and enables additional runtime error checking. Severely degrades performance if set to true. Intended for use in test suites only.
Increasing the receive buffer size can increase the performance of network I/O for high-volume connection, while decreasing it can help reduce the backlog of incoming data.
Specifying this flag may impose a performance penalty.
Note: The object returned from this method may be an instance of an implementation-specific class. The RemoteObject class ensures serialization portability of its instances' remote references through the behavior of its custom writeObject and readObject methods. An instance of RemoteRef should not be serialized outside of its RemoteObject wrapper instance or the result may be unportable.
