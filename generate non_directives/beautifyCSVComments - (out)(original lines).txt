Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for dialogs.Package SpecificationA dialog is a specialized window, typically consisting of a dialog areaand a button bar, designed for narrow-focussed communication with the user.The dialog framework consists of an abstract base class (Dialog),along with more concrete dialog subclasses for displaying messages (MessageDialog),soliciting text input (InputDialog), and displaying progress duringa long-running operation (ProgressMonitorDialog).Dialog stores (IDialogStore, DialogStore) providea general framework for organizing a dialog's settings into key/value pairs.Multi-page dialogs are made easier through the use of dialog pages (IDialogPage,DialogPage).Note: None of the classes in this package maintain global state.&nbsp;&nbsp;&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides support for managing resources such as SWTfonts and images.Package SpecificationThis package contains support for managing resources, including:font registries (FontRegistry) - for hanging on to the SWT fontobjects needed by an applicationcolor registries (ColorRegistry) - for hanging on to the SWT color objects needed by an applicationimage registries (ImageRegistry) - for hanging on to the SWT imageobjects needed by an applicationimage descriptors (ImageDescriptor) - surrogate object for creatingSWT imagesstring conversion (StringConverter) - for parsing property filesThe JFace resources module is an independent JFace module requiring a basicknowledge of SWT and the JFace property change event mechanism. Familiaritywith other JFace modules is not required.Image descriptors are objects that knows how to create an image on demand.They serve as a lightweight representation of images in situations whereno SWT display exists yet, and are used mainly in conjunction with imageregistries. This package contains the image descriptor framework, whichis a simple hierarchy rooted at the abstract class ImageDescriptor.The framework includes abstract subclasses for composing images (CompositeImageDescriptor)as well as a ready-made concrete subclass for loading images from files(FileImageDescriptor).The class JFaceResources maintains global state on behalf ofJFace itself consisting of JFace's own image registry, font registry, resourcebundle, and preference store.&nbsp;
Provides JFace support for long-running operations.Package SpecificationLong-running operations must be dealt with specially in order to keep theUI helpful and responsive. Typically this involves temporarily disablingmost controls and displaying a busy cursor and progress indicator; whilethe operation is in progress, the only requests that will be accepted willbe ones to cancel the operation.The IRunnableWithProgress interface should be implemented byany class whose instances are intended to be executed as long-running operations.These objects can then be run in any runnable context (IRunnableContext),including such standard JFace UI components as application windows (ApplicationWindow),wizard dialogs (WizardDialog), and progress monitor dialogs (ProgressMonitorDialog).The utility class ModalContext defines the basic mechanism andUI event loop for modal operations.
Provides JFace support for long-running operations.Package SpecificationLong-running operations must be dealt with specially in order to keep theUI helpful and responsive. Typically this involves temporarily disablingmost controls and displaying a busy cursor and progress indicator; whilethe operation is in progress, the only requests that will be accepted willbe ones to cancel the operation.The IRunnableWithProgress interface should be implemented byany class whose instances are intended to be executed as long-running operations.These objects can then be run in any runnable context (IRunnableContext),including such standard JFace UI components as application windows (ApplicationWindow),wizard dialogs (WizardDialog), and progress monitor dialogs (ProgressMonitorDialog).The utility class ModalContext defines the basic mechanism andUI event loop for modal operations.
Provides JFace support for long-running operations.Package SpecificationLong-running operations must be dealt with specially in order to keep theUI helpful and responsive. Typically this involves temporarily disablingmost controls and displaying a busy cursor and progress indicator; whilethe operation is in progress, the only requests that will be accepted willbe ones to cancel the operation.The IRunnableWithProgress interface should be implemented byany class whose instances are intended to be executed as long-running operations.These objects can then be run in any runnable context (IRunnableContext),including such standard JFace UI components as application windows (ApplicationWindow),wizard dialogs (WizardDialog), and progress monitor dialogs (ProgressMonitorDialog).The utility class ModalContext defines the basic mechanism andUI event loop for modal operations.
Provides JFace support for long-running operations.Package SpecificationLong-running operations must be dealt with specially in order to keep theUI helpful and responsive. Typically this involves temporarily disablingmost controls and displaying a busy cursor and progress indicator; whilethe operation is in progress, the only requests that will be accepted willbe ones to cancel the operation.The IRunnableWithProgress interface should be implemented byany class whose instances are intended to be executed as long-running operations.These objects can then be run in any runnable context (IRunnableContext),including such standard JFace UI components as application windows (ApplicationWindow),wizard dialogs (WizardDialog), and progress monitor dialogs (ProgressMonitorDialog).The utility class ModalContext defines the basic mechanism andUI event loop for modal operations.
Provides JFace support for long-running operations.Package SpecificationLong-running operations must be dealt with specially in order to keep theUI helpful and responsive. Typically this involves temporarily disablingmost controls and displaying a busy cursor and progress indicator; whilethe operation is in progress, the only requests that will be accepted willbe ones to cancel the operation.The IRunnableWithProgress interface should be implemented byany class whose instances are intended to be executed as long-running operations.These objects can then be run in any runnable context (IRunnableContext),including such standard JFace UI components as application windows (ApplicationWindow),wizard dialogs (WizardDialog), and progress monitor dialogs (ProgressMonitorDialog).The utility class ModalContext defines the basic mechanism andUI event loop for modal operations.
Provides JFace support for long-running operations.Package SpecificationLong-running operations must be dealt with specially in order to keep theUI helpful and responsive. Typically this involves temporarily disablingmost controls and displaying a busy cursor and progress indicator; whilethe operation is in progress, the only requests that will be accepted willbe ones to cancel the operation.The IRunnableWithProgress interface should be implemented byany class whose instances are intended to be executed as long-running operations.These objects can then be run in any runnable context (IRunnableContext),including such standard JFace UI components as application windows (ApplicationWindow),wizard dialogs (WizardDialog), and progress monitor dialogs (ProgressMonitorDialog).The utility class ModalContext defines the basic mechanism andUI event loop for modal operations.
Provides JFace support for long-running operations.Package SpecificationLong-running operations must be dealt with specially in order to keep theUI helpful and responsive. Typically this involves temporarily disablingmost controls and displaying a busy cursor and progress indicator; whilethe operation is in progress, the only requests that will be accepted willbe ones to cancel the operation.The IRunnableWithProgress interface should be implemented byany class whose instances are intended to be executed as long-running operations.These objects can then be run in any runnable context (IRunnableContext),including such standard JFace UI components as application windows (ApplicationWindow),wizard dialogs (WizardDialog), and progress monitor dialogs (ProgressMonitorDialog).The utility class ModalContext defines the basic mechanism andUI event loop for modal operations.
Provides JFace support for long-running operations.Package SpecificationLong-running operations must be dealt with specially in order to keep theUI helpful and responsive. Typically this involves temporarily disablingmost controls and displaying a busy cursor and progress indicator; whilethe operation is in progress, the only requests that will be accepted willbe ones to cancel the operation.The IRunnableWithProgress interface should be implemented byany class whose instances are intended to be executed as long-running operations.These objects can then be run in any runnable context (IRunnableContext),including such standard JFace UI components as application windows (ApplicationWindow),wizard dialogs (WizardDialog), and progress monitor dialogs (ProgressMonitorDialog).The utility class ModalContext defines the basic mechanism andUI event loop for modal operations.
Provides JFace support for long-running operations.Package SpecificationLong-running operations must be dealt with specially in order to keep theUI helpful and responsive. Typically this involves temporarily disablingmost controls and displaying a busy cursor and progress indicator; whilethe operation is in progress, the only requests that will be accepted willbe ones to cancel the operation.The IRunnableWithProgress interface should be implemented byany class whose instances are intended to be executed as long-running operations.These objects can then be run in any runnable context (IRunnableContext),including such standard JFace UI components as application windows (ApplicationWindow),wizard dialogs (WizardDialog), and progress monitor dialogs (ProgressMonitorDialog).The utility class ModalContext defines the basic mechanism andUI event loop for modal operations.
Provides JFace support for long-running operations.Package SpecificationLong-running operations must be dealt with specially in order to keep theUI helpful and responsive. Typically this involves temporarily disablingmost controls and displaying a busy cursor and progress indicator; whilethe operation is in progress, the only requests that will be accepted willbe ones to cancel the operation.The IRunnableWithProgress interface should be implemented byany class whose instances are intended to be executed as long-running operations.These objects can then be run in any runnable context (IRunnableContext),including such standard JFace UI components as application windows (ApplicationWindow),wizard dialogs (WizardDialog), and progress monitor dialogs (ProgressMonitorDialog).The utility class ModalContext defines the basic mechanism andUI event loop for modal operations.
Provides JFace support for long-running operations.Package SpecificationLong-running operations must be dealt with specially in order to keep theUI helpful and responsive. Typically this involves temporarily disablingmost controls and displaying a busy cursor and progress indicator; whilethe operation is in progress, the only requests that will be accepted willbe ones to cancel the operation.The IRunnableWithProgress interface should be implemented byany class whose instances are intended to be executed as long-running operations.These objects can then be run in any runnable context (IRunnableContext),including such standard JFace UI components as application windows (ApplicationWindow),wizard dialogs (WizardDialog), and progress monitor dialogs (ProgressMonitorDialog).The utility class ModalContext defines the basic mechanism andUI event loop for modal operations.
Provides JFace support for long-running operations.Package SpecificationLong-running operations must be dealt with specially in order to keep theUI helpful and responsive. Typically this involves temporarily disablingmost controls and displaying a busy cursor and progress indicator; whilethe operation is in progress, the only requests that will be accepted willbe ones to cancel the operation.The IRunnableWithProgress interface should be implemented byany class whose instances are intended to be executed as long-running operations.These objects can then be run in any runnable context (IRunnableContext),including such standard JFace UI components as application windows (ApplicationWindow),wizard dialogs (WizardDialog), and progress monitor dialogs (ProgressMonitorDialog).The utility class ModalContext defines the basic mechanism andUI event loop for modal operations.
Provides JFace support for long-running operations.Package SpecificationLong-running operations must be dealt with specially in order to keep theUI helpful and responsive. Typically this involves temporarily disablingmost controls and displaying a busy cursor and progress indicator; whilethe operation is in progress, the only requests that will be accepted willbe ones to cancel the operation.The IRunnableWithProgress interface should be implemented byany class whose instances are intended to be executed as long-running operations.These objects can then be run in any runnable context (IRunnableContext),including such standard JFace UI components as application windows (ApplicationWindow),wizard dialogs (WizardDialog), and progress monitor dialogs (ProgressMonitorDialog).The utility class ModalContext defines the basic mechanism andUI event loop for modal operations.
Provides JFace support for long-running operations.Package SpecificationLong-running operations must be dealt with specially in order to keep theUI helpful and responsive. Typically this involves temporarily disablingmost controls and displaying a busy cursor and progress indicator; whilethe operation is in progress, the only requests that will be accepted willbe ones to cancel the operation.The IRunnableWithProgress interface should be implemented byany class whose instances are intended to be executed as long-running operations.These objects can then be run in any runnable context (IRunnableContext),including such standard JFace UI components as application windows (ApplicationWindow),wizard dialogs (WizardDialog), and progress monitor dialogs (ProgressMonitorDialog).The utility class ModalContext defines the basic mechanism andUI event loop for modal operations.
Provides JFace support for long-running operations.Package SpecificationLong-running operations must be dealt with specially in order to keep theUI helpful and responsive. Typically this involves temporarily disablingmost controls and displaying a busy cursor and progress indicator; whilethe operation is in progress, the only requests that will be accepted willbe ones to cancel the operation.The IRunnableWithProgress interface should be implemented byany class whose instances are intended to be executed as long-running operations.These objects can then be run in any runnable context (IRunnableContext),including such standard JFace UI components as application windows (ApplicationWindow),wizard dialogs (WizardDialog), and progress monitor dialogs (ProgressMonitorDialog).The utility class ModalContext defines the basic mechanism andUI event loop for modal operations.
Provides JFace support for long-running operations.Package SpecificationLong-running operations must be dealt with specially in order to keep theUI helpful and responsive. Typically this involves temporarily disablingmost controls and displaying a busy cursor and progress indicator; whilethe operation is in progress, the only requests that will be accepted willbe ones to cancel the operation.The IRunnableWithProgress interface should be implemented byany class whose instances are intended to be executed as long-running operations.These objects can then be run in any runnable context (IRunnableContext),including such standard JFace UI components as application windows (ApplicationWindow),wizard dialogs (WizardDialog), and progress monitor dialogs (ProgressMonitorDialog).The utility class ModalContext defines the basic mechanism andUI event loop for modal operations.
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for preferences.Package SpecificationA preference manager (class PreferenceManager) maintainsa tree of preference nodes. Preferences are presented to the enduser in a preference dialog consisting of preference pages.A preference page consists of multiple preference fields, which can bedisplayed and modified though field editors. The framework containsan abstract base class for preference dialogs (PreferenceDialog),and an abstract preference page class (FieldEditorPreferencePage)for hosting these field editors.The individual preference values are maintained in a preference store(IPreferenceStore). Each preference has a current value and adefault value use to (re-)initialize it. The framework provides a concretepreference store implementation (PreferenceStore) based on aninternal java.util.Properties object, with support for persistingthe non-default preference values to files or streams.A field editor presents the value of a single preference to the enduser. The value is loaded from the preference store; if modified by theend user, the value is validated and eventually stored back to the preferencestore.This package contains ready-to-use field editors for various types ofpreferences:BooleanFieldEditor - booleansIntegerFieldEditor - integersStringFieldEditor - text stringsRadioGroupFieldEditor - enumerationsColorFieldEditor - RGB colorsFontFieldEditor - fontsDirectoryFieldEditor - directoriesFileFieldEditor - filesPathEditor - pathsAll field editors are subclasses of the abstract base class FieldEditor;the framework allows new kinds of field editors to be defined by subclassingthis class or one of its subclasses.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Provides a framework for wizards.Package SpecificationA wizard dialog is a specialized window for walking the end user througha sequence of steps; each step is presented on a separate page.At the most abstract level, the protocol is given by 3 interfaces:IWizard - a wizard consisting of several wizard pagesIWizardPage - an individual wizard pageIWizardContainer - the outside world from the point of view ofa wizardA wizard is any object implementing IWizard. The abstract baseclass Wizard is provided as a starting point; it is simpler tosubclass Wizard than to implement IWizard from scratch.The main responsibility of a Wizard subclass is doing the realwork when the wizard finishes.Similarly, a wizard page is any object implementing IWizardPage.The abstract base class WizardPage is provided as a starting point.The main responsibility of a WizardPage subclass is providingthe SWT controls and the backing logic for a single wizard page.WizardDialog is a ready-to-use JFace dialog that is instantiatedwith a wizard and acts as the wizard's container. This dialog has a standardlayout: an area at the top containing the wizard's title, description,and image; the actual wizard page appears in the middle; below it is aprogress indicator; and at the bottom is an area with a message line anda button bar containing Next, Back, Finish, Cancel, and Help buttons.WizardSelectionPage, a special abstract subclass of WizardPage,allows whole other wizards to be connected to a root page.Note: None of the classes in this package maintain global state.&nbsp;
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
Internal classes and helpers to implement the revision model and its UI presentation. Seethe org.eclipse.jface.text.revisionspackage for the API classes implementing the revision model.Contains everything needed to: paint revision information in the vertical ruler adapt the revision information to (quick) diff scriptsThis package is internal and may be subject to change without notice.
This package is a modified copy of org.eclipse.jface.text.contentassist that supports the linked mode proposals.This package is internal and may disappear if the changes are merged with the API content assist package. Subject to change without notice.
This package is a modified copy of org.eclipse.jface.text.contentassist that supports the linked mode proposals.This package is internal and may disappear if the changes are merged with the API content assist package. Subject to change without notice.
This package is a modified copy of org.eclipse.jface.text.contentassist that supports the linked mode proposals.This package is internal and may disappear if the changes are merged with the API content assist package. Subject to change without notice.
This package is a modified copy of org.eclipse.jface.text.contentassist that supports the linked mode proposals.This package is internal and may disappear if the changes are merged with the API content assist package. Subject to change without notice.
This package is a modified copy of org.eclipse.jface.text.contentassist that supports the linked mode proposals.This package is internal and may disappear if the changes are merged with the API content assist package. Subject to change without notice.
This package is a modified copy of org.eclipse.jface.text.contentassist that supports the linked mode proposals.This package is internal and may disappear if the changes are merged with the API content assist package. Subject to change without notice.
This package is a modified copy of org.eclipse.jface.text.contentassist that supports the linked mode proposals.This package is internal and may disappear if the changes are merged with the API content assist package. Subject to change without notice.
This package is a modified copy of org.eclipse.jface.text.contentassist that supports the linked mode proposals.This package is internal and may disappear if the changes are merged with the API content assist package. Subject to change without notice.
This package is a modified copy of org.eclipse.jface.text.contentassist that supports the linked mode proposals.This package is internal and may disappear if the changes are merged with the API content assist package. Subject to change without notice.
This package is a modified copy of org.eclipse.jface.text.contentassist that supports the linked mode proposals.This package is internal and may disappear if the changes are merged with the API content assist package. Subject to change without notice.
This package is a modified copy of org.eclipse.jface.text.contentassist that supports the linked mode proposals.This package is internal and may disappear if the changes are merged with the API content assist package. Subject to change without notice.
This package is a modified copy of org.eclipse.jface.text.contentassist that supports the linked mode proposals.This package is internal and may disappear if the changes are merged with the API content assist package. Subject to change without notice.
This package is a modified copy of org.eclipse.jface.text.contentassist that supports the linked mode proposals.This package is internal and may disappear if the changes are merged with the API content assist package. Subject to change without notice.
This package is a modified copy of org.eclipse.jface.text.contentassist that supports the linked mode proposals.This package is internal and may disappear if the changes are merged with the API content assist package. Subject to change without notice.
This package is a modified copy of org.eclipse.jface.text.contentassist that supports the linked mode proposals.This package is internal and may disappear if the changes are merged with the API content assist package. Subject to change without notice.
This package is a modified copy of org.eclipse.jface.text.contentassist that supports the linked mode proposals.This package is internal and may disappear if the changes are merged with the API content assist package. Subject to change without notice.
This package is a modified copy of org.eclipse.jface.text.contentassist that supports the linked mode proposals.This package is internal and may disappear if the changes are merged with the API content assist package. Subject to change without notice.
This package is a modified copy of org.eclipse.jface.text.contentassist that supports the linked mode proposals.This package is internal and may disappear if the changes are merged with the API content assist package. Subject to change without notice.
This package is a modified copy of org.eclipse.jface.text.contentassist that supports the linked mode proposals.This package is internal and may disappear if the changes are merged with the API content assist package. Subject to change without notice.
This package is a modified copy of org.eclipse.jface.text.contentassist that supports the linked mode proposals.This package is internal and may disappear if the changes are merged with the API content assist package. Subject to change without notice.
This package is a modified copy of org.eclipse.jface.text.contentassist that supports the linked mode proposals.This package is internal and may disappear if the changes are merged with the API content assist package. Subject to change without notice.
This package is a modified copy of org.eclipse.jface.text.contentassist that supports the linked mode proposals.This package is internal and may disappear if the changes are merged with the API content assist package. Subject to change without notice.
This package is a modified copy of org.eclipse.jface.text.contentassist that supports the linked mode proposals.This package is internal and may disappear if the changes are merged with the API content assist package. Subject to change without notice.
This package is a modified copy of org.eclipse.jface.text.contentassist that supports the linked mode proposals.This package is internal and may disappear if the changes are merged with the API content assist package. Subject to change without notice.
This package is a modified copy of org.eclipse.jface.text.contentassist that supports the linked mode proposals.This package is internal and may disappear if the changes are merged with the API content assist package. Subject to change without notice.
This package is a modified copy of org.eclipse.jface.text.contentassist that supports the linked mode proposals.This package is internal and may disappear if the changes are merged with the API content assist package. Subject to change without notice.
This package is a modified copy of org.eclipse.jface.text.contentassist that supports the linked mode proposals.This package is internal and may disappear if the changes are merged with the API content assist package. Subject to change without notice.
This package is a modified copy of org.eclipse.jface.text.contentassist that supports the linked mode proposals.This package is internal and may disappear if the changes are merged with the API content assist package. Subject to change without notice.
This package is a modified copy of org.eclipse.jface.text.contentassist that supports the linked mode proposals.This package is internal and may disappear if the changes are merged with the API content assist package. Subject to change without notice.
This package is a modified copy of org.eclipse.jface.text.contentassist that supports the linked mode proposals.This package is internal and may disappear if the changes are merged with the API content assist package. Subject to change without notice.
This package is a modified copy of org.eclipse.jface.text.contentassist that supports the linked mode proposals.This package is internal and may disappear if the changes are merged with the API content assist package. Subject to change without notice.
This package is a modified copy of org.eclipse.jface.text.contentassist that supports the linked mode proposals.This package is internal and may disappear if the changes are merged with the API content assist package. Subject to change without notice.
This package is a modified copy of org.eclipse.jface.text.contentassist that supports the linked mode proposals.This package is internal and may disappear if the changes are merged with the API content assist package. Subject to change without notice.
This package is a modified copy of org.eclipse.jface.text.contentassist that supports the linked mode proposals.This package is internal and may disappear if the changes are merged with the API content assist package. Subject to change without notice.
This package is a modified copy of org.eclipse.jface.text.contentassist that supports the linked mode proposals.This package is internal and may disappear if the changes are merged with the API content assist package. Subject to change without notice.
This package is a modified copy of org.eclipse.jface.text.contentassist that supports the linked mode proposals.This package is internal and may disappear if the changes are merged with the API content assist package. Subject to change without notice.
This package is a modified copy of org.eclipse.jface.text.contentassist that supports the linked mode proposals.This package is internal and may disappear if the changes are merged with the API content assist package. Subject to change without notice.
This package is a modified copy of org.eclipse.jface.text.contentassist that supports the linked mode proposals.This package is internal and may disappear if the changes are merged with the API content assist package. Subject to change without notice.
This package is a modified copy of org.eclipse.jface.text.contentassist that supports the linked mode proposals.This package is internal and may disappear if the changes are merged with the API content assist package. Subject to change without notice.
This package is a modified copy of org.eclipse.jface.text.contentassist that supports the linked mode proposals.This package is internal and may disappear if the changes are merged with the API content assist package. Subject to change without notice.
This package is a modified copy of org.eclipse.jface.text.contentassist that supports the linked mode proposals.This package is internal and may disappear if the changes are merged with the API content assist package. Subject to change without notice.
This package is a modified copy of org.eclipse.jface.text.contentassist that supports the linked mode proposals.This package is internal and may disappear if the changes are merged with the API content assist package. Subject to change without notice.
This package is a modified copy of org.eclipse.jface.text.contentassist that supports the linked mode proposals.This package is internal and may disappear if the changes are merged with the API content assist package. Subject to change without notice.
This package is a modified copy of org.eclipse.jface.text.contentassist that supports the linked mode proposals.This package is internal and may disappear if the changes are merged with the API content assist package. Subject to change without notice.
This package is a modified copy of org.eclipse.jface.text.contentassist that supports the linked mode proposals.This package is internal and may disappear if the changes are merged with the API content assist package. Subject to change without notice.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
Provides support for bindings between commands and various user input events(e.g., keyboard shortcuts).Package SpecificationThis package provides the common classes and abstract classes required toprovide binding support.All the real work in this package is carried out by theBindingManager, and most work with bindings can be carried outdirectly with it. The binding manager manages a collection of bindings, anddecides which bindings are active at any point in time. By changes the variousproperties of the manager, the active bindings will change. The bindingmanager implements a caching scheme that is optimized for an infreqeuntlychanging set of bindings, but frequently changing properties.The binding manager also manages schemes. A scheme is a grouping of bindings.To create a scheme, use BindingManager.getScheme(String). Thescheme must then be defined before it can be used.If you wish to implement your own type of binding, then you must subclassTrigger and TriggerSequence. Then, simply use thesesubclasses with the BindingManager.
